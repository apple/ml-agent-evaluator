index,text_a,text_b,preferred_text
3689,"n, k = map(int, input().split())
x = list(map(int, list(input().strip())))
y = x[:k] * (n // k) + x[:n % k]
if y < x:
    i = k - 1
    while y[i] == 9:
        y[i] = 0
        i -= 1
    y[i] += 1
    y = y[:k] * (n // k) + y[:n % k]
print(n)
print(''.join(map(str, y)))
","import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,k = list(map(int, input().split()))
a = list(map(int, input()))
b = a[:k]
c = [b[i%k] for i in range(n)]
if tuple(a)>tuple(c):
    d = int("""".join(map(str, b)))
    d += 1
    b = list(map(int, str(d)))
    c = [b[i%k] for i in range(n)]
print(len(c))
print("""".join(map(str, c)))

",text_b
3690,"h, m, s, t1, t2 = map(int, input().split())
h %= 12
t1 %= 12
t2 %= 12
h = h * 3600 + m * 60 + s
t1 *= 3600
t2 *= 3600
m = m * 720 + s * 12
s *= 720
t = [0] * 43200
t[h] = t[m] = t[s] = 1
if t1 > t2:
    t1, t2 = t2, t1
f1 = sum(t[t1:t2]) > 0
f2 = sum(t[t1:43200]) + sum(t[0:t2]) > 0
if f1 ^ f2:
    print(""YES"")
else:
    print(""NO"")
","used = [0] * 121
h, m, s, t1, t2 = map(int, input().split())
h %= 12
t1 %= 12
t2 %= 12
t1 *= 5
t2 *= 5
used[h * 5] = 1
used[h * 5 + 60] = 1
used[m] = 1
used[m + 60] = 1
used[s] = 1
used[s + 60] = 1
if t1 > t2:
    t1, t2 = t2, t1
t3 = t1 + 60
if sum(used[t1:t2]) == 0 or sum(used[t2:t3]) == 0:
    print(""YES"")
else:
    print(""NO"")",text_b
3691,"def dist(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def solve():
    x0, y0, ax, ay, bx, by = map(int, input().split())
    xs, ys, t = map(int, input().split())
    p = [(x0, y0)]
    while True:
        x, y = p[-1]
        nx, ny = ax*x + bx, ay*y + by
        if dist((nx, ny), (xs, ys)) > t:
            break
        p.append((nx, ny))
    ans = 0
    for l in range(len(p)):
        for r in range(l, len(p)):
            d = dist(p[l], p[r]) + min(dist((xs, ys), p[l]), dist((xs, ys), p[r]))
            if d <= t:
                ans = max(ans, r - l + 1)
    print(ans)

solve()
","x0, y0, A, C, B, D = list(map(int, input().split()))

pts = [[x0, y0]]
for i in range(100):
	nx, ny = [pts[-1][0] * A + B, pts[-1][1] * C + D]
	pts.append([nx, ny])
	if max(nx, ny) > 10000000000000000 * 10000000000000000: break


x, y, t = list(map(int, input().split()))
# print (pts[0])
# print (pts[1])
# print (pts[2])
# print (pts[3])
_max = 0
for i in range(len(pts)):
	for j in range(len(pts)):
		if abs(pts[i][0] - pts[j][0]) + abs(pts[i][1] - pts[j][1]) + abs(x - pts[i][0]) + abs(y - pts[i][1]) <= t:
			_max = max(_max, abs(i - j) + 1)
print(_max)
",text_b
3692,"import math

def dist(a, b):
    return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5

def intersect(a, b):
    return dist(a, b) <= a[2] + b[2]

n = int(input().strip())
circles = [list(map(int, input().strip().split())) for _ in range(n)]
edges = 0
for i in range(n):
    for j in range(i + 1, n):
        if intersect(circles[i], circles[j]):
            edges += 1
print(edges + n + 1)
","from math import sqrt
def pt(x):
    print(x)
rd = lambda: map(int, input().split())
n = int(input())
def f(x1, y1, r1, x2, y2, r2):
    a = (r1 + r2) ** 2
    b = (r1 - r2) ** 2
    d = (x1 - x2) ** 2 + (y1 - y2) ** 2
    if d > a:
        return 1
    elif d == a:
        return 4
    elif d < b:
        return 3
    elif d == b:
        return 5
    else:
        return 2
def g(x1, y1, r1, x2, y2, r2):
    ds = (x1 - x2) ** 2 + (y1 - y2) ** 2
    d = sqrt(ds)
    A = (r1 ** 2 - r2 ** 2 + ds) / (2 * d)
    h = sqrt(r1 ** 2 - A ** 2)
    x = x1 + A * (x2 - x1) / d  
    y = y1 + A * (y2 - y1) / d
    x3 = x - h * (y2 - y1) / d  
    y3 = y + h * (x2 - x1) / d
    x4 = x + h * (y2 - y1) / d  
    y4 = y - h * (x2 - x1) / d
    return x3, y3, x4, y4 
if n is 1:
    pt(2)
if n is 2:
    x1, y1, r1 = rd()
    x2, y2, r2 = rd()
    a = f(x1, y1, r1, x2, y2, r2)
    pt(4 if a is 2 else 3)
if n is 3:
    x1, y1, r1 = rd()
    x2, y2, r2 = rd()
    x3, y3, r3 = rd()
    a = f(x1, y1, r1, x2, y2, r2)
    b = f(x1, y1, r1, x3, y3, r3)
    c = f(x3, y3, r3, x2, y2, r2)
    t = [a, b, c]
    t.sort()
    a, b, c = t
    if a is 1 and b is 1 and c in [1, 3, 4, 5]:
        pt(4)
    if a is 1 and b is 1 and c is 2:
        pt(5)
    if a is 1 and b is 2 and c is 2:
        pt(6)
    if a is 1 and b is 2 and c in [3, 4, 5]:
        pt(5)
    if a is 1 and b in [3, 4, 5]:
        pt(4)
    if a is 2 and b is 2 and c is 2:
        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)
        r = 8
        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:
            r -= 1
        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:
            r -= 1
        pt(r)
    if a is 2 and b is 2 and c is 3:
        pt(6)
    if a is 2 and b is 2 and c in [4, 5]:
        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)
        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:
            pt(6)
        else:
            pt(7)
    if a is 2 and b is 3:
        pt(5)
    if a is 2 and b in [4, 5]:
        pt(6)
    if a is 3 and b in [3, 4, 5]:
        pt(4)
    if a is 4 and b is 4 and c is 4:
        pt(5)
    if a is 4 and b is 4 and c is 5:
        pt(4)
    if a is 4 and b is 5 and c is 5:
        pt(5)
    if a is 5 and b is 5 and c is 5:
        pt(4)",text_b
3693,"from shapely.geometry import Polygon

def do_squares_intersect(square1, square2):
    # Create Polygon objects from the squares' coordinates
    square1 = Polygon([(square1[i], square1[i+1]) for i in range(0, len(square1), 2)])
    square2 = Polygon([(square2[i], square2[i+1]) for i in range(0, len(square2), 2)])

    # Check if the squares intersect
    if square1.intersects(square2):
        return ""YES""
    else:
        return ""NO""

# Test the function
print(do_squares_intersect([0, 0, 6, 0, 6, 6, 0, 6], [1, 3, 3, 5, 5, 3, 3, 1]))  # Output: YES
print(do_squares_intersect([0, 0, 6, 0, 6, 6, 0, 6], [7, 3, 9, 5, 11, 3, 9, 1]))  # Output: NO
print(do_squares_intersect([6, 0, 6, 6, 0, 6, 0, 0], [7, 4, 4, 7, 7, 10, 10, 7]))  # Output: YES
","a = list(map(int, input().split()))
b = list(map(int, input().split()))
x1 = min(a[0], a[2], a[4], a[6])
x2 = max(a[0], a[2], a[4], a[6])
y1 = min(a[1], a[3], a[5], a[7])
y2 = max(a[1], a[3], a[5], a[7])
d1 = min(b[0] - b[1], b[2] - b[3], b[4] - b[5], b[6] - b[7])
d2 = max(b[0] - b[1], b[2] - b[3], b[4] - b[5], b[6] - b[7])
s1 = min(b[0] + b[1], b[2] + b[3], b[4] + b[5], b[6] + b[7])
s2 = max(b[0] + b[1], b[2] + b[3], b[4] + b[5], b[6] + b[7])
for x in range(-100, 101):
    for y in range(-100, 101):
        d = x - y
        s = x + y
        if x1 <= x <= x2 and y1 <= y <= y2 and s1 <= s <= s2 and d1 <= d <= d2:
            print(""YES"")
            return
print(""NO"")",text_b
3694,"def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()
    if a[0] == a[1] == 0:
        print(""cslnb"")
        return
    for i in range(1, n):
        if a[i] == a[i - 1]:
            if i > 1 and a[i - 2] + 1 == a[i] or i < n - 1 and a[i + 1] == a[i]:
                print(""cslnb"")
                return
            a[i] -= 1
            break
    a.sort()
    s = sum(a)
    s -= n * (n - 1) // 2
    if s % 2 == 0:
        print(""cslnb"")
    else:
        print(""sjfnb"")

solve()
","n = int(input())
a = list(map(int,input().split()))

dupes = 0
dupeVal = -1
d = set()
for el in a:
    if el in d:
        dupes += 1
        dupeVal = el
    else:
        d.add(el)

inPlay = True
if dupes > 1:
    print('cslnb')
    inPlay = False
elif dupes == 1:
    if dupeVal == 0 or (dupeVal - 1) in d:
        print('cslnb')
        inPlay = False

if inPlay:
    finalSum = (n*(n-1))//2
    Sum = sum(a)
    if (Sum - finalSum) % 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
    
",text_b
3695,"import heapq

def dog_show(n, T, t):
    t = [t[i] - i - 1 for i in range(n)]
    heap = []
    ans = 0
    for i in range(n):
        if t[i] < T:
            heapq.heappush(heap, -t[i])
            if len(heap) > T:
                heapq.heappop(heap)
            ans = max(ans, len(heap))
    return ans

n, T = map(int, input().split())
t = list(map(int, input().split()))
print(dog_show(n, T, t))
","n, t = map(int,input().split())
wait = list(map(int,input().split()))
seg = []
for i in range(n):
    # to get the food in wait[i], wait __ seconds before running
    m = max(0, wait[i]-i-1)
    M = t-i-2
    if m > M: continue
    seg.append((m, -1))
    seg.append((M, 1))
seg.sort()

ans = 0
cur = 0
for t, q in seg:
    cur-= q
    ans = max(ans, cur)
print(ans)",text_b
3696,"n = int(input())
a = [[0], [1]]
for i in range(2, n + 2):
    a.append(a[-1] + [0] + a[-2])
print(n)
print(*a[-2])
print(n - 1)
print(*a[-3])
","n = int(input())

a, b = [1], [0]

for i in range(n):
	new_b = a[:]
	a1 = a[:]
	a2 = a[:]
	a1.append(0)
	a2.append(0)
	for i in range(-1, -len(b) - 1, -1):
		a1[i] += b[i]
	for i in range(-1, -len(b) - 1, -1):
		a2[i] -= b[i]
	if max([abs(kek) for kek in a1]) < 2:
		a = a1
	elif max([abs(kek) for kek in a2]) < 2:
		a = a2
	else:
		print(""oops"")
		return
	b = new_b
print(len(a) - 1)
print(*(a[::-1]))
print(len(b) - 1)
print(*(b[::-1]))",text_b
3697,"n, k, m, a = map(int, input().split())
g = list(map(int, input().split()))
votes = [0]*n
for i in range(a):
    votes[g[i]-1] += 1
votes.sort(reverse=True)
if votes[k-1] > m - a:
    for i in range(n):
        if votes[i] > m - a:
            print(1, end=' ')
        else:
            print(3, end=' ')
else:
    for i in range(n):
        if votes[i] >= votes[k-1]:
            print(2, end=' ')
        else:
            print(3, end=' ')
","class State:
  __slots__ = ['candidate', 'votes', 'last_vote']

  def __init__(self, cand, votes, last):
    self.candidate = cand
    self.votes = votes
    self.last_vote = last

  def beats(self, other, extra):
    return self.votes + extra > other.votes

def main():
  candidates, seats, people, voted = map(int, input().split())
  votes = [0 for i in range(candidates)]
  last_vote = [0 for i in range(candidates)]

  if candidates == 1:
    print(1)
    return

  v = list(map(int, input().split()))
  for t in range(voted):
    cand = v[t] - 1
    votes[cand] += 1
    last_vote[cand] = t

  states = [State(i, votes[i], last_vote[i]) for i in range(candidates)]
  states = sorted(states, key = lambda x : (x.votes, -x.last_vote))
  res = [0 for i in range(candidates)]

  for i in range(candidates):
    if i < candidates - seats:
      low = candidates - seats
      if states[i].beats(states[low], people - voted):
        res[states[i].candidate] = 2
      else:
        res[states[i].candidate] = 3
    else:
      extra = people - voted
      other = i - 1
      place = i

      if extra == 0 and states[i].votes == 0:
        res[states[i].candidate] = 3
        continue

      while other >= 0 and extra > 0:
        needed = states[i].votes - states[other].votes + 1
        if needed <= extra:
          extra -= needed;
          place -= 1
          other -= 1
        else:
          break

      res[states[i].candidate] = (1 if place + seats >= candidates and states[i].votes > 0 else 2)

  for i in res:
    print(i, end = ' ')

main()
",text_b
3698,"MOD = 10**9 + 7
C = [[0]*1005 for _ in range(1005)]
dp = [[0]*1005 for _ in range(1005)]
dp2 = [[0]*1005 for _ in range(1005)]
dp2[0][0] = 1
for i in range(1001):
    C[i][0] = 1
    for j in range(1, i+1):
        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD
for i in range(1, 1001):
    dp[i][0] = 1
    for j in range(1, i+1):
        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + 2*dp[i-1][j-1]) % MOD
for i in range(1, 1001):
    for j in range(i+1):
        dp2[i][j] = (dp2[i-1][j] + dp2[i-1][j-1] + dp[i][j]) % MOD
def solve(s, k):
    if k < 0:
        return 0
    if k == 0:
        return 1
    n = len(s)
    ret = 0
    cnt = 0
    for i in range(n):
        if s[i] == '1':
            for j in range(n-i):
                if cnt + j == k-1:
                    ret = (ret + dp2[n-i-1][j]) % MOD
            cnt += 1
    if cnt == k-1:
        ret = (ret + 1) % MOD
    return ret
s = input().strip()
k = int(input().strip())
print(solve(s, k))
","mas = [[] for i in range(1001)]
mas[0].append(1)
mas[0].append(1)
for i in range(1, 1000):
    mas[i].append(1)
    for j in range(1, i):
        mas[i].append((mas[i - 1][j] + mas[i - 1][j - 1]) % (10 ** 9 + 7))
    mas[i].append(1)


def c(k, n):
    if k > n:
        return 0
    if k < 0:
        return 0
    nonlocal mas
    return mas[n][k]


m = [0] * 1000
for i in range(1, 1000):
    nw = i
    t = 0
    while nw != 1:
        nw = sum([int(j) for j in str(bin(nw)[2:])])
        t += 1
    m[i] = t
m[1] = 0
n = input()
k = int(input())
if k >= 6:
    print(0)
    return
if k == 0:
    print(1)
    return
if k == 1:
    print(len(n) - 1)
    return
ans = 0
for kkk in range(1, 1000):
    if m[kkk] == k - 1:
        nw = kkk
        t = 0
        for i in range(len(n)):
            if n[i] == '1':
                ans += c(nw - t, len(n) - 1 - i)
                ans %= 10 ** 9 + 7
                t += 1
        if sum([int(j) for j in n]) == kkk:
            ans += 1
            ans %= 10 ** 9 + 7


print(ans)
",text_b
3699,"import math
def solve():
    ax, ay, bx, by, tx, ty = map(int, input().split())
    n = int(input())
    bottles = []
    for _ in range(n):
        x, y = map(int, input().split())
        bottles.append((x, y, math.hypot(x - tx, y - ty)))
    bottles.sort(key=lambda x: x[2])
    total = sum(x[2] for x in bottles) * 2
    ans = total
    for i in range(n):
        ans = min(ans, total - bottles[i][2] + math.hypot(bottles[i][0] - ax, bottles[i][1] - ay))
    for i in range(n):
        ans = min(ans, total - bottles[i][2] + math.hypot(bottles[i][0] - bx, bottles[i][1] - by))
    for i in range(min(n, 2)):
        for j in range(i + 1, min(n, 2)):
            ans = min(ans, total - bottles[i][2] - bottles[j][2] + math.hypot(bottles[i][0] - ax, bottles[i][1] - ay) + math.hypot(bottles[j][0] - bx, bottles[j][1] - by))
    print(""%.9f"" % ans)

solve()
","from math import *

ax, ay, bx, by, cx, cy = [int(t) for t in input().split()]
n = int(input())
dist = 0
maxv = [[-inf, -inf], [-inf, -inf]]
index = [[0,0], [0,0]]

def update(d, idx, p):
    nonlocal maxv, index
    if d > maxv[p][0]:
        maxv[p][1] = maxv[p][0]
        index[p][1] = index[p][0]
        maxv[p][0] = d
        index[p][0] = idx
    elif d > maxv[p][1]:
        maxv[p][1] = d
        index[p][1] = idx

for i in range(n):
    x, y = [int(t) for t in input().split()]
    bottle_recycle = sqrt((cx - x) ** 2 + (cy - y) ** 2)
    dist += bottle_recycle * 2
    dista = bottle_recycle - sqrt((ax - x) ** 2 + (ay - y) ** 2)
    distb = bottle_recycle - sqrt((bx - x) ** 2 + (by - y) ** 2)
    update(dista, i, 0)
    update(distb, i, 1)

ans = dist - maxv[0][0]
ans = min(ans, dist - maxv[1][0])
if(index[0][0] != index[1][0]):
    ans = min(ans, dist - maxv[0][0] - maxv[1][0])
elif(n > 1):
    ans = min(ans, dist - maxv[0][1] - maxv[1][0], dist - maxv[0][0] - maxv[1][1])
print(ans)",text_b
3700,"def toy_pairs(n, k):
    if k <= 1 or k > 2 * n:
        return 0
    elif k <= n + 1:
        return (k - 1) // 2
    else:
        return (2 * n - k + 1) // 2

n, k = map(int, input().split())
print(toy_pairs(n, k))
","#!/usr/bin/env python3
n, k = list(map(int, input().split()))
ans = max(0, min(n, k - 1) - k // 2)
print(ans)
",text_b
3701,"n, x, y = map(int, input().split())
s = input().strip()
s = s.split('1')
s = [i for i in s if i != '']
cnt = len(s)
if cnt == 0:
    print(0)
else:
    print(min((cnt - 1) * x + y, cnt * y))
","n, x, y = map(int, input().split())
a = input()
cnt = 0
prev = '1'
for ai in a:
  if prev == '1' and ai == '0': cnt += 1
  prev = ai
if cnt == 0:
  print(0)
else:
  print(min(x,y)*(cnt-1)+y)",text_b
3702,"def solve(n, a, d):
    b = 10**6 + a
    e = d
    return b, e

n, a, d = map(int, input().split())
b, e = solve(n, a, d)
print(b, e)
","n,a,d=map(int,input().split())
print(368131125*a%10**9*12*10**9+1,368131125*d%10**9*12*10**9)",text_b
3703,"MOD = 10**9 + 7
MAXN = 10**6 + 5
phi = [0]*MAXN
mark = [0]*MAXN
def sievephi():
    for i in range(1,MAXN):
        phi[i] = i
    mark[1] = 1
    for i in range(2,MAXN):
        if(not mark[i]):
            for j in range(i,MAXN,i):
                mark[j] = i
                phi[j] = phi[j]//i*(i-1)
sievephi()
def f(n):
    if(n<MAXN):
        return phi[n]
    i = 2
    ans = n
    while(i*i<=n):
        if(n%i==0):
            while(n%i==0):
                n//=i
            ans-=ans//i
        i+=1
    if(n>1):
        ans-=ans//n
    return ans%MOD
def g(n):
    i = 1
    ans = 0
    while(i*i<n):
        if(n%i==0):
            ans+=f(i)
            ans%=MOD
            ans+=f(n//i)
            ans%=MOD
        i+=1
    if(i*i==n):
        ans+=f(i)
        ans%=MOD
    return ans
def F(k,n):
    if(k==1):
        return f(n)
    if(k%2==0):
        return g(F(k-1,n))
    else:
        return f(F(k-1,n))
n,k = map(int,input().split())
print(F(k,n))
","from math import sqrt, ceil

MAX_N = 10 ** 6 * 2 


prime = []
isPrime = [True for i in range(MAX_N)]

for i in range(2, MAX_N):
    if isPrime[i]:
        prime.append(i)
        for j in range(i * i, MAX_N, i):
            isPrime[j] = False


def factor(a):
    divs = []
    for i in prime:
        cnt = 0
        while a % i == 0:
            a //= i
            cnt += 1

        if cnt:
            divs.append((i, cnt,))

    if a > 1:
        divs.append((a, 1,))

    return divs


def f(n):
    ans = 1
    for div in factor(n):
        ans *= div[0] ** (div[1] - 1) * (div[0] - 1)

    return ans

def g(n):
    return n

def F(n, k):
    cur = n
    for i in range(1, k + 1):
        #print(i)
        #print(factor(cur))
        if i == 1:
            cur = f(g(cur))
        elif i % 2 == 0:
            cur = g(cur)
        else:
            cur = f(cur)

        #print(i, cur)

        if cur == 1:
            break

    return cur % (10 ** 9 + 7)

n, k = [int(i) for i in input().split(' ')]
#print(factor(n - 1))
print(F(n, k))
",text_b
3704,"import sys
from heapq import *
input = sys.stdin.readline
n = int(input())
seg = []
for _ in range(n):
    s = input().strip()
    if '/' in s:
        s, l = s.split('/')
        l = int(l)
    else:
        s, l = s, 32
    s = s.split('.')
    s = int(s[0]) << 24 | int(s[1]) << 16 | int(s[2]) << 8 | int(s[3])
    seg.append((s, s + (1 << (32 - l)) - 1, l, _))
seg.sort()
st = []
res = []
for l, r, _, i in seg:
    while st and st[-1][1] < r:
        if st[-1][1] > l:
            print(-1)
            exit(0)
        res.append(st.pop())
    if st and st[-1][1] > r:
        if st[-1][0] < l:
            print(-1)
            exit(0)
        res.append((st[-1][0], l - 1, st[-1][2]))
        st[-1] = (l, r, _)
    elif not st or st[-1][1] < l:
        st.append((l, r, _))
while st:
    res.append(st.pop())
res.sort()
print(len(res))
for l, r, _ in res:
    l = [str((l >> 24) & 255), str((l >> 16) & 255), str((l >> 8) & 255), str(l & 255)]
    r = [str((r >> 24) & 255), str((r >> 16) & 255), str((r >> 8) & 255), str(r & 255)]
    if l == r:
        print('.'.join(l))
    else:
        for i in range(4):
            if l[i] != r[i]:
                break
        print('.'.join(l[:i + 1]) + '/' + str(32 - i * 8))
","#!/usr/bin/env python3
# Copied solution

import collections
import sys
import traceback

class Input(object):
    def __init__(self):
        self.fh = sys.stdin

    def next_line(self):
        while True:
            line = sys.stdin.readline()
            if line == '\n':
                continue
            return line


    def next_line_ints(self):
        line = self.next_line()
        return [int(x) for x in line.split()]

    def next_line_strs(self):
        line = self.next_line()
        return line.split()

class Node(object):
    def __init__(self, color, subtree_color):
        self.left = self.right = None
        self.color = color
        self.subtree_color = subtree_color

def list_to_number(list):
    """"""Return (color, bits, number).""""""
    color = 1 if list[0] == '-' else 2
    values = list[1:].split('/')
    bits = 32
    if len(values) == 2:
        bits = int(values[1])
    nums = values[0].split('.')
    number = 0
    for num in nums:
        number = number * 256 + int(num)
    return (color, bits, number)

def add_list_to_tree(tree, list):
    color, bits, number = list_to_number(list)
    shift = 31
    for _ in range(bits):
        tree.subtree_color |= color
        value = (number >> shift) & 1
        if value == 0:
            if not tree.left:
                tree.left = Node(0, 0)
            tree = tree.left
        else:
            if not tree.right:
                tree.right = Node(0, 0)
            tree = tree.right
        shift -= 1
    tree.subtree_color |= color
    tree.color |= color

def check_tree(tree):
    if not tree:
        return True
    if tree.color == 3 or (tree.color and (tree.subtree_color & ~tree.color)):
        return False
    return check_tree(tree.left) and check_tree(tree.right)

def number_to_list(number, bits):
    number <<= (32 - bits)
    values = []
    for _ in range(4):
        #print('number = {}'.format(number))
        values.append(str(number % 256))
        number //= 256
    values = values[::-1]
    return '.'.join(values) + '/' + str(bits)

def get_optimized(tree, optimized, number, bits):
    if not tree or (tree.subtree_color & 1) == 0:
        return
    if tree.subtree_color == 1:
        list = number_to_list(number, bits)
        #print('number_to_list({}, {}) = {}'.format(number, bits, list))
        optimized.append(list)
        return
    get_optimized(tree.left, optimized, number * 2, bits + 1)
    get_optimized(tree.right, optimized, number * 2 + 1, bits + 1)


def get_optimized_lists(lists):
    tree = Node(0, 0)
    for list in lists:
        add_list_to_tree(tree, list)
    if not check_tree(tree):
        return None
    optimized = []
    get_optimized(tree, optimized, 0, 0)
    return optimized


def main():
    input = Input()
    while True:
        try:
            nums = input.next_line_ints()
            if not nums:
                break
            n, = nums
            if n == -1:
                break
            lists = []
            for _ in range(n):
                lists.append(input.next_line_strs()[0])
        except:
            print('read input failed')
        try:
            optimized = get_optimized_lists(lists)
            if optimized is None:
                print(""-1"")
            else:
                print(""{}"".format(len(optimized)))
                for l in optimized:
                    print(""{}"".format(l))
        except:
            traceback.print_exc(file=sys.stdout)
            print('get_min_dist failed')

main()",text_b
3705,"n = int(input())
s = input()
print(min(s.count('8'), n // 11))
","n=int(input())
s=list(input())
print(min(s.count('8'),n//11))",text_b
3706,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [[0]*m for _ in range(n)]
c = [0]*n
d = [0]*m
e = []
if n < m:
    for i in range(n):
        c[i] = min(a[i])
        for j in range(m):
            a[i][j] -= c[i]
        e += ['row '+str(i+1)]*c[i]
    for j in range(m):
        d[j] = max(a[i][j] for i in range(n))
        e += ['col '+str(j+1)]*d[j]
else:
    for j in range(m):
        d[j] = min(a[i][j] for i in range(n))
        for i in range(n):
            a[i][j] -= d[j]
        e += ['col '+str(j+1)]*d[j]
    for i in range(n):
        c[i] = max(a[i])
        e += ['row '+str(i+1)]*c[i]
for i in range(n):
    for j in range(m):
        b[i][j] = c[i]+d[j]
if a != b:
    print(-1)
else:
    print(len(e))
    print('\n'.join(e))
","
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

n,m=list(map(int,input().split()))

realg=[list(map(int,input().split())) for _ in range(n)]
g=[[0]*m for _ in range(n)]

ans=[]

# get differences
f1=min([realg[0][i] for i in range(m)])
for i in range(m):
    for _ in range(realg[0][i]-f1):
        ans.append(""col %d""%(i+1))
    for j in range(n):
        g[j][i]+=realg[0][i]-f1

f2=min([realg[i][0] for i in range(n)])
for i in range(n):
    for _ in range(realg[i][0]-f2):
        ans.append(""row %d""%(i+1))
    for j in range(m):
        g[i][j]+=realg[i][0]-f2

# check
bad=0
floor=realg[0][0]-g[0][0]
for i in range(n):
    for j in range(m):
        if realg[i][j]-g[i][j]!=floor:
            bad=1

if bad: print(""-1"")
else:
    # get floor done
    if n<m:
        for i in range(n):
            for j in range(floor): ans.append(""row %d""%(i+1))
    else:
        for i in range(m):
            for j in range(floor): ans.append(""col %d""%(i+1))
    print(len(ans))
    print(""\n"".join(ans))
",text_b
3707,"import math
n, t, k, d = map(int, input().split())
if math.ceil(n/k)*t > d + t:
    print(""YES"")
else:
    print(""NO"")
","import collections as col
import itertools as its
import sys
import operator
from bisect import bisect_left, bisect_right
from copy import copy, deepcopy
from math import factorial as fact


class Solver:
    def __init__(self):
        pass

    def solve(self):
        n, t, k, d = list(map(int, input().split()))
        n = (n + k - 1) // k
        if d < (n-1) * t:
            print('YES')
        else:
            print('NO')


def __starting_point():
    s = Solver()
    s.solve()

__starting_point()",text_b
3708,This problem cannot be solved using Python because it requires a time complexity of O(n^2) which is not feasible when n is up to 10^9. This problem is more suitable for languages like C++ which can handle larger computations more efficiently.,"__author__ = 'Pavel Mavrin'

n, m = [int(x) for x in input().split()]
a = []
for i in range(m):
    a.append([int(x) - 1 for x in input().split()])

a.sort(key=lambda x: x[0] * n + x[1])
a.append([n - 1, n])

d = [[0, 1]]
r = 0
i = 0
while i < len(a):
    if a[i][0] == r:
        dd = []
        j = 0
        while i < len(a) and a[i][0] == r and j < len(d):
            if a[i][1] < d[j][0]:
                i += 1
            elif a[i][1] == d[j][0]:
                d[j][0] += 1
                if d[j][0] >= d[j][1]:
                    j += 1
                i += 1
            else:
                dd.append([d[j][0], a[i][1]])
                d[j][0] = a[i][1] + 1
                while j < len(d) and d[j][1] <= a[i][1] + 1:
                    j += 1
                if j < len(d):
                    d[j][0] = max(d[j][0], a[i][1] + 1)
        if j < len(d):
            dd.append([d[j][0], n])
        while i < len(a) and (a[i][0] == r):
            i += 1
        d = dd
        r += 1
        if len(d) == 0:
            break
    else:
        r = a[i][0]
        d = [[d[0][0], n]]
    #print(r, i, d)

if len(d) == 0 or d[len(d) - 1][1] < n:
    print(-1)
else:
    print(2 * (n - 1))












",text_b
3709,"n, k = map(int, input().split())
problems = [0] * (1 << k)
for _ in range(n):
    problem = sum(1 << i for i, x in enumerate(input().split()) if x == '1')
    problems[problem] += 1
for mask in range(1 << k):
    if problems[mask] == 0:
        continue
    problems[mask] -= 1
    for submask in range(1 << k):
        if problems[submask] == 0 or bin(mask & submask).count('1') * 2 > bin(mask).count('1'):
            continue
        problems[submask] -= 1
        break
    else:
        print('NO')
        break
else:
    print('YES')
","def bel(mask, bit):
    return (mask & (1 << bit)) != 0
read = lambda: map(int, input().split())
n, k = read()
f = [0] * 100
for i in range(n):
    cur = int(''.join(input().split()), 2)
    cur ^= (1 << k) - 1
    f[cur] = 1
ans = 'NO'
if k == 1:
    if f[1]:
        ans = 'YES'
if k == 2:
    f1 = f2 = 0
    for i in range(4):
        if f[i]:
            if bel(i, 0): f1 = 1
            if bel(i, 1): f2 = 1
    if f1 and f2:
        ans = 'YES'
if k == 3:
    p = [0] * 3
    for i in range(8):
        if f[i]:
            for j in range(3):
                if bel(i, j): p[j] = 1
    for i in range(8):
        if f[i]:
            if bel(i, 0) and bel(i, 1) and p[2]: ans = 'YES'
            if bel(i, 0) and p[1] and bel(i, 2): ans = 'YES'
            if p[0] and bel(i, 1) and bel(i, 2): ans = 'YES'
if k == 4:
    for i in range(16):
        if f[i]:
            for j in range(16):
                if f[j]:
                    if (i | j) == 15:
                        ans = 'YES'
print(ans)",text_b
3710,"from math import gcd
from functools import reduce

def lcm(a, b):
    return a * b // gcd(a, b)

def main():
    n, k = map(int, input().split())
    c = list(map(int, input().split()))
    if k in c:
        print(""Yes"")
    else:
        lcm_val = reduce(lcm, c)
        if lcm_val % k == 0:
            print(""Yes"")
        else:
            print(""No"")

main()
","from math import *
from sys import *
n, k = map(int, stdin.readline().split("" ""))
a = 1;
for c in map(int, stdin.readline().split("" "")):
  a = a * (gcd(k, c)//gcd(a, c))
if a%k == 0:
  print(""Yes"")
else:
  print(""No"")",text_b
3711,"def solve(n, m, k):
    if k > n + m - 2:
        return -1
    if k < n:
        x = n // (k + 1)
    else:
        x = n
    if k < m:
        y = m // (k + 1)
    else:
        y = m
    return max(x, y)

n, m, k = map(int, input().split())
print(solve(n, m, k))
","n,m,k = [int(x) for x in input().split()]

if k+2>n+m:
    print(-1)
else:
    if k >= n:
        alpha = m // (k-n+2)
    else:
        alpha = m * (n // (k+1))
    if k >= m:
        beta = n // (k-m+2)
    else:
        beta = n * (m // (k + 1))
    print(max(alpha, beta))
",text_b
3712,"n = int(input())
a = list(map(int, input().split()))
c = [0]*5
for i in a:
    c[i] += 1
x = min(c[1], c[2])
c[1] -= x
c[2] -= x
if c[1]:
    x += c[1]//3*2
    c[1] %= 3
    if c[1] == 1:
        if c[3] >= 1:
            x += 1
        elif c[4] >= 2:
            x += 2
        else:
            x = -1
    elif c[1] == 2:
        if c[3] >= 2 or (c[3] >= 1 and c[4] >= 1) or c[4] >= 3:
            x += 2
        else:
            x = -1
elif c[2]:
    x += c[2]
print(x)
","#! /usr/bin/env python

n = int(input())
counts = [0] * 5
nums = [int(x) for x in input().split()]
for x in nums:
    counts[x] += 1

s = sum(nums)
if s > 2 and s != 5:
    ans = 0
    if counts[1] >= counts[2]:
        ans += counts[2]
        counts[3] += counts[2]
        counts[1] -= counts[2]
        ans += 2 * (counts[1] // 3)
        counts[3] += counts[1] // 3
        counts[1] %= 3
        if counts[3] > 0:
            ans += counts[1]
        elif counts[1] != 0:
            ans += 2
    else:
        ans += counts[1]
        counts[2] -= counts[1]
        ans += 2 * (counts[2] // 3)
        counts[2] %= 3
        if counts[4] > 0:
            ans += counts[2]
        elif counts[2] != 0:
            ans += 2
    print(ans)
else:
    print(-1)
",text_b
3713,"n = int(input())
s = input()
cnt = 1
for i in range(1, n):
    if s[i] != s[i - 1]:
        cnt += 1
print(min(n, cnt + 2))
","x = int(input())
y = input()
if x <= 3:
    print(x)
    quit()

num1 = 0
num0 = 0
for i in y:
    if i == '1':
        num1 = max(num1, num0+1)
    else:
        num0 = max(num0, num1+1)

maxx = max(num1, num0)
if '11' not in y and '00' not in y:
    print(maxx)
    quit()

print(min(maxx+2, x))",text_b
3714,"from math import gcd
def lcm(a, b):
    return a * b // gcd(a, b)

n = int(input())
a = list(map(int, input().split()))
a = [x-1 for x in a]
b = [0]*n
c = [0]*n
for i in range(n):
    if b[i]:
        continue
    x = i
    while True:
        b[x] = i+1
        c[x] += 1
        x = a[x]
        if b[x] == i+1:
            break
    if b[x] != i+1:
        print(-1)
        exit(0)
    if c[x] % 2 == 0:
        c[x] //= 2
t = 1
for i in range(n):
    t = lcm(t, c[i])
print(t)
","n = int(input())
w = list(map(int, input().split()))
w = [x-1 for x in w]

ws = sorted(w)
for i in range(n):
	if i != ws[i]:
		print(-1)
		return

a = []
vis = [False] * n
for i in range(n):
	if not vis[i]:
		a.append(0)
		j = i
		while not vis[j]:
			a[-1] += 1
			vis[j] = True
			j = w[j]

def gcd(a, b):
	if b == 0:
		return a
	return gcd(b, a % b)

ans = 1
for i in a:
	if i % 2 == 0:
		i //= 2
	ans = ans // gcd(ans, i) * i
print(ans)
",text_b
3715,"n = int(input())
a = list(map(int, input().split()))
dp = [[0]*3 for _ in range(n+1)]
for i in range(1, n+1):
    dp[i][0] = min(dp[i-1])
    if a[i-1] == 1 or a[i-1] == 3:
        dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + 1
    if a[i-1] == 2 or a[i-1] == 3:
        dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + 1
print(n - max(dp[n]))","import sys

inp = sys.stdin
#inp = open('input.txt', 'r')

n = int(inp.readline())
a = list(map(int, inp.readline().split()))


best = [0, 0, 0]
for i in range(n):
    nx_best = [0, 0, 0]
    if a[i] in (1, 3):
        nx_best[1] = max(best[0], best[2]) + 1
    if a[i] in (2, 3):
        nx_best[2] = max(best[0], best[1]) + 1
    nx_best[0] = max(best)

    best = nx_best[:]

print(n - max(best))
",text_b
3716,"def max_lcm(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 6
    elif n % 2 == 1:
        return n * (n - 1) * (n - 2)
    elif n % 3 == 0:
        return (n - 1) * (n - 2) * (n - 3)
    else:
        return n * (n - 1) * (n - 3)

n = int(input())
print(max_lcm(n))
","def gcd(a, b):
    c = a % b
    return gcd(b, c) if c else b

s, a = 0, int(input())
if a < 3: print(a)
else:
    while a ** 3 > s:
        b = a - 1
        while a * b * b > s:
            if gcd(a, b) == 1:
                d = a * b
                c = b - 1
                while d * c > s:
                    if gcd(c, d) == 1: s = d * c
                    c -= 1
            b -= 1
        a -= 1
    print(s)",text_b
3717,"n = int(input())
rects = [list(map(int, input().split())) for _ in range(n)]
x1 = sorted(rects, key=lambda x: x[0])
x2 = sorted(rects, key=lambda x: -x[2])
y1 = sorted(rects, key=lambda x: x[1])
y2 = sorted(rects, key=lambda x: -x[3])
x = max(x1[-1][0], x1[-2][0])
y = max(y1[-1][1], y1[-2][1])
if x <= min(x2[0][2], x2[1][2]) and y <= min(y2[0][3], y2[1][3]):
    print(x, y)
else:
    x = max(x1[-1][0], x1[-3][0])
    y = max(y1[-1][1], y1[-3][1])
    print(x, y)
","def excl_max_list(a):
    first_max = max(a)
    imax = a.index(first_max)
    second_max = max(a[:imax] + a[imax + 1:])
    return [second_max if elem == first_max else first_max for elem in a]

def excl_min_list(a):
    first_min = min(a)
    imin = a.index(first_min)
    second_min = min(a[:imin] + a[imin + 1:])
    return [second_min if elem == first_min else first_min for elem in a]

n = int(input())
rectangles = [tuple(map(int, input().split())) for i in range(n)]
lefts = [l for l, d, r, u in rectangles]
rights = [r for l, d, r, u in rectangles]
downs = [d for l, d, r, u in rectangles]
ups = [u for l, d, r, u in rectangles]

max_lefts = excl_max_list(lefts)
max_downs = excl_max_list(downs)
min_rights = excl_min_list(rights)
min_ups = excl_min_list(ups)

for i in range(n):
    if max_lefts[i] <= min_rights[i] and max_downs[i] <= min_ups[i]:
        print(max_lefts[i], max_downs[i])
        break
",text_b
3718,"n = int(input())
balls = list(map(int, input().split()))
balls = sorted(set(balls))
for i in range(len(balls) - 2):
    if balls[i + 2] - balls[i] == 2:
        print(""YES"")
        exit(0)
print(""NO"")
","n = int(input())
a = sorted(list(set(map(int, input().split()))))

for i in range(2, len(a)):
    if a[i] - a[i - 2] <= 2:
        print('YES')
        break
else:
    print('NO')
",text_b
3719,"from bisect import bisect_left, bisect_right

def solve(n, m, a, b):
    a.sort()
    b.sort()
    ans = 0
    for i in range(n):
        for j in range(i + 1, n + 1):
            l = a[i:j]
            x = len(l)
            y = bisect_right(b, l[-1]) - bisect_left(b, l[0])
            ans = max(ans, min(x + y, m))
    return ans

n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
print(solve(n, m, a, b))
","from collections import Counter
MV = 400020
a = [0] * MV
for i in range(MV):
    a[i] = set()

n ,m = list(map(int , input().split()))

first = list(map(int , input().split()))
second = list(map(int , input().split()))

for fid, f in enumerate(first):
    for sid, s in enumerate(second):
        a[f+s].add(fid + MV)
        a[f+s].add(sid)

a.sort(key = lambda x: -len(x))

b = [len(k) for k in a]

# for k in range(MV):
#     if b[k]>0:
#         print(k, b[k], a[k])

best_res = b[0]
for pos in range(MV):
    for pos2 in range(MV):
        if b[pos] + b [pos2] <= best_res:
            break
        cur = len(a[pos].union(a[pos2]))
        if cur > best_res :
            best_res = cur
print(best_res)
",text_b
3720,"import math

def solve(n):
    grundy = [0, 1, 2, 1, 4, 3, 2, 1, 5, 6, 2, 1, 8, 7, 5, 9, 8, 7, 3, 4, 7, 6, 8, 7, 5, 3, 8, 7, 2, 1, 1]
    primes = [0, 0, 1, 1, 2, 1, 2, 1, 2, 1, 4, 1, 2, 1, 6, 1, 4, 1, 2, 1, 8, 1, 6, 1, 4, 1, 2, 1, 10, 3, 2]
    xor_sum = 0
    for i in range(2, int(math.sqrt(n)) + 1):
        if primes[i] == i:
            cnt = 0
            x = i * i
            while x <= n:
                x *= i
                cnt += 1
            xor_sum ^= grundy[cnt]
    xor_sum ^= max(0, n - sum(primes[:int(math.sqrt(n)) + 1]) * 2)
    return ""Vasya"" if xor_sum else ""Petya""

n = int(input())
print(solve(n))
","from sys import stdin, stdout
import math, collections
mod = 10**9+7

def isPower(n):
    if (n <= 1):
        return True
    for x in range(2, (int)(math.sqrt(n)) + 1):
        p = x
        while (p <= n):
            p = p * x
            if (p == n):
                return True

    return False
n = int(input())
arr = [0,1,2,1,4,3,2,1,5,6,2,1,8,7,5,9,8,7,3,4,7,4,2,1,10,9,3,6,11,12]
ans = arr[int(math.log(n, 2))]
s = int(math.log(n, 2))
for i in range(3, int(n**0.5)+1):
    if not isPower(i):
        ans^=arr[int(math.log(n, i))]
        s+=int(math.log(n, i))
ans^=((n-s)%2)
print(""Vasya"" if ans else ""Petya"")",text_b
3721,"from sys import stdin, stdout
from collections import defaultdict

n, m, q = map(int, stdin.readline().split())
rows = defaultdict(list)
cols = defaultdict(list)
for _ in range(q):
    r, c = map(int, stdin.readline().split())
    rows[r].append(c)
    cols[c].append(r)
visited = [0] * (n + m + 2)
graph = defaultdict(list)
for r in rows:
    for c in rows[r]:
        graph[r].append(n + c)
        graph[n + c].append(r)
for c in cols:
    for r in cols[c]:
        graph[n + c].append(r)
        graph[r].append(n + c)
def dfs(v):
    visited[v] = 1
    for u in graph[v]:
        if not visited[u]:
            dfs(u)
cnt = 0
for v in range(1, n + m + 1):
    if not visited[v]:
        dfs(v)
        cnt += 1
stdout.write(str(cnt - 1) + '\n')
","import sys
n,m,q=map(int,input().split())
p=[-1]*(n+m)
r=[0]*(n+m)
def par(i):
 if p[i]==-1: return i
 p[i]=par(p[i])
 return p[i]
def merge(a,b):
 a,b=par(a),par(b)
 if a==b: return 0
 if r[a]<r[b]:p[a]=b
 elif r[b]<r[a]:p[b]=a
 else:p[a]=b;r[b]+=1
 return 1
v=n+m
for l in sys.stdin.read().strip().split('\n') if q else []:
 a,b=map(int,l.split())
 v-=merge(a-1,b-1+n)
print(v-1)",text_b
3722,"N = int(input())
cAA = input()
cAB = input()
cBA = input()
cBB = input()

MOD = 10**9+7

dp = [[[[0]*2 for _ in range(2)] for _ in range(2)] for _ in range(N+1)]
dp[2][0][0][0] = 1
dp[2][0][0][1] = 1
dp[2][0][1][0] = 1
dp[2][0][1][1] = 1
dp[2][1][0][0] = 1
dp[2][1][0][1] = 1
dp[2][1][1][0] = 1
dp[2][1][1][1] = 1

for i in range(2, N):
    for j in range(2):
        for k in range(2):
            for l in range(2):
                if dp[i][j][k][l] == 0:
                    continue
                if cAA == 'A':
                    dp[i+1][j][k][0] += dp[i][j][k][l]
                    dp[i+1][j][k][0] %= MOD
                else:
                    dp[i+1][1][k][0] += dp[i][j][k][l]
                    dp[i+1][1][k][0] %= MOD
                if cAB == 'A':
                    dp[i+1][j][l][0] += dp[i][j][k][l]
                    dp[i+1][j][l][0] %= MOD
                else:
                    dp[i+1][1][l][0] += dp[i][j][k][l]
                    dp[i+1][1][l][0] %= MOD
                if cBA == 'A':
                    dp[i+1][k][j][0] += dp[i][j][k][l]
                    dp[i+1][k][j][0] %= MOD
                else:
                    dp[i+1][k][1][0] += dp[i][j][k][l]
                    dp[i+1][k][1][0] %= MOD
                if cBB == 'A':
                    dp[i+1][l][j][0] += dp[i][j][k][l]
                    dp[i+1][l][j][0] %= MOD
                else:
                    dp[i+1][l][1][0] += dp[i][j][k][l]
                    dp[i+1][l][1][0] %= MOD

ans = 0
for j in range(2):
    for k in range(2):
        for l in range(2):
            ans += dp[N][j][k][l]
            ans %= MOD
print(ans)
","from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
import math
import bisect
import random
from itertools import permutations, accumulate, combinations, product
import sys
import string
from bisect import bisect_left, bisect_right
from math import factorial, ceil, floor
from operator import mul
from functools import reduce


sys.setrecursionlimit(2147483647)
INF = 10 ** 13
def LI(): return list(map(int, sys.stdin.readline().split()))
def I(): return int(sys.stdin.readline())
def LS(): return sys.stdin.readline().rstrip().split()
def S(): return sys.stdin.readline().rstrip()
def IR(n): return [I() for i in range(n)]
def LIR(n): return [LI() for i in range(n)]
def SR(n): return [S() for i in range(n)]
def LSR(n): return [LS() for i in range(n)]
def SRL(n): return [list(S()) for i in range(n)]
def MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]
mod = 1000000007

#aかbのどちらかは無限に増やせる
n=I()
c1=S()
c2=S()
c3=S()
c4=S()

if n<=3:
    print((1))
    return

if c2==""A"":
    if c1==""A"":
        print((1))
    else:
        dp = [[0] * 2 for _ in range(n - 3)]
        dp[0][0] = 1
        dp[0][1] = 1
        for i in range(1, n - 3):
            dp[i][0] = sum(dp[i - 1]) % mod
            dp[i][1] = dp[i - 1][0]
        if c3==""A"":
            print((sum(dp[-1]) % mod))
        else:
            print((pow(2,n-3,mod)))
else:
    if c4==""B"":
        print((1))
    else:
        dp = [[0] * 2 for _ in range(n - 3)]
        dp[0][0] = 1
        dp[0][1] = 1
        for i in range(1, n - 3):
            dp[i][0] = sum(dp[i - 1]) % mod
            dp[i][1] = dp[i - 1][0]
        if c3==""B"":
            print((sum(dp[-1]) % mod))
        else:
            print((pow(2,n -3,mod)))





",text_b
3723,"from math import sqrt
from collections import Counter

def max_pokemons(n, s):
    counter = Counter(s)
    max_count = max(counter.values())
    for i in range(2, int(sqrt(max(s))) + 1):
        count = sum([counter[j] for j in range(i, max(s) + 1, i)])
        max_count = max(max_count, count)
    return max_count

n = int(input().strip())
s = list(map(int, input().strip().split()))
print(max_pokemons(n, s))
","from collections import Counter
n = int(input())
a = [int(_) for _ in input().split()]
f = Counter(a)
N = 10 ** 5 + 10
p = [0 for i in range(N)]
ans = Counter()
for i in range(2, N):
    if p[i]:
        continue
    for j in range(i, N, i):
        p[j] = 1
        ans[i] += f[j]
print(max(1, ans.most_common(1)[0][1]))
",text_b
3724,"from collections import Counter
from math import factorial as f

MOD = 10**9+7
N = int(input())
S = input()
c = Counter(S)
A, B, C = c['A'], c['B'], c['C']

dp = [[[0]*(C+1) for _ in range(B+1)] for _ in range(A+1)]
dp[0][0][0] = 1
for i in range(A+1):
    for j in range(B+1):
        for k in range(C+1):
            if i > 0:
                dp[i][j][k] += dp[i-1][j][k] * f(i+j+k-1) // (f(i-1)*f(j)*f(k)) % MOD
            if j > 0:
                dp[i][j][k] += dp[i][j-1][k] * f(i+j+k-1) // (f(i)*f(j-1)*f(k)) % MOD
            if k > 0:
                dp[i][j][k] += dp[i][j][k-1] * f(i+j+k-1) // (f(i)*f(j)*f(k-1)) % MOD
            dp[i][j][k] %= MOD

print(sum(dp[i][j][k] for i in range(A+1) for j in range(B+1) for k in range(C+1)) % MOD)
","n = int(input())
s = input()
s = list(map('_ABC'.index, s))
s0 = s[0]

MOD = 10 ** 9 + 7

dp = [0, 0, 0, 0]
dp[s0] = 1

p = 1
while p < n and s[p] == s0:
    p += 1

xor = 0 if p % 2 == 0 else s0

for i, c in enumerate(s[p:], start=p):

    d, e = c % 3 + 1, (c + 1) % 3 + 1

    dp[c] = sum(dp) % MOD
    dp[d], dp[e] = dp[e], dp[d]

    if i == p:
        dp[c] += p // 2
        dp[s[i - 1] ^ c] += (p - 1) // 2
    elif xor == 0:
        dp[c] += 1

    xor ^= c

print((sum(dp) % MOD))
",text_b
3725,"def solve():
    m = int(input())
    h1, a1 = map(int, input().split())
    x1, y1 = map(int, input().split())
    h2, a2 = map(int, input().split())
    x2, y2 = map(int, input().split())
    t1 = -1
    t2 = -1
    t3 = -1
    t4 = -1
    for i in range(m):
        if h1 == a1 and t1 == -1:
            t1 = i
        if h1 == a1 and h2 == a2 and t2 == -1:
            t2 = i
        if h1 == a1 and t3 == -1:
            t3 = i
        if h2 == a2 and t4 == -1:
            t4 = i
        h1 = (x1 * h1 + y1) % m
        h2 = (x2 * h2 + y2) % m
    if t2 != -1:
        print(t2)
    elif t1 != -1 and t4 != -1 and t3 != t1:
        print(t1 + t3 * ((t4 - t1 + t3 - 1) // t3))
    else:
        print(-1)

solve()
","import fractions

def read_data():
    m = int(input())
    h1, a1 = map(int, input().split())
    x1, y1 = map(int, input().split())
    h2, a2 = map(int, input().split())
    x2, y2 = map(int, input().split())
    return m, h1, a1, x1, y1, h2, a2, x2, y2

def solve(m, h1, a1, x1, y1, h2, a2, x2, y2):
    t = 0
    h1s = [-1] * m
    h2s = [-1] * m
    h1s[h1] = 0
    h2s[h2] = 0
    t1 = -1
    t2 = -1
    while h1 != a1 or h2 != a2:
        t += 1
        h1 = (x1 * h1 + y1) % m
        h2 = (x2 * h2 + y2) % m
        if h1s[h1] >= 0 and t1 == -1:
            t1 = h1s[h1]
            s1 = t - t1
            if t2 >= 0:
                break
        else:
            h1s[h1] = t
        if h2s[h2] >= 0 and t2 == -1:
            t2 = h2s[h2]
            s2 = t - t2
            if t1 >= 0:
                break
        else:
            h2s[h2] = t
    if h1 == a1 and h2 == a2:
        return t
    return retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s)

def retrieve(a1, a2, t1, s1, t2, s2, h1s, h2s):
    u1 = h1s[a1]
    u2 = h2s[a2]
    if u1 == -1 or u2 == -1:
        return -1
    if u1 < t1:
        if guess(h2s, u1, t2, s2, a2):
            return u1
        else:
            return -1
    if u2 < t2:
        if guess(h1s, u2, t1, s1, a1):
            return u2
        else:
            return -1
    return find_time(u1, s1, u2, s2)

def guess(hs, u, t, s, a):
    if u <= t:
        return hs[a] == u
    tt = t + (u - t) % s
    return hs[a] == tt

def find_time(u1, s1, u2, s2):
    g = fractions.gcd(s1, s2)
    if abs(u1 - u2) % g:
        return -1
    k1, k2 = extended_euclid(s1, s2, u2-u1, g)
    b = s2 // g
    return (k1 % b) * s1 + u1

def egcd(a, b):
    x, lastx = 0, 1
    y, lasty = 1, 0
    while b:
        q = a // b
        a, b = b, a % b
        x, lastx = lastx - q * x, x
        y, lasty = lasty - q * y, y
    return lastx, lasty

def extended_euclid(a, b, c, g):
    x, y = egcd(a, b)
    return (c // g) * x, (x // g) * y


param = read_data()
print(solve(*param))",text_b
3726,"from collections import deque
def bfs():
    dist=[-1]*(2*n+2)
    dist[0]=0
    q=deque([0])
    while q:
        v=q.popleft()
        for u in g[v]:
            if dist[u]==-1 and cap[v][u]-flow[v][u]>0:
                dist[u]=dist[v]+1
                q.append(u)
    return dist[2*n+1]!=-1

def dfs(v,t,f):
    if v==t:
        return f
    used[v]=True
    for u in g[v]:
        if not used[u] and cap[v][u]-flow[v][u]>0:
            d=dfs(u,t,min(f,cap[v][u]-flow[v][u]))
            if d>0:
                flow[v][u]+=d
                flow[u][v]-=d
                return d
    return 0

def max_flow(s,t):
    flow=0
    while bfs():
        used=[0]*(2*n+2)
        f=dfs(s,t,10**9+7)
        while f:
            flow+=f
            f=dfs(s,t,10**9+7)
    return flow

n=int(input())
x=list(map(int,input().split()))
x.sort()
y=[0]*(2*n+2)
for i in range(n):
    y[2*i+1]=x[i]
    y[2*i+2]=x[i]+1
y=list(set(y))
y.sort()
n=len(y)-1
g=[[] for _ in range(2*n+2)]
cap=[[0]*(2*n+2) for _ in range(2*n+2)]
flow=[[0]*(2*n+2) for _ in range(2*n+2)]
for i in range(1,n+1):
    g[0].append(i)
    g[i].append(0)
    cap[0][i]=1
    g[n+i].append(2*n+1)
    g[2*n+1].append(n+i)
    cap[n+i][2*n+1]=1
for i in range(1,n):
    for j in range(i+1,n+1):
        if y[j]-y[i]>1:
            break
        g[i].append(n+j)
        g[n+j].append(i)
        cap[i][n+j]=1
print(max_flow(0,2*n+1))","import itertools
from math import sqrt
def chunk(a):
    i = 0
    res = []
    while i < len(a):
        res.append(a[i])
        while i != len(a) - 1 and a[i + 1] == a[i] + 1:
            i += 1
        res.append(a[i] + 1)
        i += 1
    return res

def augment(g, src, dest):
    o = [None] * len(g)
    q = [(src, src)]
    while q:
        w = q.pop()
        if o[w[0]] is None:
            o[w[0]] = w[1]
            for s in g[w[0]]:
                if o[s] is None:
                    q.append((s, w[0]))
    if not o[dest]:
        return False
    i = dest
    while i != src:
        g[o[i]].discard(i)
        g[i].add(o[i])
        i = o[i]
    return True

def match(a):
    l = {}
    c = 0
    matches = 0
    for i, j in a:
        if i not in l:
            l[i] = c
            c += 1
        if j not in l:
            l[j] = c
            c += 1
    L = {v: k for k, v in l.items()}
    g = [set() for i in range(len(l) + 2)]
    src = len(l)
    dest = src + 1
    for i, j in a:
        g[src].add(l[i])
        g[l[i]].add(l[j])
        g[l[j]].add(dest)
    while augment(g, src, dest):
        matches += 1
    return matches

def prime(n):
    for i in range(2, min(n, int(sqrt(n) + 7))):
        if n % i == 0:
            return False
    return n > 1

def pairs(b):
    c = []
    for i in b:
        for j in b:
            if i % 2 == 0 and j % 2 == 1 and prime(abs(i - j)):
                c.append((i, j))
    return c

n = int(input())
a = list(map(int, input().split()))
b = chunk(a)
r = match(pairs(b))
e = len(list(filter(lambda x: x % 2 == 0, b)))
o = len(b) - e
print(int(r + 2 * ((e - r) // 2 + (o - r) // 2) + 3 * ((e - r) % 2)))",text_b
3727,"import heapq

def solve():
    a, b, c, d = map(int, input().split())
    nums = [a, b, c, d]
    seq = []
    for i in range(3, -1, -1):
        if nums[i] > 0:
            heapq.heappush(seq, i)
            nums[i] -= 1
            break
    while nums != [0, 0, 0, 0]:
        if len(seq) == 0 or seq[-1] + 1 < seq[0] - 1:
            return ""NO""
        if nums[seq[-1] + 1] > 0:
            heapq.heappush(seq, seq[-1] + 1)
            nums[seq[-1] + 1] -= 1
        elif nums[seq[0] - 1] > 0:
            heapq.heappush(seq, seq[0] - 1)
            nums[seq[0] - 1] -= 1
        else:
            return ""NO""
    return ""YES\n"" + "" "".join(map(str, seq))

print(solve())
","def solve(a, e):
	if not a[e]:
		return False, []
	a = list(a[::])
	ans = [e]
	a[e] -= 1
	for i in range(sum(a)):
		if ans[-1] - 1 >= 0 and a[ans[-1] - 1] > 0:
			v = ans[-1] - 1
			ans.append(v)
			a[v] -= 1
		elif ans[-1] + 1 <= 3 and a[ans[-1] + 1] > 0:
			v = ans[-1] + 1
			ans.append(v)
			a[v] -= 1
		else:
			return False, []
	return True, ans

def main():
	a = list(map(int, input().split()))
	for i in range(4):
		r, b = solve(a, i)
		if r:
			print('YES')
			print(*b)
			return
	print('NO')

main()
",text_b
3728,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [[0]*m for _ in range(m)]
for i in range(n):
    for j in range(m):
        b[a[i][j]-1][j] += 1
for i in range(m):
    for j in range(i+1, m):
        c = b[i][:i] + b[j][i+1:j] + b[i][j+1:] + [b[i][i]+b[j][j]]
        d = b[j][:i] + b[i][i+1:j] + b[j][j+1:] + [b[i][i]+b[j][j]]
        if max(c) <= 1 and max(d) <= 1:
            print('YES')
            exit(0)
print('NO')
","import sys

n, m = list(map(int,input().split()))
g = [list(map(int,input().split())) for _ in range(n)]
for c1 in range(m):
    for c2 in range(c1, m):
        ok = True
        for row in g:
            row[c1], row[c2] = row[c2], row[c1]
            cnt = 0
            for i in range(m):
                if row[i] != i + 1:
                    cnt += 1
                if cnt > 2:
                    break
            row[c1], row[c2] = row[c2], row[c1]
            if cnt > 2:
                ok = False
                break
        if ok:
            print('YES')
            return
print('NO')
",text_b
3729,"import sys
from math import factorial as f
mod = 10**9+7
f,w,h = map(int,input().split())
n = f+w
fact = [1]*(n+1)
for i in range(1,n+1):
    fact[i] = (fact[i-1]*i)%mod
inv = [1]*(n+1)
inv[n] = pow(fact[n],mod-2,mod)
for i in range(n-1,-1,-1):
    inv[i] = (inv[i+1]*(i+1))%mod
def C(n,r):
    if r>n or r<0:
        return 0
    return (fact[n]*inv[r]*inv[n-r])%mod
def solve(f,w,h):
    ans = 0
    for i in range(1,min(f,w)+1):
        if i<h:
            continue
        ans += C(f+w,i)*C(i-1,f)*2
        ans %= mod
    if f>=w and w>=h:
        ans += C(f+w,w)*C(w,f+1)
        ans %= mod
    return ans
print(solve(f,w,h))
","def build_fac():
   nonlocal mod
   fac = [1] * int(3e5 + 1)
   for i in range(1, int(3e5)):
      fac[i] = i*fac[i-1] % mod
   return fac

def inv(x):
   nonlocal mod
   return pow(x, mod-2, mod)

def ncr(n, r):
   nonlocal fac
   if n < 0 or n < r: return 0
   return fac[n]*inv(fac[r])*inv(fac[n-r]) % mod

def cf(f, w, h):
   nonlocal mod
   if w == 0: return 1
   rs = 0
   for k in range(1, min(w//(h+1),f+1)+1):
      rs += ncr(f+1, k) * ncr(w-k*h-1, k-1) % mod
      rs %= mod
   return rs

f, w, h = map(int,input().split(' '))
mod = int(1e9 + 7)

fac = build_fac()
cnt = cf(f, w, h)
rs = cnt*inv(ncr(f+w, w)) % mod

print(rs)",text_b
3730,"n = int(input())
a = list(map(int, input().split()))
a = [0] + a + [1e9 + 7]
f = [0] * (n + 2)
g = [0] * (n + 2)
for i in range(1, n + 1):
    if a[i] > a[i - 1]:
        f[i] = f[i - 1] + 1
    else:
        f[i] = 1
for i in range(n, 0, -1):
    if a[i] < a[i + 1]:
        g[i] = g[i + 1] + 1
    else:
        g[i] = 1
ans = max(f)
for i in range(1, n):
    if a[i - 1] + 1 < a[i + 1]:
        ans = max(ans, f[i - 1] + 1 + g[i + 1])
    else:
        ans = max(ans, f[i - 1] + 1, g[i + 1] + 1)
print(ans)
","n=int(input())
vec=list(map(int,input().split()))
al=[]
otrez=[]
for x in vec:
    if len(al)==0:
        al.append(x)
    elif(x<=al[-1]):
        otrez.append(al)
        al=[x]
    else:
        al.append(x)
otrez.append(al)
maxx=0
if(len(otrez)!=1):
    for i in range(0,len(otrez)-1):
        if(len(otrez[i])==1)or(len(otrez[i+1])==1):
            maxot=len(otrez[i])+len(otrez[i+1])
        elif (otrez[i+1][0]-otrez[i][-2])>1 or (otrez[i+1][1]-otrez[i][-1])>1:
            maxot=len(otrez[i])+len(otrez[i+1])
        else:
            maxot=max([len(otrez[i]),len(otrez[i+1])])+1
        if(maxot>maxx):
            maxx=maxot
    print(maxx)
else:
    print(len(otrez[0]))",text_b
3731,"def solve(a, b, l, r):
    if a > b:
        return min(a, r - l + 1)
    if a == b:
        if a == 1:
            return 1 if l % 2 == r % 2 else 2
        return min(a + 1, r - l + 1)
    if a == 1 and b == 2:
        return 2 if l % 3 != r % 3 or l % 3 == 0 and r % 3 == 0 else 3
    if a == 2 and b == 1:
        return 2 if l % 3 != r % 3 else 3
    if a == 2 and b == 2:
        return 3 if l % 4 != r % 4 or l % 4 == 0 and r % 4 == 0 else 4
    if a == 1:
        return 1 if (r - l + 1) % (2 * b + 2) <= b else 2
    if a == 2:
        return 2 if (r - l + 1) % (2 * b + 2) <= b else 3
    if a == 3:
        return 3 if (r - l + 1) % (2 * b + 2) <= b else 4
    return min(a + b, r - l + 1)

a, b, l, r = map(int, input().split())
print(solve(a, b, l, r))
","a,b,l,r=list(map(int, input().split()))
length=int(l/(a+b))
if a==3 and b==1 and l==4 and r==10:
    print(4)
    return
l-=length*(a+b)
r-=length*(a+b)
if r>=4*a+4*b:
    r=4*a+4*b
if b>=a:
    _A=[]
    for i in range(a):
        _A.append(i+1)
    for i in range(b):
        _A.append(a)
    for i in range(a):
        _A.append(i+1)
    _A[2*a+b-1]+=1
    for i in range(b):
        _A.append(_A[2*a+b-1])
    for i in range(2*a+2*b):
        _A.append(_A[i])
    _B=[]
    for i in range(25):
        _B.append(0)
    cnt=0
    for i in range(r-l+1):
        if _B[_A[l+i-1]]==0:
            cnt+=1
            _B[_A[l+i-1]]=1
else:
    _A=[]
    for i in range(a):
        _A.append(i+1)
    for i in range(b):
        _A.append(a)
    for i in range(a):
        if i+1<=b:
            _A.append(i+1)
        else:
            _A.append(a+i-b+2)
    for i in range(b):
        _A.append(_A[2*a+b-1])
    for i in range(2*a+2*b):
        _A.append(_A[i])
    _B=[]
    for i in range(25):
        _B.append(0)
    cnt=0
    for i in range(r-l+1):
        if _B[_A[l+i-1]]==0:
            cnt+=1
            _B[_A[l+i-1]]=1
# print(_A)
print(cnt)
",text_b
3732,"x, y, m = map(int, input().split())
if max(x, y) >= m:
    print(0)
elif x <= 0 and y <= 0:
    print(-1)
else:
    if x > y:
        x, y = y, x
    ans = 0
    if x < 0:
        t = (-x + y - 1) // y
        x += t * y
        ans += t
    while max(x, y) < m:
        x, y = y, x + y
        ans += 1
    print(ans)
","k = 0
x, y, m = map(int, input().split())
if (y < x):
    x, y = y, x
if (y >= m):
    print(0)
else:
    if (x <= 0) and (y <= 0):
        print(-1)
    else:
        if (x <= 0) and (y > 0):
            if (abs(x) % y > 0):
                k += abs(x) // y + 1
            else:
                k += abs(x) // y
            x = x + y * k
        a = 0
        b = 1
        c = 0
        while (c < 5000000000000000000):
            if (a * x + b * y >= m):
                print(k)
                break
            c = a + b
            a = b
            b = c
            k += 1
        if (c >= 5000000000000000000):
            print(-1)",text_b
3733,"from math import ceil, log2
from collections import Counter

n, I = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
c = Counter(a)
b = list(c.values())
b = [0] + b
for i in range(1, len(b)):
    b[i] += b[i - 1]
k = int(I * 8 / n)
K = min(2 ** k, len(c))
print(min(b[i] - b[i - K] for i in range(K - 1, len(b))))
","N, I = list(map(int, input().split()))
A = sorted([int(a) for a in input().split()])
B = []
j = 0
for i in range(N):
    if i == 0 or A[i] == A[i-1]:
        B.append(j)
    else:
        j += 1
        B.append(j)

def calc(k):
    K = 1<<k
    i = 0
    j = 0
    ma = 0
    while j < N:
        if B[j]-B[i] <= K - 1:
            ma = max(ma, j-i+1)
            j += 1
        else:
            i += 1
    return N-ma

ans = 10**100
for i in range(31):
    if i * N <= 8 * I:
        ans = min(ans, calc(i))

print(ans)


",text_b
3734,"week = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
a = input()
b = input()
if (week.index(b) - week.index(a)) % 7 in [0, 2, 3]:
    print(""YES"")
else:
    print(""NO"")
","a, b = input(), input()
d = {'monday': 1, 'tuesday': 2, 'wednesday': 3, 'thursday': 4, 'friday': 5, 'saturday': 6, 'sunday': 7}
x, y = d[a], d[b]
flag = (y - x) % 7 in {0, 2, 3}
print('YES' if flag else 'NO')
",text_b
3735,"def max_sum(n):
    if n < 10:
        return n
    else:
        return 9 + max_sum(n - 10)

n = int(input())
print(max_sum(n))
","n = int(input())

a = int(str(n)[0])
l = len(str(n)) - 1

val1 = a * 10 ** l - 1
val2 = n - val1

def sd(x):
    return sum(int(d) for d in str(x))

print(sd(val1) + sd(val2))
",text_b
3736,"def is_mirror_word(word):
    mirror_letters = set('AHIMOTUVWXY')
    return word == word[::-1] and set(word) <= mirror_letters

word = input().strip()
print('YES' if is_mirror_word(word) else 'NO')
","s=input()
M={""A"",""H"",""I"",""M"",""O"",""T"",""U"",""V"",""W"",""X"",""Y""}
ans=""YES""
n=len(s)
for i in range(len(s)//2):
    x=s[i]
    y=s[n-i-1]
    if(x!=y or x not in M):
        ans=""NO""
        break
if(n%2==1):
    if(s[n//2] not in M):
        ans=""NO""
print(ans)
    
",text_b
3737,"n = int(input())
a = list(map(int, input().split()))
a.sort()
l = a.count(a[0])
r = a.count(a[-1])
if a[0] == a[-1]:
    print(0)
else:
    print(n - l - r)
","x = int(input())
l = list(map(int, input().split(' ')))
if min(l) == max(l):
    print(0)
else:
    print(x-l.count(min(l))-l.count(max(l)))",text_b
3738,"def main():
    a, b = map(int, input().split())
    s = input().strip()
    n = len(s)
    dx = [0]*n
    dy = [0]*n
    for i in range(n):
        dx[i] = dx[i-1] + (s[i] == 'R') - (s[i] == 'L')
        dy[i] = dy[i-1] + (s[i] == 'U') - (s[i] == 'D')
    for i in range(n):
        x = a - dx[i]
        y = b - dy[i]
        if x*dx[-1] >= 0 and x % dx[-1] == 0 and y*dy[-1] >= 0 and y % dy[-1] == 0 and x//dx[-1] == y//dy[-1]:
            print(""Yes"")
            return
    print(""No"")

main()
","a, b = list(map(int, input().split()))
s = input()
sm = [[0, 0] for i in range(len(s))]
repl = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)}
for i, c in enumerate(s):
    sm[i][0] = sm[i - 1][0] + repl[c][0]
    sm[i][1] = sm[i - 1][1] + repl[c][1]
# a = n * sm[-1][0] + sm[i][0]
for i in range(len(s)):
    na, nb = 0 if sm[-1][0] == 0 else (a - sm[i][0]) // sm[-1][0], 0 if sm[-1][1] == 0 else (b - sm[i][1]) // sm[-1][1]
    if a == na * sm[-1][0] + sm[i][0] and b == nb * sm[-1][1] + sm[i][1] and (0 in sm[-1] or na == nb) and na >= -1 and nb >= -1:
        print('Yes')
        return
print('No')
",text_b
3740,"MOD = 10**9+7
S = int(input())
dp = [0]*(S+1)
dp[0] = 1
for i in range(1, S+1):
    if i-3 >= 0:
        dp[i] = dp[i-1] + dp[i-3]
        dp[i] %= MOD
print(dp[S])
","import sys
input = sys.stdin.readline

from fractions import gcd
import numpy as np

MOD = 10 ** 9 + 7

S = int(input())

M = 10**4

def type_1(S):
    cnt = 0
    # S 2種の桁数k,k+1からなる。さらにk>=9を仮定する。
    # 項数nとすると、kn < S < (k+1)n となる(k,n)の個数を数える
    # まずk > Mとなるものを数える。このとき1<=n<=Mである。
    n = np.arange(1,M+1)
    k_max = (S-1)//n
    k_min = np.maximum(M+1,S//n)
    cnt += np.maximum(0,k_max - k_min + 1).sum()
    # 次に、9<=k<=Mとなるものを数える
    k = np.arange(9,M+1)
    n_max = (S-1)//k
    n_min = S//(k+1) + 1
    cnt += np.maximum(0,n_max-n_min+1).sum()
    return cnt

type_1(S)

def type_2(S):
    # S 1種の桁数からなる。
    cnt = 0
    div = np.arange(1,M+1,dtype=np.int64)
    div = set(div[S%div==0])
    div |= set(S//x for x in div)
    for d in div:
        n = S//d
        # d桁のものをn個使うようにしたい
        if d < 10:
            total = 9 * 10 ** (d-1)
            cnt += max(0,total-n+1)
        else:
            total = 9 * pow(10,int(d)-1,MOD)
            cnt += total-n+1
    return cnt % MOD

def type_3(S):
    cnt = 0
    # S 2種以上の桁数からなる。9桁の数以下しか使わない。
    # ここは適当にいけそう
    for R in range(1,10):
        for L in range(1,R):
            mid = sum(i*9*10**(i-1) for i in range(L+1,R)) # 途中の桁数の寄与
            rest = S - (L+mid+R)
            if rest < 0:
                continue
            # Lが1+x個、Rが1+y個として
            # Lx + Ry = rest, 0<=x<=x_max, 0<=y<=y_max
            x_max = 9*10**(L-1)-1
            y_max = 9*10**(R-1)-1
            g = gcd(L,R)
            if rest % g != 0:
                continue
            L0 = L//g
            R0 = R//g
            rest //= g
            # x mod R0が一意に決まる
            for x0 in range(R0):
                if (L0*x0-rest)%R0 == 0:
                    break
            y0 = (rest-L0*x0)//R0
            # (x0 + tR, y0-tL)として解がパラメータ表示できる
            # 0 <= x0 + tR <= x_max
            t_min = 0
            t_max = (x_max-x0)//R0
            # y0-tL >= 0
            t_max = min(t_max,y0//L0)
            # y0-tL <= y_max iff y0-y_max <= tL
            t_min = max(t_min,(y0-y_max+L-1)//L0)
            cnt += max(0, t_max - t_min + 1)
    return cnt

answer = (type_1(S) + type_2(S) + type_3(S)) % MOD
print(answer)",text_b
3741,"import sys
from collections import defaultdict

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()
    if a[0] == 0:
        print(3)
        return
    b = [0]*61
    for i in range(n):
        for j in range(60, -1, -1):
            if (a[i]>>j)&1:
                if b[j] != 0:
                    print(3)
                    return
                b[j] = i+1
                break
    g = defaultdict(list)
    for i in range(n):
        for j in range(60, -1, -1):
            if (a[i]>>j)&1:
                if b[j] != i+1:
                    g[i+1].append(b[j])
                    g[b[j]].append(i+1)
                break
    ans = 1<<60
    for i in range(1, n+1):
        d = [1<<60]*(n+1)
        d[i] = 0
        q = [(i, 0)]
        while q:
            v, p = q.pop()
            for u in g[v]:
                if u == p:
                    continue
                if d[u] == 1<<60:
                    d[u] = d[v]+1
                    q.append((u, v))
                else:
                    ans = min(ans, d[v]+d[u]+1)
    if ans == 1<<60:
        print(-1)
    else:
        print(ans)

solve()
","from collections import deque
bits = [0] * 64
n = int(input())
data = list([x for x in map(int, input().split()) if x != 0])
n = len(data)
if n == 0:
    print(-1)
    return
for v in data:
    i = 0
    while v != 0:
        bits[i] += v & 1
        i += 1
        v >>= 1
for i in range(64):
    if bits[i] > 2:
        print(3)
        return
graph = [[] for _ in range(n)]
for u in range(n):
    for v in range(u):
        if (data[u] & data[v]) != 0 and u != v:
            graph[v].append(u)
            graph[u].append(v)


def bfs(start):
    group = [-1] * n
    depth = [0] + [-1] * (n - 1)
    for j in range(len(graph[start])):
        to = graph[start][j]
        group[to] = j
        depth[to] = 1
    bfsQ = deque(graph[start])
    minlen = 999999999
    while len(bfsQ) > 0:
        u = bfsQ[0]
        bfsQ.popleft()
        for v in graph[u]:
            if v == start:
                if depth[u] < 2:
                    continue
                return depth[u] + 1
            if group[v] == -1:
                group[v] = group[u]
                depth[v] = depth[u] + 1
                bfsQ.append(v)
            elif group[v] != group[u]:
                newlen = depth[u] + depth[v] + 1
                if newlen < minlen:
                    minlen = newlen
    return minlen


answer = min(list(map(bfs, list(range(n)))))
print(answer if answer <= n else -1)
",text_b
3742,"n = int(input())
a = list(map(int, input().split()))
a = [0] + a + [0]
b = [i for i in range(1, n + 1) if i not in a]
b.sort()
b = [0] + b + [0]
f = [[0] * 105 for _ in range(105)]
for i in range(n + 2):
    for j in range(len(b)):
        if a[i] > 0:
            if i > 0:
                f[i][j] = min(f[i - 1][j] + (a[i] % 2 != a[i - 1] % 2), f[i][j])
            if j > 0:
                f[i][j] = min(f[i - 1][j - 1] + (a[i] % 2 != b[j] % 2), f[i][j])
        else:
            if i > 0:
                f[i][j] = min(f[i - 1][j] + (b[j] % 2 != a[i - 1] % 2), f[i][j])
            if j > 0:
                f[i][j] = min(f[i - 1][j - 1] + (b[j] % 2 != b[j - 1] % 2), f[i][j])
print(min(f[n + 1]))
","import sys
readline = sys.stdin.readline

N = int(readline())
S = list(map(int, readline().split()))
S = [0 if s == 0 else 1 if s & 1 else -1 for s in S]

odd = -(-N//2)
even = N//2
for s in S:
    if s:
        if s == 1:
            odd -= 1
        else:
            even -= 1

inf = 10**9
dpe = [[inf]*(odd+1) for _ in range(even+1)]
dpo = [[inf]*(odd+1) for _ in range(even+1)]
dpe[0][0] = 0
dpo[0][0] = 0

for i in range(N):
    dp2e = [[inf]*(odd+1) for _ in range(even+1)]
    dp2o = [[inf]*(odd+1) for _ in range(even+1)]
    s = S[i]
    for e in range(even+1):
        for o in range(odd+1):
            if s == 1:
                dp2o[e][o] = min(dp2o[e][o], dpo[e][o], 1+dpe[e][o])
            elif s == -1:
                dp2e[e][o] = min(dp2e[e][o], dpe[e][o], 1+dpo[e][o])
            else:
                if o < odd:
                    dp2o[e][o+1] = min(dp2o[e][o+1], dpo[e][o], 1+dpe[e][o])
                if e < even:
                    dp2e[e+1][o] = min(dp2e[e+1][o], dpe[e][o], 1+dpo[e][o])
    dpe = [d[:] for d in dp2e]
    dpo = [d[:] for d in dp2o]

print(min(dpe[even][odd], dpo[even][odd]))",text_b
3743,"def max_colors(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n

n = int(input().strip())
print(max_colors(n))
","n = int(input())
p = 2
while n % p and p ** 2 <= n:
    p += 1
if p ** 2 > n:
    p = n
pw = n.bit_length() // p.bit_length()
while pow(p, pw) < n:
    pw += 1
while pow(p, pw) > n:
    pw -= 1
if pow(p, pw) == n:
    print(p)
else:
    print(1)
",text_b
3744,"import sys
from heapq import *
def solve():
    n, p, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = [(a[i], b[i], i + 1) for i in range(n)]
    c.sort(reverse=True)
    dp = [[0] * (s + 1) for _ in range(p + 1)]
    pre = [[None] * (s + 1) for _ in range(p + 1)]
    for i in range(1, n + 1):
        dp1 = [dp[j][:] for j in range(p + 1)]
        pre1 = [pre[j][:] for j in range(p + 1)]
        for j in range(min(i, p), -1, -1):
            for k in range(min(i - j, s), -1, -1):
                if j + k < i:
                    if dp1[j][k] < dp[j][k] + c[i - 1][1]:
                        dp1[j][k] = dp[j][k] + c[i - 1][1]
                        pre1[j][k] = (j, k, 0)
                if j > 0 and dp1[j][k] < dp[j - 1][k] + c[i - 1][0]:
                    dp1[j][k] = dp[j - 1][k] + c[i - 1][0]
                    pre1[j][k] = (j - 1, k, 1)
                if k > 0 and dp1[j][k] < dp[j][k - 1] + c[i - 1][1]:
                    dp1[j][k] = dp[j][k - 1] + c[i - 1][1]
                    pre1[j][k] = (j, k - 1, 0)
        dp = dp1
        pre = pre1
    print(dp[p][s])
    ans1 = []
    ans2 = []
    j = p
    k = s
    for i in range(n, 0, -1):
        if pre[j][k][2] == 1:
            ans1.append(c[i - 1][2])
            j -= 1
        else:
            ans2.append(c[i - 1][2])
            k -= 1
    print(*ans1)
    print(*ans2)
solve()
","#!/usr/bin/env python3
from itertools import accumulate
from heapq import heappop, heappush


def top(ppl_indices, vals, start):
    Q = []
    res = [0 for i in range(len(ppl_indices))]
    for k, idx in enumerate(ppl_indices):
        heappush(Q, -vals[idx])
        if k >= start:
            res[k] = res[k-1] - heappop(Q)

    return res


n, a_size, b_size = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))

conversion_gain = [y - x for x, y in zip(a, b)]

ordered_by_a = sorted(zip(a, list(range(n))), reverse=True)
prefix_sums_a = list(accumulate([x for x, y in ordered_by_a]))
conversions = top([idx for val, idx in ordered_by_a], conversion_gain, a_size)
rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[a_size:])],
                               b, n - a_size - b_size))) + [0]

sol, top_k = max([(prefix_a + convert + add_bs, idx)
                  for idx, (prefix_a, convert, add_bs)
                  in enumerate(zip(prefix_sums_a[a_size-1:a_size+b_size],
                                   conversions[a_size-1:a_size+b_size],
                                   rest_of_bs))])
top_k += a_size

conversion_ordered_by_a = [(conversion_gain[idx], idx) for val, idx in ordered_by_a]
conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)
converted = [idx for val, idx in conversion_sorted[:top_k-a_size]]
team_a = list(set(idx for val, idx in ordered_by_a[:top_k]) - set(converted))

b_ordered_by_a = [(b[idx], idx) for val, idx in ordered_by_a]
b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)
team_b = converted + [idx for val, idx in b_sorted[:(a_size+b_size) - top_k]]

print(sol)
print("" "".join(str(idx+1) for idx in team_a))
print("" "".join(str(idx+1) for idx in team_b))
",text_b
3745,"n, m = map(int, input().split())
edges = [set() for _ in range(n)]
for _ in range(m):
    u, v = map(int, input().split())
    edges[u - 1].add(v - 1)
    edges[v - 1].add(u - 1)
for i in range(n):
    if len(edges[i]) == n - 1:
        continue
    for j in range(i + 1, n):
        if len(edges[j]) == n - 1:
            continue
        if len(edges[i] & edges[j]) != len(edges[i]) + len(edges[j]) - n + 1:
            print('No')
            exit(0)
s = ['b'] * n
for i in range(n):
    if len(edges[i]) == n - 1:
        continue
    s[i] = 'a'
    for j in edges[i]:
        if s[j] == 'b':
            s[j] = 'c'
print('Yes')
print(''.join(s))
","# -*- coding:utf-8 -*-

""""""

created by shuangquan.huang at 1/17/20

""""""

import collections
import time
import os
import sys
import bisect
import heapq
from typing import List


def solve(N, M, edges):
    if M == N*(N-1)//2:
        return 'a' * N
    
    g = collections.defaultdict(list)
    for u, v in edges:
        g[u].append(v)
        g[v].append(u)

    s = ['', 'a', 'b', 'c']
    for u in range(1, N+1):
        mark = [3 for _ in range(N + 1)]
        mark[0] = 0
        mark[u] = 1
        for v in g[u]:
            mark[v] = 1
    
        for u in range(1, N+1):
            if mark[u] == 3:
                for v in g[u]:
                    if mark[v] == 1:
                        mark[v] = 2
        
        a, b, c = mark.count(1), mark.count(2), mark.count(3)
        if a*(a-1)//2 + b*(b-1)//2 + c*(c-1)//2 + a*b + b*c != M:
            continue
        
        if any([abs(mark[u] - mark[v]) > 1 for u, v in edges]):
            continue
            
        return ''.join([s[mark[v]] for v in range(1, N+1)])
    
    return None
    

N, M = map(int, input().split())
edges = []
for i in range(M):
    u, v = map(int, input().split())
    edges.append((u, v))
    
s = solve(N, M, edges)
if s:
    print('Yes')
    print(s)
else:
    print('No')",text_b
3746,"def solve(n, a, b, c):
    if n == 0:
        return 0
    if dp[n][a][b] != -1:
        return dp[n][a][b]
    dp[n][a][b] = min(solve(n - 1, a, c, b) + t[a][b] + solve(n - 1, c, a, b), solve(n - 1, a, b, c) + t[a][c] + solve(n - 1, b, a, c) + t[c][b] + solve(n - 1, a, b, c))
    return dp[n][a][b]

t = [[0 for _ in range(3)] for _ in range(3)]
dp = [[[-1 for _ in range(3)] for _ in range(3)] for _ in range(41)]
for i in range(3):
    t[i] = list(map(int, input().split()))
n = int(input())
print(solve(n, 0, 1, 2))
","#	!/bin/env python3
#	coding: UTF-8


#	✪ H4WK3yE乡
#	Mohd. Farhan Tahir
#	Indian Institute Of Information Technology and Management,Gwalior

#	Question Link
#	https://codeforces.com/problemset/problem/392/B
#

# ///==========Libraries, Constants and Functions=============///


import sys

inf = float(""inf"")
mod = 1000000007


def get_array(): return list(map(int, sys.stdin.readline().split()))


def get_ints(): return list(map(int, sys.stdin.readline().split()))


def input(): return sys.stdin.readline()

# ///==========MAIN=============///


def main():
    dp = [[[0 for _ in range(3)] for _ in range(3)] for _ in range(43)]
    matrix = [[0 for _ in range(3)] for _ in range(3)]
    for i in range(3):
        matrix[i] = get_array()
    n = int(input())
    for i in range(1, n+1):
        for frm in range(3):
            for to in range(3):
                other = 3-frm-to
                if frm == to:
                    continue
                dp[i][frm][to] = dp[i-1][frm][other]+matrix[frm][to]+dp[i-1][other][to]
                c = dp[i-1][frm][to]+matrix[frm][other] + \
                    dp[i-1][to][frm]+matrix[other][to]+dp[i-1][frm][to]
                dp[i][frm][to] = min(c, dp[i][frm][to])
    print(dp[n][0][2])


def __starting_point():
    main()

__starting_point()",text_b
3747,"def main():
    s = input().strip()
    print(min(s.count('B'), s.count('u')//2, s.count('l'), s.count('b'), s.count('a')//2, s.count('s'), s.count('r')))

main()
","from collections import Counter

def main():
    s = input()

    c = Counter(s)
    w = Counter(""Bulbasaur"")

    ans = 1e9
    for char in w:
        ans = min(ans, c[char] // w[char])

    print(ans)


main()
",text_b
3748,"from collections import Counter

H, W = map(int, input().split())
S = [input() for _ in range(H)]

def check(n, S):
    cnt = Counter(S)
    pair, single = divmod(n, 2)
    for v in cnt.values():
        pair -= v // 2
        single -= v % 2
        if pair < 0 or single < 0:
            return False
    return True

print(""YES"" if check(H, ["""".join(sorted(s)) for s in zip(*S)]) and check(W, S) else ""NO"")
","H, W = list(map(int, input().split()))
Ss = [input() for _ in range(H)]

# 行の入れ替えパターンを生成する（中央付近から埋めていく）
def dfs(iR):
    # 全て埋まったら、判定に移る
    if iR < 0:
        return check()

    # 未使用の行を検索する
    iF = flgs.index(False)
    Rs[iR] = iF - offset
    flgs[iF] = True

    # ペアの相手を決めて、次のペア生成に移る
    ans = False
    for iF2, flg in enumerate(flgs):
        if not flg:
            Rs[H - 1 - iR] = iF2 - offset
            flgs[iF2] = True
            ans = ans or dfs(iR - 1)
            flgs[iF2] = False

    flgs[iF] = False

    return ans


# 与えられた行の入れ替えパターンに対して、列の入れ替えのみで点対称にできるかを判定する
def check():

    Ts = [Ss[R] for R in Rs]
    Ts = list(map(list, list(zip(*Ts))))

    # (W+1)/2列目を使用可能かどうか
    if W % 2: flgCenter = True
    else: flgCenter = False

    # 各列に対して、処理を行う
    Used = [False] * W
    for j, T in enumerate(Ts):
        if Used[j]: continue
        for j2, T2 in enumerate(Ts[j + 1:], j + 1):
            # 上下反転したような未使用の列が存在するならば、次の列へ
            if not Used[j2] and T[::-1] == T2:
                Used[j2] = True
                break
        else:
            # 自身が上下対称、かつ、(W+1)/2列目を使用可能ならば、次の列へ
            if T[::-1] == T and flgCenter == True:
                flgCenter = False
            else:
                # この入れ替えパターンでは不可能と判定
                return False

    return True


if H % 2:
    # Hが奇数ならば、先頭にダミーを付加
    flgs = [False] * (H + 1)
    offset = 1
else:
    flgs = [False] * H
    offset = 0

Rs = [-1] * H
if dfs((H - 1) // 2):
    print('YES')
else:
    print('NO')
",text_b
3749,"MOD = 998244353
N, X = input().split()
N = int(N)
A = [int(input(), 2) for _ in range(N)]
X = int(X, 2)
A.sort(key=lambda x: -x.bit_length())

def f(x, y):
    while y:
        x, y = y, x % y
    return x

g = A[0]
for a in A[1:]:
    g = f(g, a)

B = [0]*4001
for i in range(4001):
    B[i] = B[i-1]*2+((g>>i)&1)
    if i < 4000:
        B[i] %= MOD

dp = [[0]*2 for _ in range(4001)]
dp[0][0] = 1
for i in range(4000):
    dp[i+1][0] += dp[i][0]
    if (X>>i)&1:
        dp[i+1][1] += dp[i][0]
    dp[i+1][0] += dp[i][1]
    dp[i+1][1] += dp[i][1]
    dp[i+1][0] %= MOD
    dp[i+1][1] %= MOD

ans = (dp[4000][0]+dp[4000][1])%MOD
if X >= g:
    ans = (ans+pow(2, B[X.bit_length()-1], MOD))%MOD
print(ans)
","#!/usr/bin/env python3
def divmod(f, g):
    assert g
    h = 0
    for i in reversed(list(range(f.bit_length() - g.bit_length() + 1))):
        if f & (1 << (g.bit_length() + i - 1)):
            f ^= g << i
            h ^= 1 << i
    return h, f

def gcd(f, g):
    while g:
        q, r = divmod(f, g)
        f, g = g, r
    return f

import functools
def solve(n, x, a):
    # (g) = (a_1, ..., a_n) is a principal ideal since F_2[x] is a PID
    g = functools.reduce(gcd, a)

    # count h in F_2[x] s.t. h g <= x
    cnt = 0
    h = 0
    for k in reversed(list(range(x.bit_length() - g.bit_length() + 1))):
        bit = 1 << (g.bit_length() + k - 1)
        if (x & bit):
            cnt += 1 << k
        if (x & bit) != (h & bit):
            h ^= g << k
    cnt += (h <= x)
    return cnt % 998244353


def main():
    n, x = input().split()
    n = int(n)
    x = int(x, 2)
    a = [ int(input(), 2) for _ in range(n) ]
    print((solve(n, x, a)))

def __starting_point():
    main()


__starting_point()",text_b
3750,"k, a, b = map(int, input().split())
if a < b:
    a, b = b, a
if a // k == 0:
    print(-1)
elif a // k == 1 and b < k:
    print(-1)
else:
    print(a // k + b // k)
","k, a, b = map(int, input().split())

mx_a = a // k
mx_b = b // k
if mx_a == 0 and b % k != 0:
	print(-1)
elif mx_b == 0 and a % k != 0:
	print(-1)
else:
	print(mx_a + mx_b)",text_b
3751,"def kostya_obfuscation(s):
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    for i in range(len(s)):
        if s[i] > alphabet[i]:
            return 'NO'
    return 'YES'

s = input().strip()
print(kostya_obfuscation(s))
","s = input()

last = -1
for i in range(26):
	c = chr(ord('a') + i)
	kk = s.find(c)
	if kk == -1:
		kk = len(s)
	if kk < last:
		print(""NO"")
		return
	last = kk
print(""YES"")",text_b
3752,"from math import ceil
k, d, t = map(int, input().split())
t *= 2
cycle = ceil(k / d) * d
on = min(k, cycle)
off = cycle - on
if on >= t:
    print(t / 2)
else:
    t -= on
    print(on / 2 + ceil(t / (on + off)) * cycle - (on + off - t % (on + off)) / 2)
","def f(x):
    res = (x // k1) * val
    e = x % k1
    if e <= k:
        res += e
    else:
        res += k + (e - k) / 2
    return res

k, d, t = map(int, input().split())
c = (k - 1) // d + 1
k1 = c * d
rem = -k % d
val = k + rem / 2
l = 0
r = 1e50
for i in range(500):
    m = (l + r) / 2
    if f(m) >= t:
        r = m
    else:
        l = m
print('%.10f' % r)",text_b
3753,"def main():
    n, m = map(int, input().split())
    a = [list(input()) for _ in range(n)]
    dp1 = [[0]*m for _ in range(n)]
    dp2 = [[0]*m for _ in range(n)]
    dp1[0][0] = 1
    dp2[n-1][m-1] = 1
    for i in range(n):
        for j in range(m):
            if a[i][j] == '#':
                continue
            if i > 0:
                dp1[i][j] += dp1[i-1][j]
            if j > 0:
                dp1[i][j] += dp1[i][j-1]
    for i in range(n-1, -1, -1):
        for j in range(m-1, -1, -1):
            if a[i][j] == '#':
                continue
            if i < n-1:
                dp2[i][j] += dp2[i+1][j]
            if j < m-1:
                dp2[i][j] += dp2[i][j+1]
    if dp1[n-1][m-1] == 0:
        print(0)
        return
    for i in range(n):
        for j in range(m):
            if dp1[i][j] > 0 and dp2[i][j] > 0 and dp1[i][j] == dp1[n-1][m-1] and dp2[i][j] == dp2[0][0]:
                print(1)
                return
    print(2)

main()
","import sys
input = sys.stdin.readline

n,m=list(map(int,input().split()))
MAP=[list(input().strip()) for i in range(n)]

from collections import deque
Q=deque()
Q.append([0,0])

while Q:
    x,y=Q.pop()

    if x+1<n and MAP[x+1][y]==""."":
        MAP[x+1][y]=1
        Q.append([x+1,y])

    if y+1<m and MAP[x][y+1]==""."":
        MAP[x][y+1]=1
        Q.append([x,y+1])

Q.append([n-1,m-1])


while Q:
    x,y=Q.pop()

    if x-1>=0 and MAP[x-1][y]==1:
        MAP[x-1][y]=0
        Q.append([x-1,y])

    if y-1>=0 and MAP[x][y-1]==1:
        MAP[x][y-1]=0
        Q.append([x,y-1])

if MAP[n-1][m-1]!=1:
    print(0)
    return

SCORE=[0]*(n+m+5)

for i in range(n):
    for j in range(m):
        if MAP[i][j]==0:
            SCORE[i+j]+=1

if 1 in SCORE:
    print(1)
else:
    print(2)
    
",text_b
3754,"import sys
input = sys.stdin.readline
mod = 998244353
N = int(input())
d = list(map(int,input().split()))
d.sort()
d.append(0)
d = [0] + d
fact = [1]*(N+1)
inv = [1]*(N+1)
for i in range(1,N+1):
    fact[i] = fact[i-1]*i%mod
    inv[i] = pow(fact[i],mod-2,mod)
def comb(n,k):
    return fact[n]*inv[k]*inv[n-k]%mod
ans = 0
for i in range(1,N+1):
    if d[i] >= N:
        ans += comb(N,i)*fact[i]%mod*fact[N-i]%mod
        ans %= mod
    else:
        ans += comb(N,i)*fact[i]%mod*fact[N-i-1]%mod*d[i]%mod
        ans %= mod
print(ans)
","P,a,I=998244353,1,input
n=int(I())
d=list(map(int,I().split()))
s=sum(d)%P
for i in d:a=a*i%P
for i in range(n,2*n-2):a=a*(s-i)%P
print(a)",text_b
3755,"N = int(input())
A = list(map(int, input().split()))

if max(A) <= 0:
    idx = A.index(max(A))
    print(A[idx])
    print(N-1)
    for i in range(idx+1, N):
        print(N)
    for i in range(idx):
        print(1)
else:
    dp = [[-10**18]*N for _ in range(N)]
    for i in range(N):
        dp[i][i] = A[i]
    for i in range(N-1):
        if dp[i][i] > 0:
            dp[i+1][i+1] = max(dp[i+1][i+1], dp[i][i] + A[i+1])
        dp[i+1][i] = max(dp[i+1][i], dp[i][i])
    ans = max(dp[i][i] for i in range(N))
    print(ans)
    idx = [i for i in range(N) if dp[i][i] == ans][-1]
    seq = [idx+1]
    for i in range(idx, 0, -1):
        if dp[i][i] == dp[i-1][i-1] + A[i]:
            seq.append(i)
        else:
            seq.append(i+1)
    print(len(seq))
    for i in seq[::-1]:
        print(i)
","# coding: utf-8
# Your code here!
import sys
readline = sys.stdin.readline
read = sys.stdin.read

n, = map(int,input().split())
*a, = map(int,input().split())

if all(i <= 0 for i in a):
    m = max(a)
    idx = a.index(m)
    print(m)
    print(n-1)
    for i in range(idx):
        print(1)
    for i in range(n-idx-1):
        print(n-idx-i)
    return

even = a[::2]
odd = a[1::2]

se = sum(i for i in even if i > 0)
so = sum(i for i in odd  if i > 0)

res = []
if se < so:
    res.append(1)
    a.pop(0)
    n -= 1
# 0,2,4,6,....-th から
if len(a)%2==0:
    res.append(n)
    a.pop()
    n -= 1
while len(a) > 1:
    n = len(a)
    if a[-1] <= 0:
        res.append(n)
        a.pop()
        res.append(n-1)
        a.pop()
    else:
        if a[-3] > 0:
            res.append(n-1)
            a[-3] += a[-1]
            a.pop()
            a.pop()
        else:
            if len(a) == 3:
                res += [1,1]
                a.pop(0)
                a.pop(0)
            else:
                res.append(n-2)
                a.pop(n-3)
                a.pop(n-3)


assert a[0] == max(se,so)
print(max(se,so))
print(len(res))
print(*res,sep=""\n"")
",text_b
3756,"n, t = map(int, input().split())
s = list(input())
dot = s.index('.')
i = dot + 1
while i < len(s) and s[i] < '5':
    i += 1
if i == len(s):
    print(''.join(s))
else:
    while t > 0 and i > dot:
        if s[i] >= '5':
            s[i] = ''
            if s[i-1] == '.':
                j = i - 2
                while s[j] == '9':
                    s[j] = '0'
                    j -= 1
                s[j] = str(int(s[j]) + 1)
                i -= 2
            else:
                s[i-1] = str(int(s[i-1]) + 1)
                i -= 1
            t -= 1
        else:
            break
    if s[0] == '0':
        s = ['1'] + s
    print(''.join(s).rstrip('.'))
","def main():
    n, t = map(int, input().split())
    s = input()
    dot = s.find('.')
    for i in range(dot + 1, n):
        if s[i] > '4':
            break
    else:
        print(s)
        return
    while t:
        i -= 1
        t -= 1
        if s[i] < '4':
            break
    if i > dot:
        print(s[:i], chr(ord(s[i]) + 1), sep='')
        return
    else:
        l = list(s[dot - 1::-1])
        for i, c in enumerate(l):
            if c == '9':
                l[i] = '0'
            else:
                l[i] = chr(ord(c) + 1)
                break
        else:
            l.append('1')
    print(''.join(reversed(l)))


def __starting_point():
    main()

__starting_point()",text_b
3757,"from math import sqrt
a00, a01, a10, a11 = map(int, input().split())
n0 = int((sqrt(1 + 8 * a00) - 1) / 2)
n1 = int((sqrt(1 + 8 * a11) - 1) / 2)
if n0 * (n0 - 1) // 2 != a00 or n1 * (n1 - 1) // 2 != a11 or n0 + n1 > 1000000:
    print('Impossible')
else:
    if n0 == 0 and n1 == 0:
        if a01 + a10 > 0:
            print('Impossible')
        else:
            print('0')
    elif n0 == 0:
        if a01 + a10 > 0:
            print('Impossible')
        else:
            print('1' * n1)
    elif n1 == 0:
        if a01 + a10 > 0:
            print('Impossible')
        else:
            print('0' * n0)
    else:
        if a01 + a10 != n0 * n1:
            print('Impossible')
        else:
            s = ['0'] * n0 + ['1'] * n1
            for i in range(n1 - 1, -1, -1):
                if a10 >= n0:
                    a10 -= n0
                    s.insert(a10, '1')
                else:
                    s.insert(a10, '1')
                    break
            print(''.join(s))
","import math

def get_cnt(res):
    n = 1 + math.floor(math.sqrt(2 * res))
    if n * (n-1) / 2 == res:
        return n
    else:
        return -1
        
def calc():
    cnt = list(map(int, input().split()))
    if cnt == [0,0,0,0]:
        return '0'

    a = get_cnt(cnt[0])
    b = get_cnt(cnt[3])

    if cnt == [0,0,0,cnt[3]]:
        a = 0
    if cnt == [cnt[0],0,0,0]:
        b = 0

    if a == -1 or b == -1 or (a * b) != (cnt[1] + cnt[2]):
        return ""Impossible""

    ans = ['0'] * (a + b)
    i = 0
    while b > 0:
        while cnt[1] >= b:
            i = i + 1
            cnt[1] -= b
        b -= 1
        ans[i] = '1'
        i += 1
    return ''.join(ans)
            

print(calc())
",text_b
3758,"def check(mid):
    last = [0]*len(p)
    for i in range(len(p)):
        if i == 0:
            last[i] = max(2*a[0], a[-1])
        else:
            j = last[i-1]
            while j < len(a) and a[j] <= p[i] + mid:
                j += 1
            if j == len(a):
                last[i] = max(2*a[-1], p[i] + mid)
            elif a[j] > p[i] + mid and a[j-1] <= p[i] + mid/2:
                last[i] = max(2*a[j-1], p[i] + mid)
            else:
                return False
    return last[-1] <= mid

n = int(input().strip())
s = input().strip()
a = [i for i in range(n) if s[i] == '*']
p = [i for i in range(n) if s[i] == 'P']
l = 0
r = 2*n
while r - l > 1:
    mid = (l + r) // 2
    if check(mid):
        r = mid
    else:
        l = mid
print(r)
","from sys import stdin, stdout

n = int(stdin.readline())
s = stdin.readline().strip()

mins = []
packs = []

for i in range(len(s)):
    if s[i] == '*':
        mins.append(i)
    elif s[i] == 'P':
        packs.append(i)

l, r = -1, 2 * len(s) + 1
while r - l > 1:
    m = (l + r) >> 1
    
    test1 = mins[:]
    test2 = packs[:]
    
    
    while test2 and test1:
        cnt = m
        pos = test2.pop()
        
        if pos > test1[-1]:
            while test1 and abs(pos - test1[-1]) <= cnt:
                cnt -= abs(pos - test1[-1])
                pos = test1[-1]
                test1.pop()
        else:
            cntl, cntr = 0, 0
            
            if abs(test1[-1] - pos) > m:
                break
            
            lpos = (m + pos - test1[-1]) // 2
            rpos = m - 2 * abs(test1[-1] - pos)
            
            lb, rb = -1, len(test1)
            while rb - lb > 1:
                mb = (lb + rb) >> 1
                
                if pos - test1[mb] <= lpos:
                    rb = mb
                else:
                    lb = mb
            
            cntl = len(test1) - rb
            
            lb, rb = -1, len(test1)
            while rb - lb > 1:
                mb = (lb + rb) >> 1
                
                if pos - test1[mb] <= rpos:
                    rb = mb
                else:
                    lb = mb
            
            cntr = len(test1) - rb
            
            cnt = max(cntl, cntr)
            while test1 and cnt:
                test1.pop()
                cnt -= 1
    
    
    if not test1:
        r = m
    else:
        l = m
    
stdout.write(str(r))",text_b
3759,"import math
n = int(input().strip())
if n == 0:
    print(1)
else:
    print(4 * int(n * math.sqrt(2)))","print(max(1, 4 * int(int(input()) * 2 ** 0.5)))
",text_b
3760,"import math
n, m, x, y, a, b = map(int, input().split())
g = math.gcd(a, b)
a //= g
b //= g
l = min(n // a, m // b)
a *= l
b *= l
x1 = max(0, x - (a + 1) // 2)
y1 = max(0, y - (b + 1) // 2)
x2 = x1 + a
y2 = y1 + b
if x2 > n:
    x1 -= x2 - n
    x2 = n
if y2 > m:
    y1 -= y2 - m
    y2 = m
print(x1, y1, x2, y2)
","from fractions import gcd
n, m, x, y, a, b = map(int, input().split())
r = gcd(a, b)
a, b = a // r, b // r
r = min(n // a, m // b)
a, b = a * r, b * r
cx, cy = (a + 1) // 2, (b + 1) // 2
dx, dy = min(n - a, max(cx, x) - cx), min(m - b, max(cy, y) - cy)
print(dx, dy, a + dx, b + dy)",text_b
3761,"import sys
from collections import deque

s = input().strip()
x, y = map(int, input().split())

s = s.split('T')
x_list = [len(s[i]) for i in range(0, len(s), 2)]
y_list = [len(s[i]) for i in range(1, len(s), 2)]

x -= x_list[0]
x_list = x_list[1:]

x_dp = [0]*(8005)
y_dp = [0]*(8005)
x_dp[4002] = 1
y_dp[4002] = 1

for i in x_list:
    nx_dp = [0]*(8005)
    for j in range(8005):
        if x_dp[j]:
            if j+i < 8005:
                nx_dp[j+i] = 1
            if j-i >= 0:
                nx_dp[j-i] = 1
    x_dp = nx_dp

for i in y_list:
    ny_dp = [0]*(8005)
    for j in range(8005):
        if y_dp[j]:
            if j+i < 8005:
                ny_dp[j+i] = 1
            if j-i >= 0:
                ny_dp[j-i] = 1
    y_dp = ny_dp

if x_dp[x+4002] and y_dp[y+4002]:
    print('Yes')
else:
    print('No')
","from sys import setrecursionlimit, stderr
from functools import reduce
from itertools import *
from collections import defaultdict
from bisect import *

def read():
  return int(input())
 
def reads():
  return [int(x) for x in input().split()]

S = input()
x, y = reads()
qs = [len(s) for s in S.split('T')]

def knapsack(xs, target):
  es = {0}
  for x in xs:
    es = {e - x for e in es} | {e + x for e in es}
  return target in es

ans = knapsack(qs[2::2], x-qs[0]) and knapsack(qs[1::2], y)
print(""Yes"" if ans else ""No"")",text_b
3762,"MOD = 10**9 + 7
dp = [[0]*31 for _ in range(31)]
dp[0][0] = 1

for i in range(30):
    for j in range(i+1):
        dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD
        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]*2**j) % MOD

k = int(input())
k = bin(k)[2:][::-1]
n = len(k)

dp2 = [[0]*31 for _ in range(31)]
dp2[0][0] = 1

for i in range(n):
    for j in range(i+1):
        if k[i] == '1':
            for l in range(j+1):
                dp2[i+1][max(j, l+1)] = (dp2[i+1][max(j, l+1)] + dp2[i][j]*dp[i][l]) % MOD
            for l in range(j):
                dp2[i+1][j] = (dp2[i+1][j] + dp2[i][j]*dp[i][l]) % MOD
        else:
            for l in range(j+1):
                dp2[i+1][j] = (dp2[i+1][j] + dp2[i][j]*dp[i][l]) % MOD

print(sum(dp2[n][j] for j in range(n+1)) % MOD)
","from math import factorial
MOD = 10**9+7

k = int(input())
bink = list(map(int, bin(k)[2:]))
N = len(bink)

# dp[i][j][k] = first i bits, j bases,
#   k = 1 if maxor matches k, 0 else
dp = [[[0,0] for j in range(i+2)] for i in range(N+1)]
dp[0][0][1] = 1
for i in range(1, N+1):
    for j in range(i+1):
        # k = 0 -> 0
        dp[i][j][0]+= 2**j * dp[i-1][j][0] # distribute
        if j: dp[i][j][0]+= dp[i-1][j-1][0] # new base
        # k = 1 -> 0
        odd = 2**(j-1) if j else 0
        even = 2**j - odd
        if bink[i-1] == 1:
            dp[i][j][0]+= even * dp[i-1][j][1] # distribute even
        # k = 1 -> 1
        if bink[i-1] == 0:
            dp[i][j][1]+= even * dp[i-1][j][1] # distribute even
        else:
            dp[i][j][1]+= odd * dp[i-1][j][1] # distribute odd
            if j: dp[i][j][1]+= dp[i-1][j-1][1] # new base
ans = sum(map(sum, dp[-1]))
print(ans % MOD)",text_b
3763,"from math import factorial as f
from itertools import permutations as p

def solve(n, a, p):
    a.sort()
    dp = [[0 for _ in range(p+1)] for _ in range(n+1)]
    dp[0][0] = 1
    for i in range(n):
        for j in range(i+1):
            for k in range(p+1):
                dp[j+1][min(p, k+a[i])] += dp[j][k]
                dp[j][k] *= 2
    ans = 0
    for i in range(n+1):
        for j in range(p+1):
            ans += dp[i][j] * i
    return ans / (2**n)

n = int(input())
a = list(map(int, input().split()))
p = int(input())
print(solve(n, a, p))
","import math

n = int(input())
a = [int(x) for x in input().split()]
p = int(input())

sum=0;
for x in range(n):
	sum+=a[x]
if(sum<=p):
	print(n)
else:
	ans=0
	for i in range(n):
		dp = [[[0 for z in range(55)] for y in range(55)] for x in range(55)]
		dp[-1][0][0]=1
		for j in range(n):
			if(j==i):

				for k in range(n):
					for z in range(p+1):
						dp[j][k][z]=dp[j-1][k][z]
				continue

			for k in range(n):

				for z in range(p+1):

					if(z+a[j]<=p):
						dp[j][k+1][z+a[j]]+=dp[j-1][k][z]
					dp[j][k][z]+=dp[j-1][k][z]


		for k in range(n):
			for z in range(p+1):
				if(z+a[i]>p):
					ans+=k*dp[n-1][k][z]*math.factorial(k)*math.factorial(n-k-1)

	print(ans/math.factorial(n))
",text_b
3764,"import heapq

n, k, x = map(int, input().split())
strengths = list(map(int, input().split()))
strengths = [-1 * i for i in strengths]
heapq.heapify(strengths)

for _ in range(k):
    for i in range(n):
        if i % 2 == 0:
            temp = -1 * heapq.heappop(strengths)
            temp ^= x
            heapq.heappush(strengths, -1 * temp)
        else:
            break

print(-1 * min(strengths), -1 * max(strengths))
","n, k, x = list(map(int, input().split()))
rangers = list(map(int, input().split()))

for i in range(min(k, 8 + k%4)):
    rangers.sort()
    rangers = [ rangers[i] if i%2 else rangers[i]^x for i in range(n)]
#    print(rangers)      

rangers.sort()
print(rangers[-1], rangers[0])
",text_b
3765,"import sys
from heapq import *

a, b, h, w, n = map(int, sys.stdin.readline().split())
p = list(map(int, sys.stdin.readline().split()))
p.sort(reverse=True)
p += [1] * (n + 2)

def solve(a, b, h, w):
    if a <= h and b <= w:
        return 0
    if a > h:
        a, h = h, a
    if b > w:
        b, w = w, b
    if a > h:
        a, h = h, a
    if a <= h and b <= w:
        return 0
    if a * b > h * w * p[0] * p[1]:
        return -1
    if a <= h and b * p[0] <= w:
        return 1
    if b <= w and a * p[0] <= h:
        return 1
    if a * p[0] <= h and b * p[1] <= w:
        return 2
    if b * p[0] <= w and a * p[1] <= h:
        return 2
    return 3

print(min(solve(a, b, h, w), solve(a, b, w, h)))
","import sys


MAXV = 100010
d = [0] * MAXV


a, b, h, w, n = list(map(int,input().split()))

arr = input().split()

for it in range(n):
    arr[it] = int(arr[it])

# print(arr)
# print(a, b, h, w, n)

def solve(a, b, h, w, z, product, it):
    # print("">"", a, b, h, w, z, product, it)
    k = 0
    if a % h:
        k = a // h + 1
    else:
        k = a // h

    if k <= z and (product // z) * w >= b:
        print(it)
        return



arr = sorted(arr)
arr = arr[::-1]
# print(arr)

d[1] = 1
solve(a, b, h, w, 1, 1, 0)
solve(a, b, w, h, 1, 1, 0)
product = 1
xxx = 0

for it in range(1, n + 1):
    # arr[it - 1] = int(arr[it - 1])
    product *= arr[it - 1]
    # print(""="", arr[it - 1])

    for j in reversed(list(range(1, MAXV))):
        if not d[j]:
            continue

        x = j * arr[it - 1]
        # x = min(x, MAXV - 1)
        if x < MAXV:
            d[x] = 1
        else:
            if xxx:
                xxx = min(x, xxx)
            else:
                xxx = x
    if xxx:
        solve(a, b, h, w, xxx, product, it)
        solve(a, b, w, h, xxx, product, it)

    for j in range(MAXV):
        if d[j]:
            solve(a, b, h, w, j, product, it)
            solve(a, b, w, h, j, product, it)


print(-1)
",text_b
3766,"import sys
from itertools import combinations

def solve():
    n = int(input())
    cards = set(input().split())
    colors = {'R', 'G', 'B', 'Y', 'W'}
    numbers = {'1', '2', '3', '4', '5'}
    color_hints = [set() for _ in range(5)]
    number_hints = [set() for _ in range(5)]
    for card in cards:
        color, number = card
        color_hints[ord(color) - ord('A')].add(card)
        number_hints[int(number) - 1].add(card)
    for i in range(10):
        for hints in combinations(range(10), i):
            color_hints_to_give = [color_hints[hint] for hint in hints if hint < 5]
            number_hints_to_give = [number_hints[hint - 5] for hint in hints if hint >= 5]
            if len(set.union(*color_hints_to_give, *number_hints_to_give)) == len(cards):
                return i
    return 10

print(solve())
","""""""
Codeforces Round 253 Div 1 Problem A

Author  : chaotic_iak
Language: Python 3.3.4
""""""

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0:
        return inputs
    if mode == 1:
        return inputs.split()
    if mode == 2:
        return [int(x) for x in inputs.split()]

def write(s=""\n""):
    if isinstance(s, list): s = "" "".join(map(str,s))
    s = str(s)
    print(s, end="""")

################################################### SOLUTION
import itertools
covers = itertools.product([0,1], repeat=10)

n, = read()
s = read(1)
a = [0] * 25
colors = ""RGBYW""
for i in s:
    a[colors.index(i[0]) * 5 + int(i[1])-1] |= 1

def check(cover):
    nonlocal a
    unknowns = [0] * 11
    for i in range(25):
        if not a[i]: continue
        id = -1
        if not cover[i%5]: id = 5+i//5
        if not cover[5+i//5]:
            if id == -1:
                id = i%5
            else:
                id = 10
        if id > -1:
            if unknowns[id]: return False
            unknowns[id] = 1
    return True

mn = 99
for i in covers:
    if check(i):
        mn = min(mn, sum(i))

print(mn)",text_b
3767,"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
b.sort()
s = sum(a)
t = 0
k = 0
while s > 0:
    s -= b.pop()
    t += min(s, b[-1])
    k += 1
print(k, t)
","f = lambda: list(map(int, input().split()))
n = int(input())
a, b = f(), f()

d = [[None] * 10001 for i in range(n)]

def g(i, s):
    if s <= 0: return (0, s)
    if i == n: return (1e7, 0)

    if not d[i][s]:
        x, y = g(i + 1, s - b[i])
        d[i][s] = min(g(i + 1, s), (x + 1, y + b[i] - a[i]))
    return d[i][s]

x, y = g(0, sum(a))
print(x, y)",text_b
3768,"x, y = map(int, input().split())
if x < y:
    x, y = y, x
    c = 'B'
else:
    c = 'A'
ans = []
while y:
    q, r = divmod(x, y)
    ans.append((q, c))
    x, y = y, r
    c = 'A' if c == 'B' else 'B'
if x != 1:
    print('Impossible')
else:
    ans[-1] = (ans[-1][0] - 1, ans[-1][1])
    ans.append((1, 'A' if ans[-1][1] == 'B' else 'B'))
    for a, b in ans:
        print(a, b, sep='', end='')
","import sys
read = lambda: list(map(int, sys.stdin.readline().split()))
x, y = read()

res = []
c = 'A'
while x * y > 1:
   k = min(x // y, x - 1)
   if k > 0:
      res.append('{}{}'.format(k, c))
   x, y = y, x - k*y
   c = 'A' if c == 'B' else 'B'

if x == 0 or y == 0:
   print('Impossible')
else:
   print(''.join(res))

",text_b
3769,"MOD = 10**9 + 7

def power(x, y):
    if y == 0:
        return 1
    elif y % 2 == 0:
        return power((x * x) % MOD, y // 2)
    else:
        return (x * power((x * x) % MOD, y // 2)) % MOD

def solve(p, k):
    if k == 0:
        return power(p, p - 1)
    elif k == 1:
        return power(p, p)
    else:
        a = [1]
        x = k
        while x != 1:
            a.append(x)
            x = (x * k) % p
        return power(p, len(a))

p, k = map(int, input().split())
print(solve(p, k))
","def main():
	p, k = list(map(int, input().split()))
	s = 1
	m = pow(10,9)+7
	if k == 0:
		s = pow(p,p-1,m)
	elif k == 1:
		s = pow(p,p,m)
	else:
		o = 1
		n = k
		while n != 1:
			n = k*n %p
			o += 1
		c = (p-1)//o
		s = pow(p,c,m)
	print(s%m)
main()
",text_b
3770,"import sys
from collections import deque
input = sys.stdin.readline

N, M = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
edges = [list(map(int, input().split())) for _ in range(M)]
edges = [[u-1, v-1] for u, v in edges]

G = [[] for _ in range(N)]
for u, v in edges:
    G[u].append(v)
    G[v].append(u)

visited = [False]*N
components = []
for i in range(N):
    if not visited[i]:
        stack = deque([i])
        visited[i] = True
        component = [i]
        while stack:
            v = stack.pop()
            for u in G[v]:
                if not visited[u]:
                    stack.append(u)
                    visited[u] = True
                    component.append(u)
        components.append(component)

dp = [[-float('inf')]*(N+1) for _ in range(len(components)+1)]
dp[0][0] = 0
for i, component in enumerate(components, start=1):
    total_B = sum(B[v] for v in component)
    total_A = sum(A[v] for v in component)
    for j in range(N+1):
        if j >= total_A:
            dp[i][j] = max(dp[i][j], dp[i-1][j-total_A] + total_B)
        dp[i][j] = max(dp[i][j], dp[i-1][j])

print(max(dp[-1]))
","import sys
input = sys.stdin.readline

N,M=map(int,input().split())
A=list(map(int,input().split()))
B=list(map(int,input().split()))

# node : 0<=i<=3*N-1, i:minus i+1: delete i+2: plus
# start : 3*N
# goal : 3*N+1

EDGE=[dict() for i in range(3*N+2)]
V=3*N+2
start=3*N
goal=3*N+1

for i in range(N):
    EDGE[start][3*i] = -B[i] + (1<<30)
    EDGE[3*i][3*i+1] = A[i] + (1<<30)
    EDGE[3*i+1][3*i+2] = B[i] + (1<<30)
    EDGE[3*i+2][goal] = float(""inf"")

for i in range(M):
    x,y=map(int,input().split())
    x-=1
    y-=1

    EDGE[3*x+1][3*y] = float(""inf"")
    EDGE[3*y+1][3*x] = float(""inf"")

ANS=0
while True:
    USED=[0]*V
    ROUTE=[-1]*V
    Q=[(start,float(""inf""))]
    
    while Q: # DFS
        NOW,cost=Q.pop()
        if NOW==goal:
            break

        for to in EDGE[NOW]:
            if USED[to]==0 and EDGE[NOW][to]!=0: 
                ROUTE[to]=NOW
                USED[to]=1
                Q.append((to,min(cost,EDGE[NOW][to])))
    else:
        break
    
    ANS+=cost
    i=goal
    while i!=start: # goalからたどり,Routeを使ってEDGEの更新
        j=ROUTE[i]
        EDGE[j][i]-=cost # 使ったルートをいけなく更新
        if j in EDGE[i]:
            EDGE[i][j]+=cost # 逆向きに進めるようにする.これらを重みつきにすれ普通のフロー
        else:
            EDGE[i][j]=cost
            
        i=j
        
print(-(ANS-(N<<30)))",text_b
3771,"from collections import deque
H, W = map(int, input().split())
G = [list(input()) for _ in range(H)]
INF = 10**9
N = 2*H + 2*W + 2
cap = [[0]*N for _ in range(N)]
cost = [[0]*N for _ in range(N)]
to = [[] for _ in range(N)]
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]
S = 2*H + 2*W
T = S + 1
def add_edge(u, v, c, d):
    cap[u][v] = c
    cap[v][u] = 0
    cost[u][v] = d
    cost[v][u] = -d
    to[u].append(v)
    to[v].append(u)
for i in range(H):
    for j in range(W):
        if G[i][j] == 'o':
            add_edge(2*i, 2*H + 2*j, 1, 1)
            add_edge(2*H + 2*j, 2*i + 1, 1, 0)
            add_edge(2*j, 2*H + 2*i + 1, 1, 1)
            add_edge(2*H + 2*i + 1, 2*j + 1, 1, 0)
        elif G[i][j] == 'S':
            add_edge(S, 2*i, INF, 0)
            add_edge(S, 2*j, INF, 0)
            add_edge(2*i + 1, T, INF, 0)
            add_edge(2*j + 1, T, INF, 0)
        elif G[i][j] == 'T':
            add_edge(2*i, T, INF, 0)
            add_edge(2*j, T, INF, 0)
            add_edge(S, 2*i + 1, INF, 0)
            add_edge(S, 2*j + 1, INF, 0)
res = 0
while True:
    dist = [INF]*N
    dist[S] = 0
    prevv = [0]*N
    preve = [0]*N
    que = deque([(0, S)])
    while que:
        d, v = que.popleft()
        if dist[v] < d:
            continue
        for i, u in enumerate(to[v]):
            if cap[v][u] > 0 and dist[u] > dist[v] + cost[v][u]:
                dist[u] = dist[v] + cost[v][u]
                prevv[u] = v
                preve[u] = i
                que.append((dist[u], u))
    if dist[T] == INF:
        break
    v = T
    while v != S:
        u = prevv[v]
        cap[u][v] -= 1
        cap[v][u] += 1
        v = u
    res += dist[T]
print(res if res < INF else -1)
","from networkx import*
H,*S=open(0)
H,W=map(int,H.split())
g=Graph()
a=g.add_edges_from
for i in range(m:=H*W):
  a([[m*2,h:=i//W],[m*2,w:=i%W+m]]*((c:=S[h][w-m])=='S')+[[h,I:=m*3],[w,I]]*(c=='T'),capacity=I)
  a([[h,w],[w,h]]*(c>'T'),capacity=1)
print([-1,f:=minimum_cut(g,m*2,I)[0]][f<I])",text_b
3772,"def solve(a, b):
    if a % b == 0:
        return a // b
    else:
        return a // b + solve(b, a % b)

a, b = map(int, input().split())
print(solve(a, b))
","a, b = list(map(int, input().split()))
res = 0

while b != 0:
    res += a // b
    a %= b
    a, b = b, a
print(res)
",text_b
3773,"def mex(s):
    i = 0
    while i in s:
        i += 1
    return i

def grundy(a, k):
    if a % k == 0:
        return a // k
    b = a // k * k
    if a - b >= b // k + 1:
        return grundy(a - b // k - 1, k)
    return grundy(b, k)

N = int(input())
G = 0
for _ in range(N):
    a, k = map(int, input().split())
    G ^= grundy(a, k)
if G == 0:
    print(""Aoki"")
else:
    print(""Takahashi"")
","n = int(input())
nim = []
for i in range(n):
  a,k = map(int,input().split())
  while a%k != 0 and a>k:
    t = a//k
    if t+1>=a%k:
      a -= t+1
    else:
      y = a%k
      a -= y//(t+1)*(t+1)
  if a<k:
    x = 0
  elif a%k == 0:
    x = a//k
  nim.append(x)
ans = 0
for i in nim:
  ans ^= i
if ans == 0:
  print(""Aoki"")
else:
  print(""Takahashi"")",text_b
3774,"def solve(n, m):
    if n > m:
        n, m = m, n
    if n == 1:
        if m % 6 <= 3:
            return m // 6 * 6
        else:
            return m // 6 * 6 + 2 * (m % 6 - 3)
    elif n == 2:
        if m in [2, 3, 7]:
            return m
        else:
            return n * m // 2 * 2
    else:
        return n * m // 2 * 2

n, m = map(int, input().split())
print(solve(n, m))
","n, m = list(map(int, input().split()))
if n > m:
  n, m = m, n
if n == 1:
  print(([0, 0, 0, 0, 1, 2][m % 6] + m // 6 * 3) * 2)
  return
if n == 2:
  if m == 2:
    print(0)
  elif m == 3:
    print(4)
  elif m == 7:
    print(12)
  else:
    print(n * m)
  return
print((n * m) // 2 * 2)
",text_b
3775,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [list(map(int, input().split())) for _ in range(m)]
c = [0]*10
d = [0]*10
e = [0]*10
f = [0]*10
for i in range(n):
    c[a[i][0]] += 1
    c[a[i][1]] += 1
    e[a[i][0]] += 1
    e[a[i][1]] += 1
for i in range(m):
    d[b[i][0]] += 1
    d[b[i][1]] += 1
    f[b[i][0]] += 1
    f[b[i][1]] += 1
for i in range(10):
    if c[i] > 0 and d[i] > 0:
        if c[i] > 1:
            for j in range(n):
                if a[j][0] == i or a[j][1] == i:
                    e[a[j][0]] -= 1
                    e[a[j][1]] -= 1
        if d[i] > 1:
            for j in range(m):
                if b[j][0] == i or b[j][1] == i:
                    f[b[j][0]] -= 1
                    f[b[j][1]] -= 1
if max(e) > 1 or max(f) > 1:
    print(-1)
elif sum([1 for i in range(10) if c[i] > 0 and d[i] > 0]) > 1:
    print(0)
else:
    for i in range(10):
        if c[i] > 0 and d[i] > 0:
            print(i)
            break
","
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

n,m=list(map(int,input().split()))

possible1=[set() for _ in range(200)]
possible2=[set() for _ in range(200)]
weird=[0]*15

p1=list(map(int,input().split()))
p2=list(map(int,input().split()))

for i in range(n):
    for j in range(m):
        a=sorted(p1[i*2:i*2+2])
        b=sorted(p2[j*2:j*2+2])
        if a==b: continue
        got=-1
        if a[0] in b: got=a[0]
        if a[1] in b: got=a[1]
        if got==-1: continue
        weird[got]=1
        possible1[a[0]*11+a[1]].add(got)
        possible2[b[0]*11+b[1]].add(got)

if sum(weird)==1:
    print(weird.index(1))
elif max(len(i) for i in possible1)==1 and max(len(i) for i in possible2)==1:
    print(0)
else:
    print(-1)
",text_b
3776,"format = int(input())
time = input()

hours, minutes = map(int, time.split(':'))

if format == 24:
    if hours > 23:
        hours = 10
    if minutes > 59:
        minutes = 10
else:
    if hours > 12 or hours == 0:
        hours = 10
    if minutes > 59:
        minutes = 10

print(""{:02}:{:02}"".format(hours, minutes))
","n = int(input())
s = input().split(':')
if n == 12:
    if s[0] == '00':
        s[0] = '01'
    elif int(s[0]) > 12 and s[0][1] == '0':
        s[0] = '10'
    elif int(s[0]) > 12:
        s[0] = '0' + s[0][1]
else:
    if int(s[0]) > 23:
        s[0] = '0' + s[0][1]
if int(s[1]) > 59:
    s[1] = '0' + s[1][1]
print(':'.join(s))",text_b
3777,"import sys
input = sys.stdin.readline
mod = 10**9+7
n,m = map(int,input().split())
x = int(input())
edge = sorted([list(map(int,input().split())) for _ in range(m)],key=lambda x:x[2])
par = list(range(n+1))
rank = [0]*(n+1)
def find(x):
    if par[x] == x:
        return x
    else:
        par[x] = find(par[x])
        return par[x]
def unite(x,y):
    x = find(x)
    y = find(y)
    if x == y:
        return
    if rank[x] < rank[y]:
        par[x] = y
    else:
        par[y] = x
        if rank[x] == rank[y]:
            rank[x] += 1
def same(x,y):
    return find(x) == find(y)
cnt = [0]*(m+1)
for i in range(m):
    if not same(edge[i][0],edge[i][1]):
        cnt[i+1] = cnt[i]+1
        unite(edge[i][0],edge[i][1])
    else:
        cnt[i+1] = cnt[i]
dp = [[0]*(n+1) for _ in range(m+1)]
dp[0][0] = 1
for i in range(m):
    for j in range(cnt[i]+1):
        if dp[i][j] == 0:
            continue
        if j < cnt[i+1]:
            dp[i+1][j+1] += dp[i][j]
            dp[i+1][j+1] %= mod
        dp[i+1][j] += dp[i][j]*2
        dp[i+1][j] %= mod
ans = 0
for i in range(m):
    if edge[i][2]*cnt[i+1] > x:
        break
    for j in range(cnt[i+1]):
        if edge[i][2]*j+(n-1-j)*edge[i+1][2] <= x:
            ans += dp[i+1][j]
            ans %= mod
print(ans)
","import sys
from operator import itemgetter
readline = sys.stdin.readline

sys.setrecursionlimit(2*10**6)
class UF():
    def __init__(self, num):
        self.par = [-1]*num
        self.size = [1]*num
    def find(self, x):
        if self.par[x] < 0:
            return x
        else:
            x = self.par[x]
            return self.find(x)
    
    def union(self, x, y):
        rx = self.find(x)
        ry = self.find(y)
        if rx != ry:
            if self.par[rx] < self.par[ry]:
                self.par[ry] = rx
                self.size[rx] += self.size[ry] 
            elif self.par[rx] > self.par[ry]:
                self.par[rx] = ry
                self.size[ry] += self.size[rx]
            else:
                self.par[rx] -= 1
                self.par[ry] = rx
                self.size[rx] += self.size[ry]
        return

def parorder(Edge, p):
    N = len(Edge)
    Cs = [None]*N
    par = [0]*N
    par[p] = -1
    stack = [p]
    order = []
    visited = set([p])
    ast = stack.append
    apo = order.append
    while stack:
        vn = stack.pop()
        apo(vn)
        for vf, cost in Edge[vn]:
            if vf in visited:
                continue
            visited.add(vf)
            par[vf] = vn
            Cs[vf] = cost
            ast(vf)
    return par, order, Cs

def getcld(p):
    res = [[] for _ in range(len(p))]
    for i, v in enumerate(p[1:], 1):
        res[v].append(i)
    return res

MOD = 10**9+7
N, M = list(map(int, readline().split()))
X = int(readline())
Edge = []
for _ in range(M):
    a, b, c = list(map(int, readline().split()))
    a -= 1
    b -= 1
    Edge.append((c, a, b))

Edge.sort(key = itemgetter(0))

T = UF(N)

cnt = 0
idx = 0
tEdge = [[] for _ in range(N)]
oEdge = []
mst = 0
while cnt < N-1:
    while True:
        cost, x, y = Edge[idx]
        rx = T.find(x)
        ry = T.find(y)
        idx += 1
        if rx != ry:
            break
        oEdge.append((cost, x, y))
    cnt += 1
    tEdge[x].append((y, cost))
    tEdge[y].append((x, cost))
    mst += cost
    T.union(x, y)
for i in range(idx, M):
    oEdge.append(Edge[i])
    

root = 0
P, L, Cs = parorder(tEdge, root)
#C = getcld(P)

Leng = [0]*N
for i in L[1:]:
    p = P[i]
    Leng[i] = 1 + Leng[p]

Dl = [list(range(N))] + [[P[i] for i in range(N)]]
depth = N.bit_length()
for _ in range(depth-1):
    res = [-1]*N
    for i in range(N):
        a = Dl[-1][i]
        if a != root and a != -1:
            res[i] = Dl[-1][a]
    Dl.append(res)

data = [[0]*N] + [[0 if i == root else Cs[i] for i in range(N)]]

for j in range(depth-1):
    res = [0]*N
    for i in range(N):
        a = Dl[j+1][i]
        if a != root and a != -1 and data[-1][a]:
            res[i] = max(data[-1][i], data[-1][a])
    data.append(res)

def query(u0, v0):
    u, v = u0, v0
    if Leng[u] > Leng[v]:
        u, v = v, u
    dif = Leng[v] - Leng[u]
    res = 0
    for i in range(dif.bit_length()):
        if (1<<i) & dif:
            res = max(res, data[i+1][v])
            v = Dl[i+1][v]
    ll = Leng[u].bit_length()
    for i in range(ll):
        k = ll-1-i
        if Dl[k+1][v] != Dl[k+1][u]:
            res = max(res, data[k+1][v], data[k+1][u])
            u = Dl[k+1][u]
            v = Dl[k+1][v]

    if u != v:
        res = max(res, Cs[v], Cs[u])
        
    return res

if mst == X:
    ans = (pow(2, N-1, MOD) - 2) * pow(2, M-(N-1), MOD) % MOD
else:
    ans = 0
cue = 0
ran = 0
dec = 0
for c, u, v in oEdge:
    me = query(u, v)
    if mst + c - me < X:
        dec += 1
    elif mst + c - me == X:
        cue += 1
    else:
        ran += 1

ans = (ans + 2*(pow(2, cue)-1)*pow(2, ran, MOD))%MOD

print(ans)
",text_b
3778,"import heapq

n = int(input())
a = list(map(int, input().split()))

pq = []
for i in range(n):
    if a[i] > 0:
        heapq.heappush(pq, (-a[i], i+1))

targets = []
prev = 0
while pq:
    hits, col = heapq.heappop(pq)
    hits = -hits
    if hits > prev + 1:
        print(-1)
        exit(0)
    elif hits == prev + 1:
        targets.append((len(targets)+1, col))
    else:
        targets.insert(len(targets)-prev-1, (len(targets)+1, col))
    prev = hits

print(len(targets))
for r, c in targets:
    print(r, c)
","import sys
readline = sys.stdin.readline

N = int(readline())
A = list(map(int, readline().split()))

Ans = []
one = []
tt = []
for i in range(N-1, -1, -1):
    a = A[i]
    if a == 0:
        continue
    if a == 1:
        Ans.append((i, i))
        one.append((i, i))
        continue
    if a == 2:
        if not one:
            Ans = None
            break
        else:
            oi, _ = one.pop()
            Ans.append((oi, i))
            tt.append((oi, i))
            continue
    else:
        if not tt:
            if not one:
                Ans = None
                break
            else:
                oi, wi = one.pop()
                Ans.append((i, wi))
                Ans.append((i, i))
                tt.append((i, i))
        else:
            oi, wi = tt.pop()
            Ans.append((i, wi))
            Ans.append((i, i))
            tt.append((i, i))
        continue

if Ans is None:
    print(-1)
else:
    print(len(Ans))
    if Ans:
        print('\n'.join(f'{a+1} {b+1}' for a, b in Ans))


",text_b
3779,"import math
from functools import reduce
from operator import mul

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    g = reduce(gcd, a)
    if g > 1:
        a = [i // g for i in a]
    g = reduce(gcd, a)
    if g > 1:
        print(1)
        print(0)
    else:
        print(k)
        print(' '.join(map(str, range(k))))

solve()
","import math
n,k=map(int,input().split())
g=k
for a in map(int,input().split()):
 g=math.gcd(g,a)
print(k//g)
print(' '.join(map(str,range(0,k,g))))",text_b
3780,"import math
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    v, t = map(int, input().split())
    vx, vy = map(int, input().split())
    wx, wy = map(int, input().split())
    x2 -= x1 + vx * t
    y2 -= y1 + vy * t
    l = 0
    r = 1e18
    for _ in range(200):
        m = (l + r) / 2
        if m < t:
            if (x2 - vx * m) ** 2 + (y2 - vy * m) ** 2 <= (v * m) ** 2:
                r = m
            else:
                l = m
        else:
            if (x2 - wx * (m - t)) ** 2 + (y2 - wy * (m - t)) ** 2 <= (v * m) ** 2:
                r = m
            else:
                l = m
    print('%.15f' % r)

solve()
","import math
x1, y1, x2, y2 = list(map(int, input().split(' ')[:4]))
u_max, tau = list(map(int, input().split(' ')[:2]))
vx, vy = list(map(int, input().split(' ')[:2]))
wx, wy = list(map(int, input().split(' ')[:2]))

A = (x2 - x1, y2 - y1)
v = (-vx, -vy)
w = (-wx, -wy)

B = (A[0] + tau * v[0], A[1] + tau * v[1])


def solve_sqr_eq(a, b, c):
    d = b**2 - 4*a*c
    if d >= 0:
        return ((-b + math.sqrt(d)) / (2*a), (-b - math.sqrt(d)) / (2*a))
    else:
        return None


a = v[0]**2 + v[1]**2 - u_max**2
b = 2 * A[0] * v[0] + 2 * A[1] * v[1]
c = A[0]**2 + A[1]**2
r = solve_sqr_eq(a, b, c)

if r is not None:
    t1, t2 = r
    t_min = min(t1, t2)
    t_max = max(t1, t2)
    if 0 <= t_min <= tau:
        print(t_min)
        return
    if 0 <= t_max <= tau:
        print(t_max)
        return


a = w[0]**2 + w[1]**2 - u_max**2
b = 2 * B[0] * w[0] + 2 * B[1] * w[1] - u_max**2 * 2 * tau
c = B[0]**2 + B[1]**2 - u_max**2 * tau**2
r = solve_sqr_eq(a, b, c)

if r is not None:
    t1, t2 = r
    t_min = min(t1, t2)
    t_max = max(t1, t2)
    if 0 <= t_min :
        print(t_min + tau)
        return
    if 0 <= t_max:
        print(t_max + tau)
        return
",text_b
3781,"T = int(input())
for _ in range(T):
    N = int(input())
    a = list(map(int, input().split()))
    a.sort()
    sum_a = sum(a)
    if sum_a % 2 == 1 or a[-1] > sum_a - a[-1]:
        print('First')
    else:
        print('Second')
","import sys
input=sys.stdin.readline
from collections import defaultdict

def solve(n,A):
    d=defaultdict(int)
    for a in A:
        d[a]+=1
    flag=True
    for v in d.values():
        if v%2!=0:
            flag=False
            break
    return bool(n%2)^flag

def main():
    t=int(input())
    for _ in range(t):
        n=int(input())
        A=list(map(int,input().split()))
        judge=solve(n,A)
        print('Second' if judge else 'First')
    
def __starting_point():
    main()
__starting_point()",text_b
3782,"from heapq import *
from collections import deque
N, K, Q = map(int, input().split())
A = list(map(int, input().split()))
A.append(10**10)
B = sorted(A)
ans = 10**10
for b in B:
    C = []
    D = deque()
    for a in A:
        if a >= b:
            D.append(a)
        else:
            if len(D) >= K:
                E = list(D)
                E.sort()
                for _ in range(len(E)-K+1):
                    C.append(E.pop(0))
            D = deque()
    if len(D) >= K:
        E = list(D)
        E.sort()
        for _ in range(len(E)-K+1):
            C.append(E.pop(0))
    if len(C) >= Q:
        C.sort()
        ans = min(ans, C[Q-1]-b)
print(ans)
","#!usr/bin/env python3
from collections import defaultdict,deque
from heapq import heappush, heappop
import sys
import math
import bisect
import random
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def LS():return [list(x) for x in sys.stdin.readline().split()]
def S():
    res = list(sys.stdin.readline())
    if res[-1] == ""\n"":
        return res[:-1]
    return res
def IR(n):
    return [I() for i in range(n)]
def LIR(n):
    return [LI() for i in range(n)]
def SR(n):
    return [S() for i in range(n)]
def LSR(n):
    return [LS() for i in range(n)]

sys.setrecursionlimit(1000000)
mod = 1000000007

def solve():
    n,k,q = LI()
    a = LI()
    b = [[a[i],i] for i in range(n)]
    b.sort()
    ans = b[q-1][0]-b[0][0]
    l = [-1,n]
    for i in range(1,n):
        l.append(b[i-1][1])
        l.sort()
        if b[i-1][0] == b[i][0]:
            continue
        s = [a[l[i]+1:l[i+1]] for i in range(i+1)]
        c = []
        for si in s:
            si.sort()
            for j in range(len(si)-k+1):
                c.append(si[j])
        if len(c) < q:
            continue
        c.sort()
        m = c[q-1]-c[0]
        if m < ans:
            ans = m
    print(ans)
    return

#Solve
def __starting_point():
    solve()

__starting_point()",text_b
3783,"import sys
input = sys.stdin.readline
mod = 10**9+7
N, K = map(int,input().split())
fact = [1]*(K+1)
inv = [1]*(K+1)
for i in range(1,K+1):
    fact[i] = (fact[i-1]*i)%mod
    inv[i] = pow(fact[i],mod-2,mod)
dp = [0]*(K+1)
dp[0] = pow(2,N,mod)
for i in range(1,K+1):
    dp[i] = (dp[i-1]*2*N)%mod
    for j in range(i):
        dp[i] = (dp[i]-dp[j]*fact[i]*inv[i-j]%mod*inv[j]%mod)%mod
print(dp[K])
","n, k = list(map(int, input().split()))
m = 0x3b9aca07
v = 500000004
r = 0
p = pow(2, n, m)
a = [1] + [0] * k
for i in range(k):
    for j in range(i, -1, -1):
        a[j + 1] += a[j]
        a[j] = a[j] * j % m
for i in range(k + 1):
    r = (r + p * a[i]) % m
    p = p * v * (n - i) % m
print(r)
",text_b
3784,"MOD = 10**9 + 7
N = 55
comb = [[0]*N for _ in range(N)]
dp = [[[0]*N for _ in range(N)] for _ in range(N)]
ways = [[0]*N for _ in range(N)]
dp[2][1][1] = comb[2][2] = ways[2][1] = 1

for i in range(3, N):
    comb[i][0] = comb[i][i] = 1
    for j in range(1, i):
        comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD
    for j in range(1, i):
        ways[i][j] = pow(2, i*(i-1)//2 - j, MOD)
        for k in range(1, j+1):
            dp[i][j][k] = ways[i][j]
            for l in range(2, i):
                for x in range(max(1, j-(i-l)*(i-l-1)//2), min(j, l*(l-1)//2)+1):
                    for y in range(1, min(x, k)+1):
                        dp[i][j][k] = (dp[i][j][k] - comb[i-2][l-2]*comb[i][l]%MOD*dp[l][x][y]%MOD*ways[i-l][j-x]%MOD) % MOD

n, m = map(int, input().split())
print(dp[n+2][n+1][m])
","mod = int(1e9 + 7)
n, m = map(int, input().split())
f = [ [0 for i in range(60)] for j in range(60) ]
g = [ [0 for i in range(60)] for j in range(60) ]
s = [ [0 for i in range(60)] for j in range(60) ]
inv = [ 1 ]
f[0][0] = s[0][0] = 1

def pow(x, exp) :
    res = 1
    for i in range(0, 31) :
        if exp & 1 : res = res * x % mod
        exp >>= 1
        if exp == 0 : break
        x = x * x % mod
    return res

for i in range(1, n + 1) :
    inv.append( pow(i, mod - 2) )

for node in range(1, n + 1) :
    for cut in range(1, n + 1) :
        tmp = 0
        for ln in range(node) :
            for lc in range(cut - 1, n + 1) :
                if f[ln][lc] == 0 : continue
                if lc == cut - 1 :
                    tmp = ( tmp + f[ln][lc] * s[node - ln - 1][cut - 1] ) % mod
                else :
                    tmp = ( tmp + f[ln][lc] * f[node - ln - 1][cut - 1] ) % mod
        cnt = 1
        if tmp != 0 :
            cn, cc = 0, 0
            for i in range(1, n + 1) :
                cn += node
                cc += cut
                cnt = cnt * (tmp + i - 1) % mod * inv[i] % mod
                if cn > n or cc > n : break
                for j in range(n - cn, -1, -1) :
                    for k in range(n - cc, -1, -1) :
                        if f[j][k] == 0 : continue
                        g[j + cn][k + cc] += f[j][k] * cnt
                        g[j + cn][k + cc] %= mod
            for i in range(n + 1) :
                for j in range(n + 1) :
                    f[i][j] = (f[i][j] + g[i][j]) % mod
                    g[i][j] = 0
            
    for cut in range(n, -1, -1) :
        s[node][cut] = ( s[node][cut + 1] + f[node][cut] ) % mod
print(f[n][m - 1])",text_b
3785,"from collections import deque
n, m, k = map(int, input().split())
maze = [list(input()) for _ in range(n)]
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
visited = [[False]*m for _ in range(n)]
queue = deque()
for i in range(n):
    for j in range(m):
        if maze[i][j] == '.':
            queue.append((i, j))
            visited[i][j] = True
            break
    else:
        continue
    break
while queue:
    x, y = queue.popleft()
    for i in range(4):
        nx, ny = x + dx[i], y + dy[i]
        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == '.':
            queue.append((nx, ny))
            visited[nx][ny] = True
while k:
    x, y = queue.pop()
    maze[x][y] = 'X'
    k -= 1
for row in maze:
    print(''.join(row))
","import sys

n, m, k = (int(x) for x in sys.stdin.readline().split(' '))
maze = []
for i in range(n):
    maze.append(list(sys.stdin.readline().strip()))

for y in range(n):
    for x in range(m):
        if maze[y][x] == '.':
            x0, y0 = x, y
            break
    else:
        continue
    break
else:
    print('no spare room')
    return

stack = []
stack.append((x0,y0))
while stack:
    x, y = stack[-1]

    if maze[y][x] == '.':
        maze[y][x] = '0'
        if x > 0 and maze[y][x-1] == '.':
            stack.append((x-1, y))
    elif maze[y][x] == '0':
        maze[y][x] = '1'
        if y < n-1 and maze[y+1][x] == '.':
            stack.append((x, y+1))
    elif maze[y][x] == '1':
        maze[y][x] = '2'
        if x < m-1 and maze[y][x+1] == '.':
            stack.append((x+1, y))
    elif maze[y][x] == '2':
        maze[y][x] = '3'
        if y > 0 and maze[y-1][x] == '.':
            stack.append((x, y-1))
    elif maze[y][x] == '3':
        if k > 0:
            maze[y][x] = 'X'
            k -= 1
        stack.pop()

for y in range(n):
    for x in range(m):
        maze[y][x] = '.' if maze[y][x] == '3' else maze[y][x]

print(""\n"".join(["""".join(s) for s in maze]))
",text_b
3786,"from collections import defaultdict
n = int(input())
p = list(map(int, input().split()))
p = [0] + p
dist = [0]*n
for i in range(2, n+1):
    dist[i-1] = dist[p[i-1]-1] + 1
dist.sort()
cnt = defaultdict(int)
for i in dist:
    cnt[i] += 1
ans = 0
for i in cnt.values():
    ans += i % 2
print(ans)
","n = int(input())
p = [-1, 0] + [int(x) for x in input().split()]
h = [0] * (n+1)
count = [0] * n
count[0] = 1
max_h = 0
for i in range(2, n+1):
    h[i] = h[p[i]]+1
    count[h[i]]+=1
    max_h = max(max_h,h[i])
ans = 0
for i in range(max_h+1):
    ans += count[i]%2
print(ans)",text_b
3787,"N, A, B = map(int, input().split())
if A + B - 1 > N or A * B < N:
    print(-1)
else:
    ans = []
    x = N
    for i in range(A):
        y = max(B - 1, N - x + 1)
        ans += list(range(x - y + 1, x + 1))[::-1]
        x -= y
    print(*ans)
","n,a,b = map(int,input().split())
if a+b>n+1 or a*b<n:
  print(-1)
  return
ans = []
for i in range(1,a+1):
  ans.append(i*b)
if b == 1:
  x = list(range(1,n+1))
  print(*x)
  return
x = (n-a)//(b-1)
y = (n-a)%(b-1)
for i in range(1,b):
  for j in range(1,x+1):
    ans.append(j*b-i)
  if i <= y:
    ans.append((x+1)*b-i)
ans_true = []
for i,x in enumerate(ans):
  ans_true.append((i+1,x))
ans_true.sort(key=lambda x:x[1])
x = list(zip(*ans_true))[0]
print(*x)",text_b
3788,"import sys
from collections import defaultdict
from math import gcd

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()
    dp = [[0]*n for _ in range(n)]
    for i in range(n):
        dp[i][i] = 1
    for l in range(2, n+1):
        for i in range(n-l+1):
            j = i+l-1
            for k in range(i, j):
                if gcd(a[k], a[j]) > 1:
                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])
                if gcd(a[i], a[k+1]) > 1:
                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])
    print(""Yes"" if dp[0][n-1] == n else ""No"")

solve()
","from sys import stdin
from math import gcd
n=int(stdin.readline())
a=[int(x) for x in stdin.readline().split()]
c = []
ld=[]
rd=[]


def check(l, r, e):
    if r == l: return c[l][e] > 0
    if e < l and ld[l][r-l] != 0:
        return ld[l][r-l] == 1
    elif e > r and rd[l][r-l] != 0:
        return rd[l][r-l] == 1
    for i in range(l, r+1):
        if c[i][e]>0:
            if i==l or check(l, i-1, i):
                if i==r or check(i+1, r, i):
                    if e < l:
                        ld[l][r-l] = 1
                    else:
                        rd[l][r-l] = 1
                    return True
    if e < l:
        ld[l][r - l] = -1
    else:
        rd[l][r - l] = -1
    return False


for i in range(n):
    c.append([0]*n)
    ld.append([0]*n)
    rd.append([0] * n)
for i in range(n):
    for j in range(i+1,n):
        if gcd(a[i],a[j]) > 1:
            c[i][j] = c[j][i] = 1
ans=False
for i in range(n):
    if i == 0 or check(0, i - 1, i):
        if i == n-1 or check(i + 1, n-1, i):
            ans = True
            break
if ans:
    print(""Yes"")
else:
    print(""No"")


",text_b
3789,"import heapq

N = int(input())
A = list(map(int, input().split()))
A.sort()
A = [-a for a in A]
heapq.heapify(A)
ans = 0
while A:
    a = -heapq.heappop(A)
    ans += a
    while A and -A[0] < a:
        heapq.heappop(A)
print(ans)
","from collections import deque
 
 
class Dinic:
    def __init__(self, n: int):
        """"""頂点数をnとする""""""
        self.INF = float(""inf"")
        self.n = n
        self.graph = [[] for _ in range(n)]
 
    def add_edge(self, _from: int, to: int, capacity: int):
        """"""残余グラフを構築
        1. _fromからtoへ向かう容量capacityの辺をグラフに追加する
        2. toから_fromへ向かう容量0の辺をグラフに追加する
        """"""
        forward = [to, capacity, None]
        forward[2] = backward = [_from, 0, forward]
        self.graph[_from].append(forward)
        self.graph[to].append(backward)
 
    def bfs(self, s: int, t: int):
        """"""capacityが正の辺のみを通ってsからtに移動可能かどうかBFSで探索
        level: sからの最短路の長さ
        """"""
        self.level = [-1] * self.n
        q = deque([s])
        self.level[s] = 0
        while q:
            _from = q.popleft()
            for to, capacity, _ in self.graph[_from]:
                if capacity > 0 and self.level[to] < 0:
                    self.level[to] = self.level[_from] + 1
                    q.append(to)
 
    def dfs(self, _from: int, t: int, f: int) -> int:
        """"""流量が増加するパスをDFSで探索
        BFSによって作られた最短路に従ってfを更新する
        """"""
        if _from == t:
            return f
        for edge in self.itr[_from]:
            to, capacity, reverse_edge = edge
            if capacity > 0 and self.level[_from] < self.level[to]:
                d = self.dfs(to, t, min(f, capacity))
                if d > 0:
                    edge[1] -= d
                    reverse_edge[1] += d
                    return d
        return 0
 
    def max_flow(self, s: int, t: int):
        """"""s-tパス上の最大流を求める
        計算量: O(|E||V|^2)
        """"""
        flow = 0
        while True:
            self.bfs(s, t)
            if self.level[t] < 0:
                break
            self.itr = list(map(iter, self.graph))
            f = self.dfs(s, t, self.INF)
            while f > 0:
                flow += f
                f = self.dfs(s, t, self.INF)
        return flow

n = int(input())
a = list(map(int, input().split()))

dinic = Dinic(n + 2)
s = 0
t = n + 1
_sum = 0
for i in range(0, n):
    if a[i] > 0:
        dinic.add_edge(s, i+1, 0)
        dinic.add_edge(i+1, t, a[i])
        _sum += a[i]
    elif a[i] < 0:
        dinic.add_edge(s, i+1, -a[i])
        dinic.add_edge(i+1, t, 0)
    else:
        dinic.add_edge(s, i+1, 0)
        dinic.add_edge(i+1, t, 0)

for i in range(n):
    num = i+1
    next_num = 2 * num
    while next_num <= n:
        dinic.add_edge(num, next_num, 10**18)
        next_num += num

print(_sum - dinic.max_flow(s, t))",text_b
3790,"n, T = map(int, input().split())
a = list(map(int, input().split()))
a.sort()
b = [0]*301
c = [0]*301
for i in range(n):
    b[a[i]] += 1
m = max(a)
for i in range(1, m+1):
    c[i] = c[i-1] + b[i]
ans = b[m]*min(T, 300)
T -= min(T, 300)
if T > 0:
    ans += (c[m] - c[m-1] + c[m])*T
print(ans)
","f = lambda: map(int, input().split())
n, m = f()
t = list(f())
d = {i: j for j, i in enumerate(sorted(set(t)))}
t = [d[i] for i in t]
k = len(d)
a = [0] * k
if m < 2 * k:
    for j in t * m:
        a[j] += 1
        q = a[j]
        j += 1
        while j < k and a[j] < q:
            a[j] += 1
            j += 1
    print(a[-1])
    return
a = [0] * k
for j in t * k:
    a[j] += 1
    q = a[j]
    j += 1
    while j < k and a[j] < q:
        a[j] += 1
        j += 1
b = [0] * k
t.reverse()
for j in t * k:
    b[j] += 1
    q = b[j]
    j -= 1
    while j > -1 and b[j] < q:
        b[j] += 1
        j -= 1
print(max(a[j] + (m - 2 * k) * t.count(j) + b[j] for j in range(k)))",text_b
3791,"import sys
from collections import defaultdict

n = int(sys.stdin.readline())
p = list(map(int, sys.stdin.readline().split()))
d = defaultdict(int)
s = [0] * (n + 1)
a = b = 0
for i in range(n):
    p[i] -= 1
    a += abs(p[i] - i)
    if p[i] > i:
        d[p[i] - i] += 1
        s[0] += 1
        s[p[i] - i + 1] -= 1
    else:
        d[0] += 1
        d[n - i + p[i]] -= 1
        s[n - i + p[i]] += 1
for i in range(1, n + 1):
    s[i] += s[i - 1]
m = a
k = 0
for i in range(1, n):
    a += s[i - 1] - d[i] + n - 1
    if a < m:
        m = a
        k = i
print(m, k)
","def main():
    n=int(input())
    A=list(map(int,input().strip().split(' ')))

    def brutal(A):
        n=len(A)
        for i in range(n):
            temp=0
            pos=0
            neg=0
            for j in range(n):
                temp+=abs(A[j]-(j+i)%n)
                if A[j]-(j+i)%n>0:
                    pos+=1
                else:
                    neg+=1

            print(temp,i,pos,neg,'ans,shift,+ve,-ve')    


    for i in range(len(A)):
        A[i]-=1

    ans=0
    pos=0
    neg=0
    change=[0 for i in range(len(A))]

    for i in range(len(A)):
        ans+=abs(A[i]-i)
        if A[i]-i>0:
            pos+=1
        else:
            neg+=1
        if A[i]-i>0:
            change[i]=A[i]-i
        elif A[i]==i:
            change[i]=0
        else:
            if A[i]!=0:
                change[i]=A[i]+n-i
            else:
                change[i]=0
    MIN=ans
    index=0
    #print(ans)
    collect=[[] for i in range(n)]
    for x in range(len(change)):
        collect[change[x]]+=[x]
    #print(collect)

    #print(ans,pos,neg)    
    for s in range(1,n):  
        ans-=abs(A[n-s]-n+1)
        ans+=abs(A[n-s]-0)
        neg-=1

        ans-=pos
        ans+=neg
        if A[n-s]>0:
            pos+=1
        else:
            neg+=1


        pos-=len(collect[s])
        neg+=len(collect[s])
        #print(ans,pos,neg)
        if ans<MIN:
            MIN=ans
            index=s
    print(MIN,index)        
    #brutal(A)        
main() ",text_b
3792,"n, k = map(int, input().split())
s = input()
t = input()
s = list(s)
t = list(t)
s.append('a')
t.append('b')
f = [0]*(n+2)
g = [0]*(n+2)
f[n+1] = 1
g[n+1] = 1
for i in range(n, -1, -1):
    f[i] = min(f[i+1]*2+(s[i] == 'b'), k)
    g[i] = min(g[i+1]*2+(t[i] == 'b'), k)
res = 1
for i in range(1, n+1):
    if s[i] == t[i]:
        if s[i] == 'b':
            res += 1
    else:
        res += min(f[i], g[i])
        break
print(res)
","def ii():
    return int(input())
def mi():
    return list(map(int, input().split()))
def li():
    return list(mi())

# B. The Fair Nut and Strings

n, k = mi()
s = input().strip()
t = input().strip()

ans = 0
jj = 0
for i in range(n):
    if s[i] == t[i]:
        ans += 1
        jj = i + 1
    else:
        break
cur = 2
for j in range(jj, n):
    if s[j] == 'b':
        cur -= 1
    if t[j] == 'a':
        cur -= 1
    if cur >= k:
        ans += k * (n - j)
        break
    ans += cur
    cur *= 2

print(ans)
",text_b
3793,"from itertools import permutations

def dist(p1, p2):
    return sum((a-b)**2 for a, b in zip(p1, p2))

def solve():
    points = [list(map(int, input().split())) for _ in range(8)]
    for perm in permutations(points):
        d = [dist(perm[0], perm[i]) for i in range(1, 8)]
        d.sort()
        if d[0] == d[1] == d[2] == d[3] == d[4] != d[5] == d[6] == d[7]:
            print(""YES"")
            for p in perm:
                print(*p)
            return
    print(""NO"")

solve()
","import itertools
from itertools import permutations as perm

l = [[int(x) for x in input().split()] for i in range(8)]

def dist2(p0,p1):
    return sum([(p0[i]-p1[i])**2 for i in range(3)])

def check(c):
    dists = [[(c[i][0]-c[j][0])**2+(c[i][1]-c[j][1])**2+(c[i][2]-c[j][2])**2 for i in range(8)] for j in range(8)]
    s2 = min([min(l) for l in dists])
    return all([sorted(l) == [0,s2,s2,s2,2*s2,2*s2,2*s2,3*s2] for l in dists])

def sub(p0,p1):
    return [p0[i]-p1[i] for i in range(3)]

def add(p0,p1):
    return [p0[i]+p1[i] for i in range(3)]

def div(p0,x):
    return [p0[i]//x for i in range(3)]

def cross(p0,p1):
    return [p0[(i+1)%3]*p1[(i+2)%3]-p0[(i+2)%3]*p1[(i+1)%3] for i in range(3)]

def match(p0,p1):
    return sorted(p0) == sorted(p1)

def poss(i,prior,s):
    if i == len(l): return check(prior)
    for p in perm(l[i]):
        if i == 1: print(p)
        possible = True
        for p2 in prior:
            if dist2(p,p2) not in [s,2*s,3*s]:
                possible = False
                break
        if possible:
            if poss(i+1,prior+[p]): return True
    return False

solved = False
for l2 in perm(l,3):
    p0 = l2[0]
    for p1 in perm(l2[1]):
        s2 = dist2(p0,p1)
        if s2 == 0: continue
        s = round(s2**.5)
        if s**2 != s2: continue
        for p2 in perm(l2[2]):
            if dist2(p0,p2) != s2 or dist2(p1,p2) != 2*s2: continue
            p3 = sub(add(p1,p2),p0)
            x = div(cross(sub(p1,p0),sub(p2,p0)),s)
            p4,p5,p6,p7 = add(p0,x),add(p1,x),add(p2,x),add(p3,x)
            l3 = [p0,p1,p2,p3,p4,p5,p6,p7]
            if sorted([sorted(p) for p in l]) == sorted([sorted(p) for p in l3]):
                print(""YES"")
                used = [False for i in range(8)]
                for p in l:
                    for i in range(8):
                        if used[i]: continue
                        if match(p,l3[i]):
                            print(l3[i][0],l3[i][1],l3[i][2])
                            used[i] = True
                            break
                solved = True
                break
        if solved: break
    if solved: break

if not solved: print(""NO"")
#if not poss(1,[l[0]]): print(""NO"")
",text_b
3794,"from math import gcd
from sys import stdin, stdout
from collections import deque

def solve():
    n = int(stdin.readline())
    a = list(map(int, stdin.readline().split()))
    a.sort()
    g = [0]*(n+1)
    g[n] = a[n-1]
    for i in range(n-2, -1, -1):
        g[i] = gcd(g[i+1], a[i])
    f = a[0]
    for i in range(1, n):
        f = gcd(f, a[i])
        if gcd(f, g[i+1]) == 1:
            break
    else:
        stdout.write('NO\n')
        return
    stdout.write('YES\n')
    b = [1]*n
    b[i] = 2
    f = a[i]
    q = deque([(i, f, g[i+1])])
    while q:
        i, f, g = q.popleft()
        for j in range(i-1, -1, -1):
            if b[j] == 1 and gcd(f, a[j]) > 1:
                b[j] = 2
                f = gcd(f, a[j])
                q.append((j, f, g))
            elif b[j] == 2 and gcd(g, a[j]) > 1:
                b[j] = 1
                g = gcd(g, a[j])
                q.append((j, f, g))
    stdout.write(' '.join(map(str, b)) + '\n')

solve()
","import sys

def gcd(l):
	if len(l)==0:
		return 0
	if len(l)==1:
		return l[0]
	if len(l)==2:                                   
		if l[1]==0:
			return l[0]  
		return gcd([l[1],l[0]%l[1]])
	return gcd([gcd(l[:-1]),l[-1]])
		
def brute_force(l1,l2,l,sol):                   
	if len(l)==0:
		g1=gcd(l1)
		g2=gcd(l2)
		return g1==1 and g2==1,sol
	
	res,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])
	if res:
		return True,s
	return brute_force(l1,l2+[l[0]],l[1:],sol+[2])

def factor(n):
	res=[]
	i=2
	while i*i<=n:
		if n%i==0:
			res.append(i)
		while n%i==0:
			n=int(n/i)
		i+=1

	if n!=1:
		res.append(n)

	return res

def dumpsol(sol):
	for v in sol:
		print(v,end=' ')

n=int(sys.stdin.readline())
l=sys.stdin.readline().strip().split("" "")[0:n]
l=[int(x) for x in l]
if n<12:
	ret,sol=brute_force([],[],l,[])
	if ret:
		print(""YES"")
		dumpsol(sol)
	else:
		print(""NO"")
	return

factors={}
for i in range(10):
	for key in factor(l[i]):
		factors[key]=0

flists={}
for f in factors:
	flists[f]=[]
	pos=0
	found=False
	for v in l:
		if v%f!=0:
			found=True
			factors[f]+=1
			flists[f].append(pos)
			if (factors[f]>9):
				break
		pos+=1
	if not found:
		print(""NO"")
		return

oftf=[]
isoftf={}
for f in factors:
	if factors[f]==0:
		print(""NO"")
		return

	if factors[f]<10:
		oftf.append(f)
		isoftf[f]=1

#print(oftf)

sol=[1 for i in range(len(l))]
x=l[0]
sol[0]=2
oxf=factor(x)
#print(oxf)
xf=[]
nxf=0
isxoftf={}
for f in oxf:
	if f in isoftf:
		nxf+=1
		isxoftf[f]=1
		xf.append(f)
	else:
		sol[flists[f][0]]=2

nonxf=[]
for f in oftf:
	if not f in isxoftf:
		nonxf.append(f)

masks={}
pos=0

#print(xf)
#print(nonxf)

for f in xf+nonxf:
	for v in flists[f]:
		if not v in masks:	
			masks[v]=0
		masks[v]|=1<<pos
	pos+=1

vals=[{} for i in range(len(masks)+1)]
vals[0][0]=0
pos=0
mlist=[]
for mask in masks:
	mlist.append(mask)
	cmask=masks[mask]
	cmask1=cmask<<10
	#print(vals)
	for v in vals[pos]:
		vals[pos+1][v|cmask]=v
		# first number is always in group2
		if (mask!=0):
			vals[pos+1][v|cmask1]=v
	pos+=1	

#print(vals)
#print(masks)
#print(sol)

test_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)
#print(test_val)
for v in vals[pos]:
	if (v&test_val)==test_val:
		print(""YES"")

		#print(pos)
		while (pos!=0):
			#print(v)
			#print(vals[pos])
			nv=vals[pos][v]
			#print(nv)
			if (nv^v<1024 and nv^v!=0):
				sol[mlist[pos-1]]=2
			v=nv
			pos-=1

		dumpsol(sol)
		return

print(""NO"")

#print(oftf)
#print(masks)

",text_b
3795,"n = int(input())
d = int(input())
e = int(input())
e *= 5
ans = n
for i in range(n // d + 1):
    ans = min(ans, (n - d * i) % e)
print(ans)
","n = int(input())
d = int(input())
e = 5*int(input())

ans = n
d, e = min([d, e]), max([d, e])

for i in range(e):
    if (n-i*d) >= 0:
        ans = min([ans, (n-i*d)%e])
        
print(ans)",text_b
3796,"from collections import Counter
from heapq import *
n = int(input())
a = list(map(int,input().split()))
c = Counter(a)
h = []
for i in c:
    heappush(h, -c[i])
maxi = 0
l = 0
r = 0
for i in range(1, n+1):
    while h and -h[0] < i:
        heappop(h)
    if len(h) >= i:
        if i * min(-h[0], i) > maxi:
            maxi = i * min(-h[0], i)
            l = i
            r = min(-h[0], i)
print(maxi)
print(l, r)
c = Counter(a)
h = []
for i in c:
    heappush(h, (-c[i], i))
mat = [[0]*r for _ in range(l)]
for i in range(r):
    for j in range(l):
        if h[0][0] == -1:
            heappop(h)
        mat[(i+j)%l][i] = h[0][1]
        h[0] = (h[0][0]+1, h[0][1])
for row in mat:
    print(*row)
","
from collections import Counter
from itertools import accumulate
from math import sqrt
from operator import itemgetter
import sys
 
n = int(input())
cnt = Counter(map(int, input().split()))
nums, counts = zip(*sorted(cnt.items(), key=itemgetter(1)))
acc = [0] + list(accumulate(counts))
area = 1
h, w = 1, 1
i = len(counts)
 
for y in range(int(sqrt(n)), 0, -1):
    while i and counts[i-1] > y:
        i -= 1
    total = acc[i] + (len(counts) - i) * y
    x = total // y
    if y <= x and area < x * y:
        h, w, area = y, x, x*y
 
ans = [[0]*w for _ in range(h)]
i = len(counts)-1
num, count = nums[i], min(h, counts[i])
 
for x in range(w):
    for y in range(h):
        ans[y][(x + y) % w] = num
 
        count -= 1
        if count == 0:
            i -= 1
            num, count = nums[i], h if h < counts[i] else counts[i]
 
print(area)
print(h, w)
for y in range(h):
    sys.stdout.write(' '.join(map(str, ans[y])) + '\n')",text_b
3797,"import sys
input = sys.stdin.readline
mod = 10**9+7
N, M = map(int,input().split())
dp = [[[0]*305 for _ in range(305)] for _ in range(305)]
dp[0][0][0] = 1
cond = [[] for _ in range(305)]
for _ in range(M):
    l, r, x = map(int,input().split())
    cond[r-1].append((l-1, x))
for i in range(N):
    for j in range(i+1):
        for k in range(j+1):
            if dp[i][j][k] == 0:
                continue
            dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]) % mod
            dp[i+1][k][i] = (dp[i+1][k][i] + dp[i][j][k]) % mod
            dp[i+1][j][i] = (dp[i+1][j][i] + dp[i][j][k]) % mod
    for l, x in cond[i]:
        for j in range(i+1):
            for k in range(j+1):
                if min(l, j, k) >= l and [j, k, i].count(l) == x:
                    continue
                dp[i][j][k] = 0
print(sum(sum(dp[N-1][j][k] for j in range(N)) for k in range(N)) % mod)
","from collections import defaultdict

MOD = 1000000007
iist = lambda: map(int,input().split())

N,M = iist()
Q = defaultdict(list)
for i in range(M):
  l,r,x = iist()
  Q[r].append((l,x))

if any(x != 1 for l,x in Q[1]):
  print(0)
  return

dp = defaultdict(int)
dp[0,0] = 3

x_sum = [3]
y_sum = [3]
s = 3

for pk in range(1,N):
  k = pk+1

  for i,(a,b) in enumerate(zip(x_sum,y_sum)):
    c = (a+b)%MOD
    dp[i,pk] = c
    x_sum[i] += c

  x_sum.append(0)
  y_sum.append((2*s)%MOD)
  s *= 3
  subQ = Q[k]

  for i,j in list(dp.keys()):
    for l,x in subQ:
      if x != (l<=i)+(l<=j)+1:
        c = dp[i,j]
        x_sum[i] -= c
        y_sum[j] -= c
        s -= c
        del dp[i,j]
        break

  for i in range(pk):
    x_sum[i] %= MOD
    y_sum[i] %= MOD
  s %= MOD

print(s)",text_b
3798,"import math

def f(b, n):
    if n < b:
        return n
    else:
        return f(b, n // b) + n % b

n = int(input().strip())
s = int(input().strip())

if n == s:
    print(n + 1)
elif n < s:
    print(-1)
else:
    for b in range(2, int(math.sqrt(n)) + 1):
        if f(b, n) == s:
            print(b)
            break
    else:
        for p in range(int(math.sqrt(n)), 0, -1):
            b = (n - s) // p + 1
            if b >= 2 and f(b, n) == s:
                print(b)
                break
        else:
            print(-1)
","import numpy as np
def f(b, n):
    s = 0
    while n > 0:
        s += n % b
        n //= b
    return s

INF = 10**15
def solve(n, s):
    if n == s:
        return n+1
    m = int(np.sqrt(n)) + 1
    for b in range(2, m+1):
        if f(b, n) == s:
            return b
    best = INF
    for p in range(1, m+10):
        q = s - p
        b = (n - q) // p
        if (b > p) and (b > q) and (f(b, n) == s):
            best = min(best, b)
    return -1 if (best == INF) else best

n = int(input())
s = int(input())
print(solve(n, s))",text_b
3799,"s = input().strip()
n = len(s)
if s[0] == s[-1]:
    if n % 2 == 0:
        print(""First"")
    else:
        print(""Second"")
else:
    if n % 2 == 0:
        print(""Second"")
    else:
        print(""First"")
","s=input();print(['Second','First'][len(s.rstrip(s[0]))%2])",text_b
3800,"a = int(input().strip())
s = list(map(int, list(input().strip())))
n = len(s)
prefix = [0]*(n+1)
for i in range(n):
    prefix[i+1] = prefix[i] + s[i]
count = [0]*(n*n+1)
for i in range(n):
    for j in range(i+1, n+1):
        count[prefix[j] - prefix[i]] += 1
answer = 0
if a == 0:
    for i in range(1, n*n+1):
        answer += count[i] * count[0]
    answer += count[0] * (count[0] - 1) // 2
else:
    for i in range(1, (n*n+1)//2+1):
        if a % i == 0 and a // i <= n*n:
            answer += count[i] * count[a // i]
print(answer)
","def f(t, k):
    i, j = 0, 1
    s, d = 0, t[0]
    n = len(t)
    while j <= n:
        if d > k:
            d -= t[i]
            i += 1
        elif d == k:
            if t[i] and (j == n or t[j]): s += 1
            else:
                a, b = i - 1, j - 1
                while j < n and t[j] == 0: j += 1
                while t[i] == 0: i += 1
                s += (i - a) * (j - b)
            if j < n: d += t[j]
            d -= t[i]
            i += 1
            j += 1                
        else:
            if j < n: d += t[j]
            j += 1
    return s

s, n = 0, int(input())
t = list(map(int, input()))
if n:
    k = sum(t)
    if k == 0: print(0)
    else:
        p = [(i, n // i) for i in range(max(1, n // k), int(n ** 0.5) + 1) if n % i == 0]
        for a, b in p:
            if a != b: s += 2 * f(t, a) * f(t, b)
            else:
                k = f(t, a)
                s += k * k
        print(s)
else:
    n = len(t)
    m = n * (n + 1)
    s = j = 0
    while j < n:
        if t[j] == 0:
            i = j
            j += 1
            while j < n and t[j] == 0: j += 1
            k = ((j - i) * (j - i + 1)) // 2
            s += k
        j += 1
    print((m - s) * s)",text_b
3801,"MOD = 998244353
n, m = map(int, input().split())
a = list(map(int, input().split()))
w = list(map(int, input().split()))
s1 = sum(w[i] for i in range(n) if a[i])
s2 = sum(w[i] for i in range(n) if not a[i])
dp = [[[0]*(m+1) for _ in range(m+1)] for _ in range(m+1)]
dp[0][0][0] = 1
for i in range(m):
    for j in range(i+1):
        for k in range(i-j+1):
            if s1+j > 0:
                dp[i+1][j+1][k] = (dp[i+1][j+1][k] + dp[i][j][k]*((s1+j)*pow(s1+s2-j+k, MOD-2, MOD))%MOD)%MOD
            if s2+k > 0:
                dp[i+1][j][k+1] = (dp[i+1][j][k+1] + dp[i][j][k]*((s2+k)*pow(s1+s2-j+k, MOD-2, MOD))%MOD)%MOD
            dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]*((s1+s2-j+k)*pow(s1+s2-j+k, MOD-2, MOD))%MOD)%MOD
for i in range(n):
    ans = 0
    for j in range(m+1):
        for k in range(m-j+1):
            if a[i]:
                ans = (ans + dp[m][j][k]*(w[i]+j))%MOD
            else:
                ans = (ans + dp[m][j][k]*max(0, w[i]-k))%MOD
    print(ans)
","P = 998244353
N, M = list(map(int, input().split()))
A = [int(a) for a in input().split()]
B = [int(a) for a in input().split()]
li = sum([A[i]*B[i] for i in range(N)])
di = sum([(A[i]^1)*B[i] for i in range(N)])
X = [[] for _ in range(M+1)]

X[0] = [1]
def calc(L):
    su = sum(L)
    pl = 0
    pd = 0
    RE = []
    for i in range(len(L)):
        a = li + i
        b = di - (len(L) - 1 - i)
        pd = b * L[i] * pow(su*(a+b), P-2, P)
        RE.append((pl+pd)%P)
        pl = a * L[i] * pow(su*(a+b), P-2, P)
    RE.append(pl%P)
    return RE

for i in range(M):
    X[i+1] = calc(X[i])
ne = 0
po = 0
for i in range(M+1):
    po = (po + X[M][i] * (li + i)) % P
    ne = (ne + X[M][i] * (di - M + i)) % P
for i in range(N):
    print(po * B[i] * pow(li, P-2, P) % P if A[i] else ne * B[i] * pow(di, P-2, P) % P)
",text_b
3802,"def longest_common_subsequence(s1, s2, virus):
    n, m, v = len(s1), len(s2), len(virus)
    dp = [[["""", 0] for _ in range(m+1)] for _ in range(n+1)]
    fail = [0]*v
    for i in range(1, v):
        j = fail[i-1]
        while j and virus[i] != virus[j]:
            j = fail[j-1]
        fail[i] = j + (virus[i] == virus[j])
    for i in range(1, n+1):
        for j in range(1, m+1):
            if s1[i-1] == s2[j-1]:
                k = dp[i-1][j-1][1]
                while k and (k == v or virus[k] != s1[i-1]):
                    k = fail[k-1]
                dp[i][j] = max([dp[i][j], [dp[i-1][j-1][0] + s1[i-1], k + 1]], key=lambda x: (len(x[0]), -x[1]))
            else:
                dp[i][j] = max([dp[i][j], dp[i-1][j], dp[i][j-1]], key=lambda x: (len(x[0]), -x[1]))
    return dp[n][m][0] if dp[n][m][0] and dp[n][m][1] != v else ""0""

print(longest_common_subsequence(""AJKEQSLOBSROFGZ"", ""OVGURWZLWVLUXTH"", ""OZ""))  # Output: ""ORZ""
print(longest_common_subsequence(""AA"", ""A"", ""A""))  # Output: ""0""
","# coding=utf-8
from functools import reduce

a = input()
b = input()
c = input()

alen = len(a)
blen = len(b)
clen = len(c)

kmpnext = [0]*(clen+1)
i = 1
j = 0
while i < clen:
	while j > 0 and c[i]!=c[j]:
		j = kmpnext[j]
	if c[i] == c[j]:
		j+=1
	kmpnext[i+1] = j
	i+=1
#print(kmpnext)

f = [[[0 for i in range(clen+2)] for i in range(blen+2)] for i in range(alen+2)]
g = [[[0 for i in range(clen+2)] for i in range(blen+2)] for i in range(alen+2)]
h = [[[0 for i in range(clen+2)] for i in range(blen+2)] for i in range(alen+2)]

f[0][0][0] = 0
g[0][0][0] = (-1,-1,-1)
h[0][0][0] = 1
m = (0,0,0)

for i in range(alen):
	for j in range(blen):
		for k in range(clen):
			if h[i][j][k] == 0:
				#print(i,j,k)
				continue
			if f[i+1][j][k] < f[i][j][k] or h[i+1][j][0] == 0:
				f[i+1][j][k] = f[i][j][k]
				g[i+1][j][k] = g[i][j][k]
				h[i+1][j][k] = 1
			if f[i][j+1][k] < f[i][j][k] or h[i][j+1][0] == 0:
				f[i][j+1][k] = f[i][j][k]
				g[i][j+1][k] = g[i][j][k]
				h[i][j+1][k] = 1

			if a[i] == b[j]:
				#print(i,j,a[i],b[j])
				kt = k
				while kt != 0 and a[i] != c[kt]:
					kt = kmpnext[kt]
				if a[i] == c[kt]:
					if f[i+1][j+1][kt+1] < f[i][j][k] + 1:
						f[i+1][j+1][kt+1] = f[i][j][k] + 1
						g[i+1][j+1][kt+1] = (i,j,k)
						h[i+1][j+1][kt+1] = 1
				else:
					if f[i+1][j+1][0] < f[i][j][k] + 1:
						f[i+1][j+1][0] = f[i][j][k] + 1
						g[i+1][j+1][0] = (i,j,k)
						h[i+1][j+1][0] = 1

			#print(i,j,k,f[i][j][k],g[i][j][k])

for i in range(alen+1):
	for j in range(blen+1):
		for k in range(clen):
			if f[i][j][k] > f[m[0]][m[1]][m[2]]:
				m = (i,j,k)
if f[m[0]][m[1]][m[2]] == 0:
	print(0)
else:
	ans = """"
	t = m
	t = g[t[0]][t[1]][t[2]]
	while t != (-1,-1,-1):
		ans = a[t[0]] + ans
		t = g[t[0]][t[1]][t[2]]
	print(ans)
",text_b
3803,"def min_bitcoins():
    HP_Y, ATK_Y, DEF_Y = map(int, input().split())
    HP_M, ATK_M, DEF_M = map(int, input().split())
    h, a, d = map(int, input().split())
    min_bitcoins = float('inf')
    for ATK_Y in range(ATK_Y, 101):
        for DEF_Y in range(DEF_Y, 101):
            HP_Y_needed = max(0, ((HP_M + max(0, ATK_Y - DEF_M) - 1) // max(0, ATK_Y - DEF_M)) * max(0, ATK_M - DEF_Y) + 1)
            cost = max(0, HP_Y_needed - HP_Y) * h + (ATK_Y - ATK_Y) * a + (DEF_Y - DEF_Y) * d
            min_bitcoins = min(min_bitcoins, cost)
    return min_bitcoins

print(min_bitcoins())
","H_y,A_y,D_y = list(map(int,input().split()))
H_m,A_m,D_m = list(map(int,input().split()))
h,a,d = list(map(int,input().split()))
ans = 10**20
for A_buy in range(max(0,H_m+D_m-A_y)+1):
  for D_buy in range(max(0,A_m-D_y)+1):
    damage = A_y + A_buy - D_m
    cost = A_buy * a + D_buy * d
    if damage > 0 and cost < ans:
      time = (H_m+damage-1)//damage
      H_left = H_y - time * max(0, A_m - D_y - D_buy)
      if H_left <= 0: cost += h * (1-H_left)
      if cost < ans: 
        ans = cost
print(ans)
",text_b
3804,"def solve(n, t):
    if t == 1:
        return n
    t -= 1
    n -= 1
    ans = 0
    for i in range(60):
        if (t >> i) & 1:
            if i > n:
                break
            ans += C[n][i]
    return ans

C = [[0 for _ in range(61)] for _ in range(61)]
C[0][0] = 1
for i in range(1, 61):
    C[i][0] = 1
    for j in range(1, i + 1):
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]

n, t = map(int, input().split())
print(solve(n, t))
","n, t = map(int, input().split())
s = bin(n + 2)[2:]
l = len(s)

if t & (t - 1):
    ans = 0
else:
    t = t.bit_length()
    f = [[0] * (l + 1) for i in range(l + 1)]
    for i in range(l + 1):
        f[i][0] = f[i][i] = 1
        for j in range(1, i):
            f[i][j] = f[i - 1][j - 1] + f[i - 1][j]

    ans = c = 0
    for i in range(l):
        if s[i] == '1':
            if t - c <= l - i - 1:
                ans += f[l - i - 1][t - c]
            c += 1
    if t == 1: ans -= 1
print(ans)",text_b
3805,"def can_be_untangled(s):
    stack = []
    for c in s:
        if stack and stack[-1] == c:
            stack.pop()
        else:
            stack.append(c)
    return ""Yes"" if not stack else ""No""

s = input().strip()
print(can_be_untangled(s))
","l = []

for c in input():
    if len(l) > 0 and l[-1] == c:
        l.pop()
    else:
        l.append(c)

print('Yes' if len(l) == 0 else 'No')
",text_b
3806,"import math
from sys import stdin

def dist(x1, y1, x2, y2):
    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

def dot(x1, y1, x2, y2):
    return x1 * x2 + y1 * y2

def cross(x1, y1, x2, y2):
    return x1 * y2 - x2 * y1

def lineDist(x1, y1, x2, y2, x3, y3):
    return abs(cross(x2 - x1, y2 - y1, x1 - x3, y1 - y3)) / dist(x1, y1, x2, y2)

n, px, py = map(int, stdin.readline().split())
x = [0] * n
y = [0] * n
for i in range(n):
    x[i], y[i] = map(int, stdin.readline().split())
    x[i] -= px
    y[i] -= py
x.append(x[0])
y.append(y[0])
minR = 1e100
maxR = max(dist(x[i], y[i], 0, 0) for i in range(n))
for i in range(n):
    if dot(x[i], y[i], x[i + 1], y[i + 1]) > 0 and dot(x[i + 1], y[i + 1], x[i], y[i]) > 0:
        minR = min(minR, lineDist(x[i], y[i], x[i + 1], y[i + 1], 0, 0))
    else:
        minR = min(minR, dist(x[i], y[i], 0, 0), dist(x[i + 1], y[i + 1], 0, 0))
print(""%.15f"" % (math.pi * (maxR ** 2 - minR ** 2)))
","import math
def dist(x, y, x1, y1, x2, y2):
    a = x-x1
    b = y-y1
    c = x2-x1
    d = y2-y1
    dot = a*c+b*d
    lensq = c*c+d*d
    param=-1
    if lensq != 0:
        param = dot / lensq
    if param < 0:
        xx = x1
        yy = y1
    elif param > 1:
        xx = x2
        yy = y2
    else:
        xx = x1 + param * c
        yy = y1 + param * d

    dx = x - xx
    dy = y - yy
    return (dx*dx+dy*dy)**0.5
def dist2(x, y):
    return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5
import math
maxx = -1
minn = 100000000000000000
pts = []
a, b, c = list(map(int, input().split(' ')))
for i in range(a):
    x, y = list(map(int, input().split(' ')))
    pts.append([x, y])

k = []
for i in pts:
    k.append(dist2(i, [b, c]))
pts.append(pts[0])
for i in range(a):
    k.append(dist(b, c, pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1]))

print((max(k)**2-min(k)**2)*math.pi)
",text_b
3807,"def solve(m):
    if m < 8:
        return m, m
    q, r = divmod(m, 8)
    if r == 0:
        return 3*q, m
    if r == 7:
        return 3*q+3, m
    if r == 1:
        return 3*q+1, m
    return max((3*q+1, m-1), solve(8*q+r-1))

m = int(input().strip())
print(*solve(m))
","im = int(input())

best_steps = 0
best_length = 0

def rec(m, steps, substracted):
    nonlocal best_steps, best_length 
    if m == 0:
        if steps > best_steps:
            best_steps = steps
            best_length = substracted
        elif steps == best_steps:
            best_length = max(best_length, substracted)
        return

    a = 1
    while (a + 1)**3 <= m:
        a += 1

    rec(m - a**3, steps + 1, substracted + a**3)

    if a - 1 != 0:
        rec(a**3-1-(a-1)**3, steps + 1, substracted + (a-1)**3)

rec(im, 0, 0)
print(best_steps, best_length)",text_b
3808,"n = int(input())
s = input()
if n % 2 != 0 or s.count('(') != s.count(')'):
    print('No')
else:
    cnt = 0
    for i in s:
        if i == '(':
            cnt += 1
        else:
            cnt -= 1
        if cnt < -1:
            print('No')
            break
    else:
        print('Yes')
","n=int(input())
s=input()
stack=[]
for i in s:
	if i==""("":
		stack.append(i)
	elif i=="")"":
		if len(stack)>0:
			if (stack[-1]==""(""):
				stack.pop()
			else:
				stack.append("")"")
		else:
			stack.append("")"")
if len(stack)==0:
	print (""Yes"")
	return
if len(stack)==2:
	if stack[0]=="")"" and stack[1]==""("":
		print (""Yes"")
		return
	else:
		print (""No"")
		return
else:
	print (""No"")",text_b
3809,"import sys
from collections import defaultdict

MOD = 10**9 + 7
n, k = map(int, input().split())
a = list(map(int, input().split()))
a = [x//50 for x in a]
k //= 50
dp = [[[[0]*101 for _ in range(51)] for _ in range(51)] for _ in range(2)]
dp[0][n][a.count(2)][a.count(1)] = 1
ans = [float('inf'), 0]
for t in range(2*n):
    i = t%2
    for x in range(n+1):
        for y in range(min(x, k)+1):
            for z in range(min(n-x, k-y*2)+1):
                if dp[i][x][y][z] == 0: continue
                if x == 0: ans = [t, dp[i][x][y][z]]
                j = 1-i
                dp[j][x][y][z] = 0
                for p in range(y+1):
                    for q in range(min(z, k-p*2)+1):
                        if p*2+q > k: break
                        dp[j][x-p-q][y-p][z-q] += dp[i][x][y][z]
                        dp[j][x-p-q][y-p][z-q] %= MOD
if ans[0] == float('inf'): print(-1, 0)
else: print(ans[0], ans[1])
","from collections import deque

n, k = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
c50 = sum([1 for i in a if i == 50])
c100 = sum([1 for i in a if i == 100])
c = [[0] * 51 for i in range(51)]
c[0][0] = 1
c[1][0] = 1
c[1][1] = 1
for x in range(2, 51):
    for y in range(x + 1):
        c[x][y] = c[x - 1][y - 1] + c[x - 1][y]
d = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]
# d[i][j][c] ответ, когда мы переправили i по 50 кг и j по 100 кг и лодка на берегу c
d[0][0][0][0] = 1
d[0][0][0][1] = 0
q = deque()
q.append([0, 0, 0])
while len(q) > 0:
    i, j, shore = q.popleft()
    for fifty in range(c50 - i + 1 if shore == 0 else i + 1):
        for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):
            if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:
                continue
            i1 = i + fifty if shore == 0 else i - fifty
            j1 = j + hundreds if shore == 0 else j - hundreds
            if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:
                d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1
                d[i1][j1][1 ^ shore][0] = 0
                q.append((i1, j1, 1 ^ shore))
            if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:
                continue
            koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (
                c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])
            d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff
            d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7
if d[c50][c100][1][1] == float('inf'):
    print(-1)
    print(0)
else:
    print(d[c50][c100][1][1])
    print(d[c50][c100][1][0])

",text_b
3810,"from collections import defaultdict
from itertools import combinations
from operator import mul
from functools import reduce
from math import gcd

MOD = 10 ** 9 + 7
MAX = 61
nCr = [[0] * MAX for _ in range(MAX)]
for i in range(MAX):
    nCr[i][0] = nCr[i][i] = 1
    for j in range(1, i):
        nCr[i][j] = (nCr[i - 1][j - 1] + nCr[i - 1][j]) % MOD

n = int(input())
a = list(map(int, input().split()))
a.sort()
g = [0] * MAX
for x in a:
    g[x] = reduce(gcd, (g[y] for y in range(1, x + 1) if x % y == 0))
cnt = defaultdict(int)
for x in a:
    cnt[g[x]] += 1
dp = [1] + [0] * n
for x in sorted(cnt.keys(), reverse=True):
    ndp = dp[:]
    for i in range(cnt[x]):
        for j in range(n, i, -1):
            ndp[j] = (ndp[j] + dp[j - i - 1] * nCr[cnt[x]][i + 1]) % MOD
    dp = ndp
print(dp[cnt[1]])
","MOD = 1000000007


def isSubset(a, b):
	return (a & b) == a


def isIntersect(a, b):
	return (a & b) != 0


# Solve for each weakly connected component (WCC)
def cntOrder(s, t):
	p = len(s)
	m = len(t)

	inMask = [0 for i in range(m)]

	for x in range(p):
		for i in range(m):
			if t[i] % s[x] == 0:
				inMask[i] |= 1 << x

	cnt = [0 for mask in range(1<<p)]
	for mask in range(1<<p):
		for i in range(m):
			if isSubset(inMask[i], mask):
				cnt[mask] += 1

	dp = [[0 for mask in range(1<<p)] for k in range(m+1)]
	for i in range(m):
		dp[1][inMask[i]] += 1
	for k in range(m):
		for mask in range(1<<p):
			for i in range(m):
				if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):
					dp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD
			dp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD

	return dp[m][(1<<p)-1]


def dfs(u):
	nonlocal a, graph, degIn, visited, s, t

	visited[u] = True
	if degIn[u] == 0:
		s.append(a[u])
	else:
		t.append(a[u])

	for v in graph[u]:
		if not visited[v]:
			dfs(v)


def main():
	nonlocal a, graph, degIn, visited, s, t

	# Reading input
	n = int(input())
	a = list(map(int, input().split()))

	# Pre-calculate C(n, k)
	c = [[0 for j in range(n)] for i in range(n)]
	for i in range(n):
		c[i][0] = 1
		for j in range(1, i+1):
			c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD	

	# Building divisibility graph
	degIn = [0 for u in range(n)]
	graph = [[] for u in range(n)]
	for u in range(n):
		for v in range(n):
			if u != v and a[v] % a[u] == 0:
				graph[u].append(v)
				graph[v].append(u)
				degIn[v] += 1

	# Solve for each WCC of divisibility graph and combine result
	ans = 1
	curLen = 0
	visited = [False for u in range(n)]
	for u in range(n):
		if not visited[u]:
			s = []
			t = []
			dfs(u)

			if len(t) > 0:
				sz = len(t) - 1
				cnt = cntOrder(s, t)

				# Number of orders for current WCC
				ans = (ans * cnt) % MOD
				# Number of ways to insert <sz> number to array of <curLen> elements
				ans = (ans * c[curLen + sz][sz]) % MOD
				curLen += sz		

	print(ans)

def __starting_point():
	main()
__starting_point()",text_b
3811,"import math
n = int(input())
pairs = [list(map(int, input().split())) for _ in range(n)]
factors = set()
for i in range(2, int(math.sqrt(pairs[0][0]))+1):
    if pairs[0][0] % i == 0:
        factors.add(i)
        while pairs[0][0] % i == 0:
            pairs[0][0] //= i
if pairs[0][0] > 1:
    factors.add(pairs[0][0])
for i in range(2, int(math.sqrt(pairs[0][1]))+1):
    if pairs[0][1] % i == 0:
        factors.add(i)
        while pairs[0][1] % i == 0:
            pairs[0][1] //= i
if pairs[0][1] > 1:
    factors.add(pairs[0][1])
for i in range(1, n):
    new_factors = set()
    for f in factors:
        if pairs[i][0] % f == 0 or pairs[i][1] % f == 0:
            new_factors.add(f)
    factors = new_factors
if len(factors) == 0:
    print(-1)
else:
    print(max(factors))
","from math import sqrt
def primset(n):
    a = set()
    
    while n % 2 == 0:
        a.add(2)
        n = n//2
         
    for i in range(3,int(sqrt(n))+1,2):
        while n % i== 0:
            a.add(i)
            n = n//i
            
    if n > 2:
        a.add(n)
    return a

n = int(input())
a, b = map(int, input().split())

primes = primset(a)
primes.update(primset(b))

for i in range(1, n):
    a, b = map(int, input().split())
    r = set()
    for p in primes:
        if a%p != 0 and b%p != 0:
            r.add(p)
    for rem in r:
        primes.remove(rem)
    if len(primes) < 1:
        print(-1)
        return
print(primes.pop())",text_b
3812,"s = input().strip()
t = input().strip()
n = len(s)
m = len(t)
s += 'b' * (m - n)
t += 'a' * (n - m)
n = len(s)
m = len(t)
s = list(s)
t = list(t)
s1 = [0] * (n + 1)
t1 = [0] * (m + 1)
for i in range(n - 1, -1, -1):
    s1[i] = s1[i + 1] + (s[i] == 'a')
for i in range(m - 1, -1, -1):
    t1[i] = t1[i + 1] + (t[i] == 'a')
s1 = s1[:-1]
t1 = t1[:-1]
s = s[:-1]
t = t[:-1]
n = len(s)
m = len(t)
if (s1[0] + t1[0]) % 2 == 1:
    print(-1)
else:
    ans = []
    i = 0
    j = 0
    while i < n or j < m:
        if s[i] == t[j]:
            while i < n and j < m and s[i] == t[j]:
                i += 1
                j += 1
            ans.append((i, j))
        else:
            while i < n and j < m and s[i] == s[i - 1]:
                i += 1
            while j < m and i < n and t[j] == t[j - 1]:
                j += 1
            ans.append((i, j))
    print(len(ans))
    for i in ans:
        print(i[0], i[1])
","
def blokovi(x):
    ret = [0]
    for i in range(len(x) - 1):
        if x[i] != x[i + 1]:
            ret.append(i + 1)
    return ret + [len(x)]

s = input()
t = input()

ss = blokovi(s)
tt = blokovi(t)

if s[-1] == 'a':
    s += 'b'
else:
    s += 'a'

if t[-1] == 'a':
    t += 'b'
else:
    t += 'a'

def greedy(x, y, rev=False):
    i, j = len(x) - 1, len(y) - 1
    swaps = []
    while True:
        while i >= 0 and x[i] == 'a':
            i -= 1
        while j >= 0 and y[j] == 'b':
            j -= 1
        if i < 0 and j < 0:
            break
        x, y = y, x
        if rev:
            swaps.append((j + 1, i + 1))
        else:
            swaps.append((i + 1, j + 1))
        i, j = j, i
    return swaps

def solve(x, y):
    p = greedy(x, y)
    q = greedy(y, x, True)
    if len(p) < len(q):
        return p
    return q

probao = set()

total = len(ss) + len(tt)
sol = solve(s[:-1], t[:-1])
for b, i in enumerate(ss):
    for c in range((2 * b + len(tt) - len(ss)) // 2 - 2, (2 * b + len(tt) - len(ss) + 1) // 2 + 3):
        if 0 <= c < len(tt):
            j = tt[c]
            bs = b + len(tt) - c - 1
            bt = c + len(ss) - b - 1
            if abs(bs - bt) > 2:
                continue
            proba = (bs, bt, s[i], t[j])
            if proba in probao:
                continue
            probao.add(proba)
            s2 = t[:j] + s[i:-1]
            t2 = s[:i] + t[j:-1]
            if i + j > 0: 
                if i + j == len(s) + len(t) - 2:
                    cand = solve(t2, s2)
                else:
                    cand = [(i, j)] + solve(s2, t2)
            else:
                cand = solve(s2, t2)
            if len(cand) < len(sol):
                sol = cand

print(len(sol))
for i, j in sol:
    print(i, j)
",text_b
3813,"import sys
from collections import defaultdict
from heapq import heapify,heappop,heappush
input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N = int(input())
P = [0] + list(map(int,input().split()))
X = [0] + list(map(int,input().split()))
G = defaultdict(list)
for i in range(2,N+1):
    G[P[i]].append(i)
dp = [0]*(N+1)
dp2 = [0]*(N+1)
dp3 = [0]*(N+1)
def dfs(v):
    if len(G[v]) == 0:
        dp[v] = X[v]
        dp2[v] = 0
        dp3[v] = X[v]
        return
    dp[v] = X[v]
    dp2[v] = 0
    dp3[v] = 0
    H = []
    for u in G[v]:
        dfs(u)
        dp[v] -= dp[u]
        dp2[v] += dp2[u]
        dp3[v] += dp3[u]
        heappush(H,dp2[u]-dp3[u])
    if dp[v] < 0:
        print(""IMPOSSIBLE"")
        exit()
    while dp[v] < dp2[v]:
        dp2[v] -= heappop(H)
    if dp[v] < dp2[v] or dp[v] > dp3[v]:
        print(""IMPOSSIBLE"")
        exit()
    return
dfs(1)
print(""POSSIBLE"")
","N=int(input())
P=[-1]+[int(i)-1 for i in input().split()]
X=[int(i) for i in input().split()]
Q=[[] for i in range(N)]
for i in range(1,N):
    Q[P[i]].append(i)
dp=[0 for i in range(N)]
INF=10**9+7
def solve(i):
    cur=[INF for j in range(X[i]+1)]
    cur[0]=0
    for j in Q[i]:
        solve(j)
        prv=[k for k in cur]
        cur=[INF for k in range(X[i]+1)]
        for acc in range(len(prv)):
            if prv[acc]<INF:
                if acc+X[j]<=X[i]:
                    cur[acc+X[j]]=min(cur[acc+X[j]],prv[acc]+dp[j])
                if acc+dp[j]<=X[i]:
                    cur[acc+dp[j]]=min(cur[acc+dp[j]],prv[acc]+X[j])
    dp[i]=min(cur)
solve(0)
if dp[0]<INF:
    print(""POSSIBLE"")
else:
    print(""IMPOSSIBLE"")
",text_b
3814,"import sys
input = sys.stdin.readline

N, M = map(int, input().split())
fac = [1]
for i in range(1, N+2):
    fac.append(fac[-1]*i%M)
inv = [pow(fac[-1], M-2, M)]
for i in range(N+1, 0, -1):
    inv.append(inv[-1]*i%M)
inv.reverse()
pw = [1]
for _ in range(N+1):
    pw.append(pw[-1]*2%M)
dp = [[0]*(N+2) for _ in range(N+2)]
dp[0][0] = 1
for i in range(1, N+2):
    dp[i][0] = 1
    for j in range(1, i+1):
        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]*(j+1)) % M
ans = 0
for i in range(N+1):
    cur = 0
    for j in range(i+1):
        cur = (cur + dp[i+1][j]*pw[N-i]*(pw[j]-1)) % M
    cur = cur * fac[N] % M * inv[i] % M * inv[N-i] % M
    if i % 2 == 0:
        ans = (ans + cur) % M
    else:
        ans = (ans - cur) % M
print(ans)
","import numpy as np


def solve(n, m):
    def prepare(n, m):
        f = 1
        for i in range(1, n + 1):
            f = f * i % m
        fn = f
        inv = [1] * (n + 1)
        f = pow(f, m - 2, m)
        inv[n] = f
        for i in range(n, 0, -1):
            f = f * i % m
            inv[i - 1] = f
        return fn, inv

    def a_x(a, x, m):
        ret = 1
        yield ret
        for _ in range(x):
            ret = ret * a % m
            yield ret

    fn, inv = prepare(n, m)

    stir2 = np.zeros(n + 2, dtype=np.int64)
    stir2[0] = 1
    upd = np.arange(2, n + 3, dtype=np.int64)

    ex2 = [2]
    for i in range(n):
        ex2.append(ex2[-1] ** 2 % m)

    ans = 0
    si = 1

    for i in range(n+1):
        nCi = fn * inv[i] * inv[n-i] % m
        i_with = np.fromiter(a_x(pow(2, n-i, m), i, m), dtype=np.int64) 
        i_on = (stir2[ :i+1] * i_with % m).sum() % m
        ans = (ans + nCi * i_on % m * ex2[n-i] % m * si) % m
        stir2[1 : i+2] = (stir2[1 : i+2] * upd[ :i+1] + stir2[ :i+1]) % m
        si *= -1

    return ans


N, M = list(map(int, input().split()))
print((solve(N, M)))
",text_b
3815,"MOD = 10**9 + 9

def power(x, y):
    if y == 0:
        return 1
    elif y % 2 == 0:
        return power(x, y // 2)**2 % MOD
    else:
        return x * power(x, y // 2)**2 % MOD

def inverse(x):
    return power(x, MOD - 2)

n, a, b, k = map(int, input().split())
s = input().strip()

a = power(a, n)
b = power(b, 1)
inv_a = inverse(a)
inv_b = inverse(b)

sum_period = 0
for i in range(k):
    if s[i] == '+':
        sum_period = (sum_period + a * b) % MOD
    else:
        sum_period = (sum_period - a * b) % MOD
    a = a * inv_a % MOD
    b = b * inv_b % MOD

num_periods = (n + 1) // k
sum_total = 0
if num_periods > 1:
    q = power(b, k)
    inv_q = inverse(q)
    sum_total = sum_period * (power(q, num_periods) - 1) * inv_q % MOD
else:
    sum_total = sum_period

print(sum_total)
","def __starting_point():
	a=[int(x) for x in input().split()]
	N=a[0]
	A=a[1]
	B=a[2]
	K=a[3]
	s=input()
	mod = 1000000009
	Q = pow(B*pow(A,mod-2,mod)%mod,K,mod)
	if Q!=1:
		D = (pow(Q,(N+1)//K,mod)-1)*pow(Q-1,mod-2,mod)%mod
	else:
		D = (N+1)//K
	ans=0
	C = pow(A,N,mod)
	A=pow(A,mod-2,mod)
	for i in range(K):
		if s[i]=='+':
			ans=(ans+C*D)%mod
		else:
			ans=(ans-C*D)%mod
		C=C*B*A%mod
	print((ans%mod+mod)%mod)
__starting_point()",text_b
3816,"def solve():
    a, b, c, l = map(int, input().split())
    ans = 0
    for i in range(l + 1):
        ans += (i + 1) * (i + 2) // 2
    for i in range(l + 1):
        if a - b - c + i < 0:
            continue
        x = min(l - i, a - b - c + i)
        ans -= (x + 1) * (x + 2) // 2
    for i in range(l + 1):
        if b - a - c + i < 0:
            continue
        x = min(l - i, b - a - c + i)
        ans -= (x + 1) * (x + 2) // 2
    for i in range(l + 1):
        if c - a - b + i < 0:
            continue
        x = min(l - i, c - a - b + i)
        ans -= (x + 1) * (x + 2) // 2
    print(ans)

solve()
","a, b, c, d = list(map(int, input().split(' ')))

ans = -(d+1) * (d+2) * (d+3) // 6
for l1 in range(0, d+1):
    minx = min(d-l1, a-b-c+l1)
    if minx < 0:
        continue;
    else:
        ans += (minx + 1) * (minx + 2) // 2

a, b, c = b, c, a
for l1 in range(0, d+1):
    minx = min(d-l1, a-b-c+l1)
    if minx < 0:
        continue;
    else:
        ans += (minx + 1) * (minx + 2) // 2

a, b, c = b, c, a
for l1 in range(0, d+1):
    minx = min(d-l1, a-b-c+l1)
    if minx < 0:
        continue;
    else:
        ans += (minx + 1) * (minx + 2) // 2

print(-ans)
",text_b
3817,"MOD = 10**9 + 9
n, m = map(int, input().split())
p = [1]
for i in range(1, n + 1):
    p.append(p[-1] * 2 % MOD)
f = [0, p[m] - 1]
for i in range(2, n + 1):
    f.append((f[-1] * 2 + p[m - 1] * (p[i - 1] - 1)) % MOD)
print(f[n])
","n, m = map(int, input().split())
s, d = 1, 1000000009
k = pow(2, m, d) - 1
for i in range(n): s, k = (s * k) % d, k - 1
print(s)",text_b
3818,"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)
mod = 10**9+7

n = int(input())
G = [[] for _ in range(n+1)]
for _ in range(n-1):
    a, b = map(int,input().split())
    G[a].append(b)
    G[b].append(a)

dp1 = [1]*(n+1)
dp2 = [1]*(n+1)
order = []
stack = [1]
check = [0]*(n+1)
check[1] = 1
while stack:
    v = stack[-1]
    order.append(v)
    if G[v]:
        w = G[v].pop()
        if check[w]:
            continue
        check[w] = 1
        stack.append(w)
    else:
        stack.pop()

for v in order[::-1]:
    for w in G[v]:
        dp1[v] *= dp2[w]
        dp1[v] %= mod
        dp2[v] *= dp1[w]+dp2[w]
        dp2[v] %= mod
    dp1[v] += dp2[v]
    dp1[v] %= mod

print((pow(2,n,mod)-dp1[1]+mod)%mod)
","from collections import deque
n = int(input())
graph = [[] for i in range(n + 1)]
for _ in range(n - 1):
  i, j = map(int, input().split())
  graph[i].append(j)
  graph[j].append(i)
mod = 10 ** 9 + 7

def bfs(x):
  q = deque([(0, x, 0)])
  dist = {x: 0}
  while q:
    step, i, par = q.popleft()
    dist[i] = step
    for j in graph[i]:
      if j == par: continue
      q.append((step + 1, j, i))
  return [step, i, dist]

_, black, _ = bfs(1)
maxdist, white, b_dist = bfs(black)
_, _, w_dist = bfs(white)

mindls = float(""-inf"")
maxdls = [0] * n
for i in range(1, n + 1):
  if i in (white, black):
    continue
  mindls = max(mindls, min(w_dist[i], b_dist[i]))
  maxdls[max(w_dist[i], b_dist[i])] += 1
ans = pow(2, n - 1, mod) * maxdist % mod
pre = 0
for i in range(1, maxdist + 1):
  if i == maxdist and not maxdls[i]: continue
  maxdls[i] += maxdls[i - 1]
  if mindls > i: continue
  ans += (pow(2, maxdls[i], mod) - pre) * i * 2
  ans %= mod
  pre = pow(2, maxdls[i], mod)
print(ans)",text_b
3819,"import sys
from collections import deque
n = int(input())
hand = list(map(int,input().split()))
pile = deque(list(map(int,input().split())))
hand.sort()
hand = deque(hand)
cnt = [0]*(n+1)
for i in range(n):
    if hand[i] != 0:
        cnt[hand[i]] = i+1
for i in range(1,n+1):
    cnt[i] = max(cnt[i],cnt[i-1])
idx = 0
while idx < n and pile[idx] == 0:
    idx += 1
if idx == n:
    print(n)
    sys.exit()
start = pile[idx]
flag = False
for i in range(start,n+1):
    if pile[idx] != i:
        flag = True
        break
    idx += 1
if not flag and cnt[start-1] <= n-idx:
    print(n-idx)
else:
    print(n+max(0,pile[idx-1]-1-cnt[pile[idx-1]-1]))
","import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)
def pe(s): return print(str(s), file=sys.stderr)
def JA(a, sep): return sep.join(map(str, a))

def bs(f, mi, ma):
    mm = -1
    while ma > mi:
        mm = (ma+mi) // 2
        if f(mm):
            mi = mm + 1
        else:
            ma = mm
    if f(mm):
        return mm + 1
    return mm

def main():
    n = I()
    a = LI()
    b = LI()
    if b == list(range(1,n+1)):
        return 0

    ss = set(a)
    if 1 not in ss:
        i = b.index(1)
        bf = 1
        for j in range(i,n):
            if b[j] != j - i + 1:
                bf = 0
                break
        if bf:
            t = b[-1]
            s = ss | set()
            for j in range(n-t):
                if t+j+1 not in s:
                    bf = 0
                    break
                s.add(b[j])
            if bf:
                return n - t

    def f(i):
        s = ss | set(b[:i])
        for j in range(1,n+1):
            if j not in s:
                return True
            if i + j <= n:
                s.add(b[i+j-1])

        return False

    r = bs(f,0,n)

    return r + n


print(main())

",text_b
3820,"n, m = map(int, input().split())
s = input()
t = input()

if '*' in s:
    prefix, suffix = s.split('*')
    if not t.startswith(prefix) or not t.endswith(suffix) or len(t) < len(s) - 1:
        print('NO')
    else:
        print('YES')
else:
    if s == t:
        print('YES')
    else:
        print('NO')
","#!/usr/bin/env python3
def solve(n, m, s, t):
    if '*' in s:
        l, r = s.split('*')
        return len(l) + len(r) <= len(t) and t.startswith(l) and t.endswith(r)
    else:
        return s == t

n, m = list(map(int, input().split()))
s = input()
t = input()
print(['NO', 'YES'][solve(n, m, s, t)])
",text_b
3821,"n = int(input())
p = list(map(float, input().split()))
p.sort(reverse=True)
dp = [0] * (n + 1)
dp[0] = 1
for i in range(n):
    for j in range(i + 1, -1, -1):
        dp[j] = max(dp[j] * (1 - p[i]), dp[j - 1] * p[i] if j else 0)
print(max(dp))
","n = int(input())
a = list(map(float, input().split()))
a.sort()
s = a[-1]
p = 1 - a[-1]
for i in range(n - 2, -1, -1):
	if s < s * (1 - a[i]) + a[i] * p:
		s = s * (1 - a[i]) + a[i] * p
		p *= (1 - a[i])
print('%.9lf' % s)
",text_b
3822,"import math
n, l, v1, v2, k = map(int, input().split())
g = math.ceil(n / k)
b = (l / (1 + (v1 / v2) * ((g - 1) / g)))
a = l - b
print(a / v1 + b / v2)
","import sys
n, l, v1, v2, k = list(map(int, input().split()))
n = (n + k - 1) // k
if n == 1:
	print(l / v2)
	return

L, R = 0, l
for i in range(100):
	M = (L + R) / 2
	S = l - M
	T = M * (n * 2 - 1)- l
	if T * v1 > S * v2:
		R = M
	else:
		L = M

print(M / v2 + S / v1)
",text_b
3823,"import math
n = int(input())
a = list(map(float, input().split()))
dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
for i in range(n+1):
    for j in range(n+1):
        dp[i][j] = 1e9
dp[0][0] = 0
cnt = [0, 0]
for i in range(2*n):
    cnt[int(a[i] == int(a[i]))] += 1
    for j in range(cnt[0]+1):
        if cnt[1] >= i-j+1:
            dp[cnt[0]][j] = min(dp[cnt[0]][j], abs(j - (a[i] - int(a[i]))))
        if j > 0:
            dp[cnt[0]][j] = min(dp[cnt[0]][j], dp[cnt[0]][j-1] + abs((j-1) - (a[i] - math.floor(a[i]))))
print(""%.3f"" % min(dp[cnt[0]][j] for j in range(n+1)))
","k = 0
ans = 0
n = int(input())
a = input().split()
for i in range(2 * n):
    s = float(a[i])
    if s != int(s):
        k+=1
        ans += (int(s) + 1 - s)

if ans - int(ans) > 0.5:
    p = int(ans) + 1
else:
    p = int(ans)
if p > n:
    p = n
if (p + n >= k):
    print('%.3f'% abs(ans - p))
else:
    print('%.3f'% abs(ans - k + n))
",text_b
3824,"x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
dx = abs(x1 - x2)
dy = abs(y1 - y2)
if dx == 0 or dy == 0:
    print(2 * (dx + dy + 2))
else:
    print(2 * (dx + dy))","Q = input().split("" "")
F = input().split("" "")
xQ = int(Q[0])
yQ = int(Q[1])
xF = int(F[0])
yF = int(F[1])

if xQ == xF:
    print((abs(yQ-yF)+1)*2+4)
elif yQ == yF:
    print((abs(xQ-xF)+1)*2+4)
else:
    print((abs(xQ-xF)+1)*2+(abs(yQ-yF)+1)*2)
",text_b
3825,"n = int(input())
if n <= 3:
    print(n * (n + 1) // 2)
elif n == 4:
    print(10)
else:
    print((n - 3) * (n - 4) // 2 + 10)
","
# add 0,4,9,49
# this is a stupid solution

import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

n=int(input())

# do a stupid approach
dp=[0]*150
s=set([0])
for i in range(150):
    dp[i]=len(s)
    s2=set(s)
    for j in s:
        s2.add(j+4)
        s2.add(j+9)
        s2.add(j+49)
    s=s2

if 0:
    for i in range(100):
        if dp[i+49]-dp[i]!=2401:
            print(i)

if n<150: print(dp[n])
else:
    stuff=(n//49)
    while n-stuff*49+49<150: stuff-=1
    print(dp[n-stuff*49]+2401*stuff)",text_b
3826,"n = int(input())
a = list(map(int, input().split()))
a = [0] + a + [0]
f = [0]*(n+2)
g = [0]*(n+2)
pos = [0]*(n+2)
res = n
for i in range(1, n+1):
    f[i] = f[i-1]
    if pos[a[i]] > f[i]:
        f[i] = pos[a[i]]
    pos[a[i]] = i
pos = [0]*(n+2)
for i in range(n, 0, -1):
    g[i] = g[i+1]
    if pos[a[i]] < g[i]:
        g[i] = pos[a[i]]
    pos[a[i]] = i
for i in range(1, n+2):
    res = min(res, g[i] - f[i-1] - 1)
print(res)
","def main():
    import sys
    input = sys.stdin.readline
    
    n = int(input())
    arr = list(map(int, input().split()))
    
    dct = {}
    for x in arr:
        dct[x] = 0
    
    i = 0
    while i != n and dct[arr[i]] == 0:
        dct[arr[i]] = 1
        i += 1
    
    if i == n:
        print(0)
        return 0
    
    j = n - 1
    while dct[arr[j]] == 0:
        dct[arr[j]] = 1
        j -= 1
    
    ans = j - i + 1
    
    for k in range(i - 1, -1, -1):
        dct[arr[k]] -= 1
        while dct[arr[j]] == 0:
            dct[arr[j]] = 1
            j -= 1
        ans = min(ans, j - (k - 1))
    
    print(ans)
    
    return 0

main()",text_b
3827,"s = input()
a = s.count('a')
b = s.count('b')
c = s.count('c')
if a >= 1 and b >= 1 and (c == a or c == b) and s == 'a' * a + 'b' * b + 'c' * c:
    print('YES')
else:
    print('NO')
","'''input
aabc
'''

def list_input():
    return list(map(int,input().split()))
def map_input():
    return map(int,input().split())
def map_string():
    return input().split()
    
s = input()
a = s.count('a')
b = s.count('b')
c = s.count('c')
ans = ""YES""
if(a == 0 or b == 0): ans = ""NO""
if(c != a and c != b): ans = ""NO""
for i in range(len(s)-1):
	if(s[i] > s[i+1]): ans = ""NO""
print(ans)	",text_b
3828,"n = int(input())
a = list(map(int, input().split()))
dp = [0]*(n+1)
for i in range(n):
    dp[a[i]] = dp[a[i]-1] + 1
print(n - max(dp))
","n, p = int(input()), list(map(int, input().split()))
a, c, v = [0] * n, 1, 1
for i, pi in enumerate(p):
    a[pi - 1] = i
for i in range(n - 1):
    if a[i] < a[i + 1]:
        c += 1
        if c > v:
            v = c
    else:
        c = 1
print(n - v)",text_b
3829,"m, n = map(int, input().split())
p = [0] * (m + 1)
for i in range(1, m + 1):
    p[i] = pow(i / m, n) - pow((i - 1) / m, n)
print(sum([i * p[i] for i in range(m + 1)]))
","""""""
Codeforces Contest 259 Div 1 Problem A

Author  : chaotic_iak
Language: Python 3.3.4
""""""

def main():
    m,n = read()
    print(m - sum((i/m)**n for i in range(1,m)))

################################### NON-SOLUTION STUFF BELOW

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0: return inputs
    if mode == 1: return inputs.split()
    if mode == 2: return map(int, inputs.split())

def read_str(): return read(0)
def read_int(): return read(2)[0]

def write(s=""\n""):
    if isinstance(s, list): s = "" "".join(map(str, s))
    s = str(s)
    print(s, end="""")

main()",text_b
3830,"t = int(input())
for _ in range(t):
    n = int(input())
    s = input()
    if '>' in s and '<' in s:
        s += s[0]
        ans = 0
        for i in range(n):
            if s[i] == '-' or s[i+1] == '-':
                ans += 1
        print(ans)
    else:
        print(n)
","def solve():
    n = int(input())
    s = input()
    k = '-'
    tr = True
    for i in s:
        if k == '-' and i != '-':
            k = i
        if i != '-' and k != i:
            tr = False
    if tr:
        print(n)
        return 0
    ans = 0
    for i in range(n):
        if s[i] == ""-"" or s[i - 1] == '-':
            ans += 1
    print(ans)
for i in range(int(input())):
    solve()",text_b
3831,"n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]
b = [a[i][0] + a[i][1] for i in range(n)]
for i in range(1, n):
    b[i] = min(b[i], b[i - 1] + 1)
for i in range(n - 2, -1, -1):
    b[i] = min(b[i], b[i + 1] + 1)
if any(b[i] < a[i][0] for i in range(n)):
    print(-1)
else:
    print(sum(b) - sum(a[i][0] for i in range(n)))
    print(*b)
","t = []
l = []
r = []
for _ in range(int(input())):
	s, g = map(int, input().split())
	t.append(s)
	l.append(s)
	r.append(g + s)
	
for i in range(1, len(l)):
	if l[i] < l[i - 1]:
		l[i] = l[i - 1] - 1
	if r[i] > r[i - 1]:
		r[i] = r[i - 1] + 1
		
for i in range(len(l) - 2, -1, -1):
	if l[i] < l[i + 1]:
		l[i] = l[i + 1] - 1
	if r[i] > r[i + 1]:
		r[i] = r[i + 1] + 1

if [1 for a, b in zip(l, r) if a > b]:
	print(-1)
else:
	print(sum([b - a for a, b in zip(t, r)]))
	print(' '.join(map(str, r)))",text_b
3832,"import sys
from math import inf

n = int(input().strip())
a = list(map(int, input().strip().split()))

dp = [[inf]*n for _ in range(n//2+1)]
dp[0][0] = 0
for i in range(1, n):
    dp[0][i] = min(dp[0][i-1], max(0, a[i-1]-a[i]+1))

for i in range(1, n//2+1):
    dp[i][2*i-1] = dp[i-1][2*i-3] if i > 1 else 0
    dp[i][2*i-1] += max(0, a[2*i-2]-min(a[2*i-1], a[2*i-3] if i > 1 else inf)+1)
    for j in range(2*i, n):
        dp[i][j] = min(dp[i][j-1], dp[i-1][j-2]+max(0, a[j-1]-min(a[j], a[j-2] if j > 2 else inf)+1))

for i in range(1, n//2+1):
    dp[i][n-1] = min(dp[i][n-1], dp[i-1][n-2] if i > 1 else 0)

print(*[dp[i][n-1] for i in range(1, n//2+1)])
","def main():
    n, a, z = int(input()), 0, 10 ** 10
    b, *cc = list(map(int, input().split()))
    dp = [(0, z, z), (z, 0, z), *[(z, z, z)] * ((n - 1) // 2)]
    for i, c in enumerate(cc, 1):
        u, v, w = dp[i // 2 + 1]
        dz = max(0, c - b + 1)
        du = max(0, b - c + 1)
        dw = max(0, min(a - 1, b) - c + 1)
        for j in range(i // 2, -1, -1):
            x, y, z = u, v, w
            u, v, w = dp[j]
            dp[j + 1] = (x if x < z else z, min(u + du, w + dw), y + dz)
        a, b = b, c
    print(' '.join(map(str, list(map(min, dp[1:])))))


def __starting_point():
    main()

__starting_point()",text_b
3833,"s = input().strip()
t = input().strip()
s1 = s.count('1')
s0 = s.count('0')
t1 = t.count('1')
t0 = t.count('0')
if s1 < t1 or s0 < t0:
    print(s)
else:
    s1 -= t1
    s0 -= t0
    i = len(t) - 1
    while i > 0 and t[i:] != t[:-i]:
        i -= 1
    t1 -= t[:i].count('1')
    t0 -= t[:i].count('0')
    print(t + (s1 // t1 * t0 + s0) * '0' + (s1 // t1 * t1) * '1' + (s1 % t1) * '1')
","from sys import stdin,stdout
# stdout = open('output.txt', 'w+')
# stdin = open('input.txt','r+')


from collections import Counter
def prefixsuffixmatch(s):
	pi_table=[0 for i in range(len(s))]
	for i in range(1,len(s)):
		y=pi_table[i-1]
		while s[i]!=s[y] and y!=0:
			y=pi_table[y-1]
		if s[i]==s[y]:
			y+=1
		pi_table[i]=y
	return pi_table
def canprint(a,b):
	if a['0']>=b['0'] and a['1']>=b['1']:
		return True
	return False

def flushit(s):
	if '0' in s:
		stdout.write('0'* s['0'])
	if '1' in s:
		stdout.write('1'* s['1'])
def fillit(x):
	if '0' not in x:
		x['0']=0
	if '1' not in x:
		x['1']=0
	return x
	
s=stdin.readline().strip();counter_s=fillit(Counter(s))
t=stdin.readline().strip();counter_t=fillit(Counter(t))
t_pi_table=prefixsuffixmatch(t)
longest_match=t_pi_table[-1]

repeating_part=t[longest_match:]

counter_repeating_part=fillit(Counter(repeating_part))




if len(counter_s)==2 and len(counter_t)==2:
	if counter_s['0']>=counter_t['0'] and counter_s['1']>=counter_t['1']:
		stdout.write(t);counter_s['0']-=counter_t['0'];counter_s['1']-=counter_t['1'];


	# while canprint(counter_s,counter_repeating_part)==True:
	# 	stdout.write(repeating_part);
	# 	counter_s['0']-=counter_repeating_part['0'];
	# 	counter_s['1']-=counter_repeating_part['1'];

	if '0' in counter_repeating_part and '1' in counter_repeating_part:
		if counter_repeating_part['0']>0 and counter_repeating_part['1']>0:
			r=min(counter_s['0']//counter_repeating_part['0'],counter_s['1']//counter_repeating_part['1'])
			stdout.write(repeating_part*r);
			counter_s['0']-=(r*counter_repeating_part['0']);
			counter_s['1']-=(r*counter_repeating_part['1']);
	flushit(counter_s);


",text_b
3834,"n, m, k = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
if m == 1 or n == 1:
    ans = min(sum(a[i][0] != a[i - 1][0] for i in range(1, n)), sum(a[i][0] != a[i - 1][0] for i in range(1, m)))
    print(ans if ans <= k else -1)
else:
    ans = float('inf')
    for i in range(1 << n):
        b = [list(row) for row in a]
        res = bin(i).count('1')
        for j in range(m):
            cnt = sum(b[x][j] != ((i >> x) & 1) for x in range(n))
            if cnt * 2 > n:
                res += n - cnt
            else:
                for x in range(n):
                    b[x][j] = (i >> x) & 1
        if res <= k:
            ans = min(ans, res)
    print(ans if ans != float('inf') else -1)
","read_line = lambda: [int(i) for i in input().split()]

n, m, k = read_line()
a = [read_line() for i in range(n)]
if n < m:
    n, m, a = m, n, list(zip(*a))

xs = []
for y in a:
    x = 0
    for b in y:
        x = 2 * x + b
    xs.append(x)

def work(y):
    tot = 0
    for x in xs:
        c = bin(x ^ y).count('1')
        tot += min(c, m - c)
    return tot

ans = min(list(map(work, xs if m > k else list(range(1<<m)))))

print(ans if ans <= k else -1)
",text_b
3835,"import math
n = int(input())
a = [list(map(int,input().split())) for _ in range(n)]
x = int(math.sqrt(a[0][1]*a[0][2]/a[1][2]))
print(x, end=' ')
for i in range(1,n):
    print(a[0][i]//x, end=' ')
","n = int(input())
A = [list(map(int, input().split())) for _ in range(n)]
x = A[0][1]
y = A[1][2]
z = A[0][2]
p = (x * y * z) ** 0.5
a1 = p // y
a2 = p // z
a3 = p // x
ans = [round(a1), round(a2), round(a3)]
for i in range(3, n):
    ans.append(round(A[0][i] // a1))
print(' '.join(list(map(str, ans))))",text_b
3836,"from sys import stdin, stdout
from operator import itemgetter

n = int(stdin.readline())
people = []
alice = []
bob = []
none = []
for _ in range(n):
    s, a = stdin.readline().split()
    a = int(a)
    if s == '11':
        people.append(a)
    elif s == '10':
        alice.append(a)
    elif s == '01':
        bob.append(a)
    else:
        none.append(a)
people.sort(reverse=True)
alice.sort(reverse=True)
bob.sort(reverse=True)
none.sort(reverse=True)
while len(alice) > 0 and len(bob) > 0:
    people.append(alice.pop(0))
    people.append(bob.pop(0))
if len(alice) > 0:
    people += alice
elif len(bob) > 0:
    people += bob[:len(people)-len(bob)]
people += none[:len(people)-len(none)]
stdout.write(str(sum(people)) + '\n')
","n=int(input())
a=[];b=[];c=[];d=[]
for i in range(n):
    opt,num=[int(x) for x in input().split()]
    if opt==0:
        a.append(num)
    if opt==10:
        b.append(num)
    if opt==1:
        c.append(num)
    if opt==11:
        d.append(num)
ans=0
ans+=sum(d)
b.sort(reverse=True)
c.sort(reverse=True)
if len(b)<len(c):
    ans+=sum(b)+sum(c[0:len(b)])
    a.extend(c[len(b):])
else:
    ans+=sum(c)+sum(b[0:len(c)])
    a.extend(b[len(c):])
a.sort(reverse=True)
ans+=sum(a[0:len(d)])
print(ans)",text_b
3837,"import heapq
import sys
from operator import itemgetter

def solve():
    n, m, s = map(int, input().split())
    bugs = list(map(int, input().split()))
    students = list(zip(map(int, input().split()), map(int, input().split()), range(n)))
    students.sort(reverse=True)
    bugs = [(bug, i) for i, bug in enumerate(bugs)]
    bugs.sort(reverse=True)

    l = 0
    r = m + 1
    while r - l > 1:
        mid = (l + r) // 2
        total_passes = 0
        heap = []
        j = 0
        for i in range(mid - 1, -1, -1):
            while j < n and students[j][0] >= bugs[i][0]:
                heapq.heappush(heap, (-students[j][1], students[j][2]))
                j += 1
            if not heap:
                total_passes = s + 1
                break
            total_passes += -heap[0][0]
            bugs[i] = (bugs[i][1], heap[0][1] + 1)
            heapq.heappop(heap)
        if total_passes <= s:
            r = mid
        else:
            l = mid

    if r == m + 1:
        print(""NO"")
    else:
        print(""YES"")
        bugs.sort()
        print("" "".join(map(str, [bug[1] for bug in bugs])))

solve()
","from sys import stdin
import heapq

n,m,s = [int(x) for x in stdin.readline().split()]

bugs = [int(x) for x in stdin.readline().split()]
bugs = sorted([(bugs[x],x) for x in range(m)])

order = [x[1] for x in bugs]
bugs = [x[0] for x in bugs]

students = [int(x) for x in stdin.readline().split()]
rate = [int(x) for x in stdin.readline().split()]

valid = False
for x in range(n):
  if students[x] >= bugs[-1] and rate[x] <= s:
    valid = True
if not valid:
  print('NO')
else:
  print('YES')
  #print(students)
  for i,x in enumerate(students):
    low = 0
    high = m-1
    while high >= low:
      mid = (high+low)//2
      if bugs[mid] > x:
        high = mid-1
      else:
        low = mid+1
    #print(x,high)
    students[i] = high
  
  students = sorted([(students[x]+1,rate[x], x+1) for x in range(n)],reverse=True)
  #print(students)
  l1 = 1
  high = m

  lastValid = []
  lastD = 100000
  
  while l1 <= high:
    mid = (l1+high)//2
    shift = (mid-(m%mid))%mid
    segs = m//mid
    if shift > 0:
      segs += 1
    ind = 0
    q = []

    total = 0

    group = []

    for x in range(segs,0,-1):
      while ind<n:
        if (students[ind][0]+shift)//mid >= x:
          heapq.heappush(q,(students[ind][1],students[ind][2]))
          ind += 1
        else:
          break
      if q:
        r,i = heapq.heappop(q)
        group.append((x,i))
        total += r
      else:
        break
    if len(group) == segs and total <= s:
      #print(mid,total)
      high = mid-1
      lastValid = group
      lastD = mid
    else:
      l1 = mid+1
  complete = [0 for x in range(m)]
  lastValid.sort()
  mid = lastD
  shift = (mid-(m%mid))%mid
  skill = 1
  for bruh,i in lastValid:
    end = skill*mid-shift
    start = max(0,end-mid)
    for x in range(start,end):
      complete[x] = i
    skill += 1
  c2 = [0 for x in range(m)]
  for i,x in enumerate(complete):
    c2[order[i]] = x
  print(' '.join([str(x) for x in c2]))
  
  
  
        
    
    
",text_b
3838,"def main():
    n, k = map(int, input().split())
    q = list(map(int, input().split()))
    s = list(map(int, input().split()))
    q = [i-1 for i in q]
    s = [i-1 for i in s]
    p = [i for i in range(n)]
    q_inv = [0]*n
    for i in range(n):
        q_inv[q[i]] = i
    if k == 1:
        p = [p[q[i]] for i in range(n)]
        if p == s:
            print(""YES"")
        else:
            print(""NO"")
    else:
        p1 = [p[q[i]] for i in range(n)]
        p2 = [p[q_inv[i]] for i in range(n)]
        if p1 == s or p2 == s:
            print(""NO"")
        else:
            print(""YES"")

main()
","import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

n, k = mints()
q = list(mints())
for i in range(n):
	q[i] -= 1
s = list(mints())
a = [i for i in range(1,n+1)]
d = [0]*n
b = [False]*(k+1)
c = [False]*(k+1)
e = [10000]*2
f = [10000]*2
for i in range(k+1):
	#print(a)
	b[i] = (a == s)
	if b[i]:
		e[i%2] = min(e[i%2], i)
	for j in range(n):
		d[j] = a[q[j]]
	a,d = d,a
#print('====')
a = [i for i in range(1,n+1)]
for i in range(k+1):
	#print(a)
	c[i] = (a == s)
	if c[i]:
		f[i%2] = min(f[i%2], i)
	for j in range(n):
		d[q[j]] = a[j]
	a,d = d,a
#print('====')
#print(e)
#print(f)
if e[0] == 0:
	print('NO')
elif e[1] == 1:
	if f[1] == 1 and k > 1:
		print('NO')
	elif k%2 == 1 or f[k%2] <= k:
		print('YES')
	else:
		print('NO')
elif f[1] == 1:
	if k%2 == 1 or e[k%2] <= k:
		print('YES')
	else:
		print('NO')
else:
	if e[k%2] <= k or f[k%2] <= k:
		print('YES')
	else:
		print('NO')
",text_b
3839,"n = int(input())
for i in range(1, n+1):
    if i%3 == 0:
        print(i//3*2, 3)
    else:
        print((i+2)//3*2-1, i%3)
","#!/usr/bin/env python3
# -*- coding: utf-8 -*-

n = int(input())
above = n // 3
below = n - above
for i in range(above):
    print(2 * i + 1, 3)
for i in range(below):
    print(i, 0)
",text_b
3840,"def solve():
    n = int(input())
    a = list(map(int, input().split()))
    if n == 1 or n % 2 == 0:
        print(-1)
        return
    a = [0] + a
    f = [0] * (n + 1)
    for i in range(n, 0, -1):
        need = (a[i] + 1) // 2
        f[i] = max(need, f[2 * i] + f[2 * i + 1] if 2 * i + 1 <= n else f[2 * i])
        a[i - 1] = max(0, a[i - 1] - (a[i] - f[i]))
    print(f[1])

solve()
","3

n = int(input())
a = [0] + list(map(int, input().split()))
if len(a) < 3 or n % 2 == 0:
    print(-1)
else:
    ans = 0
    for x in range(n // 2, 0, -1):
        d = max(0, a[2 * x], a[2 * x + 1])
        ans += d
        a[x] -= d
    print(ans + max(0, a[1]))
",text_b
3841,"def solve(p, k):
    res = []
    while p:
        res.append(p % k)
        p = -(p // k)
    return res

p, k = map(int, input().split())
res = solve(p, k)
print(len(res))
print(*res)
","p, k = map(int, input().split())
k = -k

a = []
while p != 0:
  r = p % k
  p //= k
  if r < 0:
    r += -k
    p += 1
  a.append(r)

print(len(a))
print("" "".join(map(str, a)))",text_b
3842,"import sys
from bisect import bisect_right

n, p, q = map(int, input().split())
projects = sorted([list(map(int, input().split())) for _ in range(n)], reverse=True)

hull = [(0, 0)]
for a, b in projects:
    while hull[-1][1] <= b:
        hull.pop()
    hull.append((a, b))

INF = 1e18
lo, hi = 0, INF
while hi - lo > 1e-9:
    mid = (lo + hi) / 2
    max_b = -INF
    for a, b in hull:
        if a * mid >= p:
            max_b = max(max_b, b)
        else:
            idx = bisect_right(hull, ((p - a * mid) / (mid - a), INF))
            if idx < len(hull):
                max_b = max(max_b, (p - a * mid) / (mid - a) * hull[idx][1] + b)
            break
    if max_b * mid >= q:
        hi = mid
    else:
        lo = mid

print('%.15f' % hi)
","def get_bounds(points):
    if len(points) == 1:
        return points[:]
    points.sort()
    bounds = [points[0], points[1]]
    for xi, yi in points[2:]:
        while len(bounds) > 1 and not is_convex(bounds, xi, yi):
            del bounds[-1]
        bounds.append((xi, yi))
    return bounds


def is_convex(bounds, x2, y2):
    x1, y1 = bounds[-1]
    x0, y0 = bounds[-2]
    return (x1 - x0) * (y2 - y1) < (y1 - y0) * (x2 - x1)



def read_data():
    n, p, q = map(int, input().split())
    ABs = []
    for i in range(n):
        a, b = map(int, input().split())
        ABs.append((a, b))
    return n, p, q, ABs

def solve(n, p, q, ABs):
    '''
    min sum(ds)
    s.t. sum(ds[i] * As[i]) >= p and sum(ds[i] * Bs[i]) >= q
    '''
    bounds = get_bounds(ABs)
    a0, b0 = bounds[0]
    if len(bounds) == 1:
        return max(p/a0, q/b0)
    record = float('Inf')
    for a1, b1 in bounds[1:]:
        steps = min(max(p/a0, q/b0), max(p/a1, q/b1))
        den = a0 * b1 - b0 * a1
        if den != 0:
            r0 = (b1 * p - a1 * q)/den
            r1 = - (b0 * p - a0 * q)/den
            if r0 > 0 and r1 > 0:
                steps = min(steps, r0 + r1)
        a0 = a1
        b0 = b1
        record = min(record, steps)
    return record

n, p, q, ABs = read_data()
print(solve(n, p, q, ABs))",text_b
3843,"def solve():
    n, m = map(int, input().split())
    n -= 1
    m -= 1
    a = 0
    while n:
        a += 1
        n //= 7
    b = 0
    while m:
        b += 1
        m //= 7
    if a == 0:
        a = 1
    if b == 0:
        b = 1
    if a + b > 7:
        print(0)
        return
    n = 7
    m = a + b
    ans = 0
    for i in range(1 << n):
        if bin(i).count('1') == m:
            a = [0] * m
            b = [0] * m
            c = 0
            for j in range(n):
                if i & (1 << j):
                    a[c] = j
                    c += 1
            for j in range(m):
                for k in range(j + 1, m):
                    if a[j] > a[k]:
                        a[j], a[k] = a[k], a[j]
            while True:
                x = 0
                y = 0
                for j in range(m):
                    if j < b:
                        x = x * 7 + a[j]
                    else:
                        y = y * 7 + a[j]
                if x < int(input().split()[0]) and y < int(input().split()[1]):
                    ans += 1
                j = m - 1
                while j > 0 and a[j - 1] >= a[j]:
                    j -= 1
                if j == 0:
                    break
                k = m - 1
                while a[j - 1] >= a[k]:
                    k -= 1
                a[j - 1], a[k] = a[k], a[j - 1]
                a[j:] = a[:j - 1:-1]
    print(ans)


solve()
","from itertools import *
def f(x):
    x -= 1
    ret = 0
    if x == 0:
        ret = 1
    else:
        while x != 0:
            ret += 1
            x //= 7
    return ret

def g(d):
    ret = 0
    for v in d:
        ret = ret * 7 + v
    return ret



n, m = list(map(int, input().split()))
a = f(n)
b = f(m)
if a + b > 7:
    print(0)
else:
    ans = 0
    for p in permutations(list(range(7)), a + b):
        if g(p[:a]) < n and g(p[a:]) < m:
            ans += 1
    print(ans)


",text_b
3844,"from collections import Counter

n = int(input())
a = list(map(int, input().split()))
c = Counter(a)

for i in c.values():
    if i % 2 != 0:
        print(""Conan"")
        break
else:
    print(""Agasa"")
","n = int(input())
a = list(map(int, input().split()))
s = set(a)
m = {i: 0 for i in s}
for i in a:
	m[i] += 1
win = ''
for i in sorted(m)[::-1]:
	if m[i] % 2:
		win = 'Conan'
		break
if win:
	print(win)
else:
	print('Agasa')",text_b
3845,"A, B = map(int, input().split())
A -= 1
B -= 1
grid = [['.' if i < 50 else '#' for _ in range(100)] for i in range(100)]
for i in range(0, 50, 2):
    for j in range(0, 100, 2):
        if A == 0:
            break
        grid[i][j] = '#'
        A -= 1
    if A == 0:
        break
for i in range(51, 100, 2):
    for j in range(0, 100, 2):
        if B == 0:
            break
        grid[i][j] = '.'
        B -= 1
    if B == 0:
        break
print(100, 100)
for row in grid:
    print(''.join(row))
","




A,B = list(map(int, input().split()))

S = [[""."" if h < 50 else ""#"" for _ in range(100) ] for h in range(100)]

end_black = False
for i in range(0,50,2):
    if end_black:
        break
    for j in range(100):
        if B <= 1:
            end_black = True
            break
        
        if j % 2 == 0:
            S[i][j] = ""#""
            B -= 1


end_white = False
for i in range(53,100, 2):
    if end_white:
        break
    for j in range(100):
        if A <= 1:
            end_white = True
            break
        
        if j % 2 == 0:
            S[i][j] = "".""
            A -= 1

print((100,100))
for i in range(100):
    print(("""".join(S[i])))

",text_b
3846,"n, m = map(int, input().split())
a = [0]*n
b = [0]*n
c = [0]*n
d = [0]*n
e = [0]*n
f = [0]*n
g = [0]*n
h = [0]*n
j = [0]*n
k = [0]*n
l = [0]*n
p = [0]*n
q = [0]*n
r = [0]*n
s = [0]*n
t = [0]*n
u = [0]*n
v = [0]*n
w = [0]*n
x = [0]*n
y = [0]*n
z = [0]*n
for i in range(m):
    s, t = input().split()
    t = int(t)-1
    if s == '+':
        if i > 0 and a[i-1] > 0:
            b[t] = 1
        a[i] = a[i-1]+1
        c[t] = 1
        if a[i] > 1:
            d[t] = 1
    else:
        if c[t] == 0:
            if i > 0 and a[i-1] > 0:
                b[t] = 1
            a[i] = a[i-1]+1
            c[t] = 1
        else:
            a[i] = a[i-1]-1
            if a[i] > 0:
                d[t] = 1
    e[t] = i
for i in range(n):
    if e[i] < m-1 and a[e[i]]-1 > 0:
        b[i] = 1
    if a[-1] > 0 and c[i] == 1 and d[i] == 0:
        b[i] = 1
print(b.count(0))
for i in range(n):
    if b[i] == 0:
        print(i+1, end=' ')
","#!/Library/Frameworks/Python.framework/Versions/3.6/bin/python3
'''
Created on 13/09/2018

@author: ernesto
'''

n, m = [int(x) for x in input().strip().split("" "")]

posibles_jefes = set(range(1, n + 1))
anteriores = set()
posteriores = set()
continuos = [True] * (n + 1)
mencionados = set()
posibles_jefes_mencionados = set()
ultimo_en_salir = [True] * (n + 1)
ultima_salida_inesperada = None

ops = []

if(m > 1):
    for _ in range(0, m):
        s, n_s = [x for x in input().strip().split("" "")]
        n = int(n_s)
        ops.append((s, n))
    for i in range(0, m):
        op, num = ops[i]
        cont = False
        if op == '+':
            cont = not i or (ops[i - 1][0] == '-' and ops[i - 1][1] == num)
            posteriores.add(num)
        if op == '-':
            cont = i == m - 1 or (ops[i + 1][0] == '+' and ops[i + 1][1] == num)
            if num not in mencionados:
                anteriores.add(num)
                ultima_salida_inesperada = num
            posteriores.discard(num)
            ultimo_en_salir[num] &= not posteriores
        continuos[num] &= cont 
        mencionados.add(num)
#    print(""anteriores {} posteriores {} continuos {} ops {}"".format(anteriores, posteriores, continuos, ops))
    if not anteriores and not posteriores:
        assert ultima_salida_inesperada is None
        if ops[0][0] == '+' and ops[-1][0] == '-' and ops[0][1] == ops[-1][1] and continuos[ops[0][1]] and ultimo_en_salir[ops[0][1]]:
            posibles_jefes_mencionados.add(ops[0][1])
    else:
        if not posteriores:
            assert ultima_salida_inesperada is not None
            posibles_jefes_filtrados = list([x for x in anteriores if continuos[x] and ultimo_en_salir[x] and ultima_salida_inesperada == x])
            assert len(posibles_jefes_filtrados) <= 1
            if(posibles_jefes_filtrados):
                assert posibles_jefes_filtrados[0] == ops[-1][1]
                posibles_jefes_mencionados.add(ops[-1][1])
        else:
            if not anteriores:
                assert ultima_salida_inesperada is None
                posibles_jefes_filtrados = list([x for x in posteriores if continuos[x] and ultimo_en_salir[x]])
#                print(""posibles {}"".format(posibles_jefes_filtrados))
                assert len(posibles_jefes_filtrados) <= 1
                if(posibles_jefes_filtrados):
                    assert posibles_jefes_filtrados[0] == ops[0][1]
                    posibles_jefes_mencionados.add(ops[0][1])
            else:
                assert ultima_salida_inesperada is not None
#                print(""continuos {}"".format(continuos))
                posibles_jefes_mencionados = set([x for x in anteriores & posteriores if ultimo_en_salir[x] and continuos[x] and ultima_salida_inesperada == x])

#    print(""posibles jefes menc {}"".format(posibles_jefes_mencionados))
    posibles_jefes -= (mencionados - posibles_jefes_mencionados)
        
print(len(posibles_jefes))
if(len(posibles_jefes)):
    print("" "".join(map(str, sorted(posibles_jefes))))
",text_b
3847,"n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
x = int(input())

a.sort()
b.sort()

prefix_a = [0] * (n + 1)
prefix_b = [0] * (m + 1)

for i in range(n):
    prefix_a[i + 1] = prefix_a[i] + a[i]

for i in range(m):
    prefix_b[i + 1] = prefix_b[i] + b[i]

max_size_a = [0] * (prefix_a[-1] + 1)
max_size_b = [0] * (prefix_b[-1] + 1)

for i in range(n):
    for j in range(i, n):
        sum_a = prefix_a[j + 1] - prefix_a[i]
        size_a = j - i + 1
        max_size_a[sum_a] = max(max_size_a[sum_a], size_a)

for i in range(m):
    for j in range(i, m):
        sum_b = prefix_b[j + 1] - prefix_b[i]
        size_b = j - i + 1
        max_size_b[sum_b] = max(max_size_b[sum_b], size_b)

for i in range(1, len(max_size_a)):
    max_size_a[i] = max(max_size_a[i], max_size_a[i - 1])

for i in range(1, len(max_size_b)):
    max_size_b[i] = max(max_size_b[i], max_size_b[i - 1])

answer = 0
for sum_a in range(len(max_size_a)):
    if sum_a > x:
        break
    size_a = max_size_a[sum_a]
    size_b = max_size_b[min(x // sum_a, prefix_b[-1])]
    answer = max(answer, size_a * size_b)

print(answer)
","import bisect
n,m=list(map(int,input().split()))
L1=list(map(int,input().split()))
L2=list(map(int,input().split()))
x=int(input())
newL1=[0]
newL2=[0]
for i in L1:newL1.append(newL1[-1]+i)
for i in L2:newL2.append(newL2[-1]+i)
min1=[]
min2=[]
mx=9999999999999999999
for i in range(1,n+1):
    m1=mx
    for j in range(n-i+1):
        if newL1[j+i]-newL1[j]<m1:m1=newL1[j+i]-newL1[j]
    min1.append(m1)
for i in range(1,m+1):
    m2=mx
    for j in range(m-i+1):
        if newL2[j+i]-newL2[j]<m2:m2=newL2[j+i]-newL2[j]
    min2.append(m2)
area=0
for i in range(n):
    k=x//min1[i]
    for j in range(m):
        if min2[j]>k:break
    if min2[-1]<=k:j+=1
    if area<j*(i+1):area=j*(i+1)
print(area)
",text_b
3848,"def solve():
    n, p = map(int, input().split())
    s = list(input())
    s.append('a')
    for i in range(n - 1, -1, -1):
        for j in range(ord(s[i]) + 1, ord('a') + p):
            s[i] = chr(j)
            if (i >= 2 and s[i] == s[i - 1] == s[i - 2]) or (i >= 1 and s[i] == s[i - 1]):
                continue
            for k in range(i + 1, n):
                for l in range(ord('a'), ord('a') + p):
                    s[k] = chr(l)
                    if (k >= 2 and s[k] == s[k - 1] == s[k - 2]) or (k >= 1 and s[k] == s[k - 1]):
                        continue
                    break
                else:
                    break
            else:
                print(''.join(s[:-1]))
                return
    print('NO')

solve()
","3

import sys


def solve(s, k):
    l = len(s)
    for i in range(l-1, -1, -1):
        prev = s[max(i-2, 0):i]
        z = s[i] + 1
        while z in prev:
            z += 1
        if z >= k:
            continue
        # Gotcha!
        ret = s[:i] + [z]
        while len(ret) < l:
            prev = ret[max(len(ret)-2, 0):len(ret)]
            z = 0
            while z in prev:
                z += 1
            ret.append(z)
        return ret
    return None


def __starting_point():
    l, k = list(map(int, sys.stdin.readline().split()))
    s = [ord(c) - ord('a') for c in sys.stdin.readline().strip()]
    ans = solve(s, k)
    if ans is None:
        print('NO')
    else:
        print(''.join(chr(ord('a') + x) for x in ans))

__starting_point()",text_b
3849,,"import sys
import copy
input = sys.stdin.readline

n,k=list(map(int,input().split()))
C=list(input().strip())

def JUDGE(C):
    ANS_one=0
    ANS_zero=0

    for c in C:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C[::-1]:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C:
        if c==""1"":
            ANS_one+=1
        else:
            break

    for c in C[::-1]:
        if c==""1"":
            ANS_one+=1
        else:
            break

    if ANS_zero>=n-k or ANS_one>=n-k:
        return 1
    else:
        return 0

if JUDGE(C)==1:
    print(""tokitsukaze"")
    return

if k>=n-1:
    print(""quailty"")
    return
if k<n/2:
    print(""once again"")
    return
    

CAN1=copy.copy(C)
CAN2=copy.copy(C)

if C[0]==""0"":
    for i in range(1,k+1):
        CAN1[i]=""1""
else:
    for i in range(1,k+1):
        CAN1[i]=""0""

if C[-1]==""0"":
    for i in range(n-1,n-k-1,-1):
        CAN2[i]=""1""
else:
    for i in range(n-2,n-k-2,-1):
        CAN2[i]=""0""

if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:
    print(""quailty"")
    return
else:
    print(""once again"")
    return
    
    
    
",text_b
3850,"from heapq import *
n, k, p = map(int, input().split())
a = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
l = 0
r = 2 * 10 ** 9
while r - l > 1:
    m = (l + r) // 2
    q = []
    j = 0
    f = 1
    for i in range(n):
        while j < k and b[j] <= a[i] + m:
            heappush(q, b[j] - a[i])
            j += 1
        if not q or q[0] < a[i] - p:
            f = 0
            break
        heappop(q)
    if f and j == k and len(q) < n - i - 1:
        f = 0
    if f:
        r = m
    else:
        l = m
print(r)
","read = lambda: map(int, input().split())
n, k, p = read()
a, b = sorted(read()), sorted(read())
print(min(max(abs(b[i + d] - a[i]) + abs(b[i + d] - p) for i in range(n)) for d in range(k - n + 1)))",text_b
3851,"from math import gcd
from sys import stdin, stdout
n, k = map(int, stdin.readline().split())
a, b = map(int, stdin.readline().split())
def solve(n, k, a, b):
    x = n * k
    y = 1
    for i in range(n):
        for j in range(-1, 2, 2):
            p = (i * k + a) % (n * k)
            q = (i * k + b + j * k) % (n * k)
            g = gcd(n * k, abs(p - q))
            x = min(x, n * k // g)
            y = max(y, n * k // g)
    return x, y
x, y = solve(n, k, a, b)
stdout.write(str(x) + ' ' + str(y) + '\n')
","ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())
from math import gcd

n, k = mi()
a, b = mi()
s = n * k

mn, mx = 10 ** 15, -1

def solve(start):
    nonlocal mn, mx
    for i in range(n):
        bef = k * i - b
        l = (bef - start) % s
        turns = s // gcd(s, l)
        mn = min(mn, turns)
        mx = max(mx, turns)
        aft = k * i + b
        l = (aft - start) % s
        turns = s // gcd(s, l)
        mn = min(mn, turns)
        mx = max(mx, turns)

solve(a)
solve(s - a)
print(mn, mx)",text_b
3852,"N = int(input())
A = list(map(int, input().split()))
min_a = min(A)
max_a = max(A)
min_i = A.index(min_a)
max_i = A.index(max_a)
if abs(min_a) > abs(max_a):
    print(2*N-1)
    for i in range(N):
        print(min_i+1, i+1)
    for i in range(N-1):
        print(i+1, i+2)
else:
    print(2*N-1)
    for i in range(N):
        print(max_i+1, i+1)
    for i in range(N-1, 0, -1):
        print(i+1, i)
","N = int(input())
A = list(map(int,input().split()))
if min(A) >= 0:
  Flag = True
elif max(A) <= 0:
  Flag = False
else:
  p_max = max(A)
  m_max = min(A)
  if abs(p_max) >= abs(m_max):
    Flag = True
  else:
    Flag = False
if Flag:
  MAX = max(A)
  for i,v in enumerate(A):
    if v == MAX:
      MAX_loc = i
      break
  ans = []; t = 0
  for i in range(N-1):
    if A[i+1] >= A[i]:
      continue
    A[i+1] += 2*MAX
    ans.append([MAX_loc+1,i+1+1])
    ans.append([MAX_loc+1,i+1+1])
    t += 2
    MAX_loc = i+1
    MAX = A[i+1]

else:
  MIN = min(A)
  for i, v in enumerate(A):
    if v == MIN:
      MIN_loc = i
      break
  ans = []; t = 0
  for i in range(N-1):
    if A[N-1-i] >= A[N-2-i]:
      continue
    A[N-2-i] += 2*MIN
    ans.append([MIN_loc+1,N-2-i+1])
    ans.append([MIN_loc+1,N-2-i+1])
    t += 2
    MIN_loc = N-2-i
    MIN = A[N-2-i]
print(t)
for x in ans:
  print((*x))
#print(ans,t,A)    
",text_b
3853,"import math
n = int(input())
a = [list(map(int,input().split())) for _ in range(n)]
a.sort()
b = [0]*(n+1)
b[n] = a[n-1][0]+1
for i in range(n-1,-1,-1):
    b[i] = max(b[i+1],a[i][0]+1+math.ceil(math.log2(a[i][1])))
print(b[0])
","n = int(input())
t = [tuple(map(int, input().split())) for i in range(n)]

m = max(t)
d = 2 * m[0] + len(bin(m[1])) - 1

t = sorted([i for i in t if 2 * i[0] + len(bin(i[1])) > d])
p, k = t[0][0], t[0][1] - 1

for i in range(1, len(t)):
    p, k = t[i][0], max(t[i][1] - 1, k >> 2 * (t[i][0] - p))

print(p + (len(bin(k)) + 1) // 2 - 1)",text_b
3854,"n, k = map(int, input().split())
c = list(map(int, input().split()))
dp = [[0]*501 for _ in range(501)]
dp[0][0] = 1
for i in range(n):
    for j in range(k, -1, -1):
        for l in range(c[i], 501):
            if dp[j][l-c[i]]:
                dp[j+c[i]][l] = 1
res = [i for i in range(501) if dp[k][i]]
print(len(res))
print(*res)
","#coding gbk
#!usr/bin/ENV
cin =lambda : list(map(int,input().split()))
n, k = cin()
c=list(cin())
dp = [0]*(k+1)
dp[0]=1
for i in c:
    tmp = dp[:]
    for x in range(k,i-1,-1):
        tmp[x] |= dp[x-i]|(dp[x-i]<<i)
    dp = tmp
b = bin(dp[-1])
ans = [i for i in range(k + 1) if b[-i - 1] == '1']
print(len(ans))
print(*ans)
",text_b
3855,"import math
n = int(input().strip())
print(math.ceil(math.log2(n+1)))
","
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

n=int(input())

ans=1
while 2**ans-1<n:
    ans+=1
print(ans)

",text_b
3856,"from sys import stdin, stdout
from heapq import *
n = int(stdin.readline())
a = []
for i in range(n):
    w, h = map(int, stdin.readline().split())
    a.append((max(w, h), min(w, h)))
a.sort(reverse=True)
H = a[0][0]
W = sum(x[1] for x in a)
heap = []
for i in range(n):
    if len(heap) < n // 2:
        heappush(heap, a[i][1])
        W += a[i][0] - a[i][1]
    else:
        if heap and heap[0] < a[i][1]:
            W += a[i][0] - heap[0]
            heappushpop(heap, a[i][1])
        else:
            W += a[i][0] - a[i][1]
            H = max(H, a[i][1])
stdout.write(str(min(W * H, sum(x[0] for x in a) * H)))
","from operator import neg
n = int(input())
a = [tuple(map(int, input().split())) for i in range(n)]

def check(max_h):
    k = n // 2
    b = []
    for w, h in a:
        if h > max_h:
            if k <= 0 or w > max_h:
                return 1 << 60
            b.append((h, w))
            k -= 1
        else:
            b.append((w, h))
    b.sort(key=lambda t: t[1] - t[0])
    r = 0
    for w, h in b:
        if k > 0 and w <= max_h and h < w:
            r += h
            k -= 1
        else:
            r += w
    return r * max_h

print(min(check(h) for h in range(1, 1001)))
    
        
",text_b
3857,"n = int(input())
x = list(map(int, input().split()))
x.sort()
piles = [0]*n
for i in range(n):
    piles[i%n] += 1
    if piles[i%n] > x[i]:
        print(-1)
        exit(0)
print(max(piles))
","n = int(input())
ar = list(map(int,input().split(' ')))
ar.sort()
s=[]
for i in ar:
	s.sort(reverse=True)
	for j in range(len(s)):
		if i>=s[j]:
			s[j]+=1
			break
	else:
		s.append(1)
print(len(s))
",text_b
3858,"from collections import defaultdict
from itertools import combinations

MOD = 998244353
N = int(input())
XY = [tuple(map(int, input().split())) for _ in range(N)]
XY.sort()

pow2 = [1]
for _ in range(N):
    pow2.append(pow2[-1]*2%MOD)

ans = pow2[N] - 1 - N
for n in range(2, N+1):
    for comb in combinations(range(N), n):
        x0, y0 = XY[comb[0]]
        vec = defaultdict(int)
        for i in range(1, n):
            x, y = XY[comb[i]]
            vec[(y-y0, x-x0)] += 1
        ans -= pow2[n] - 1 - n
        for v in vec.values():
            ans += pow2[v] - 1 - v
        ans %= MOD

print(ans)
","import sys
input = sys.stdin.readline
from fractions import gcd
from collections import Counter

""""""
適当に部分集合Xをとり、凸包 S として、Sに1点計上すればよい
これだと2^N点得られる
ただし、凸包の面積が0となる場合が例外
空集合、1点の場合と、線分の場合を除外する

""""""

MOD = 998244353
N = int(input())
XY = [[int(x) for x in input().split()] for _ in range(N)]

answer = pow(2,N,MOD)
answer -= N + 1# 空、1点
for i,(x,y) in enumerate(XY):
    # i を選び、i+1番目以上のうちいくつかを選んで線分とする
    pts = []
    for x1, y1 in XY[i+1:]:
        dx, dy = x1-x, y1-y
        g = gcd(dx, dy)
        dx //= g
        dy //= g
        # 標準化
        if dx < 0:
            dx, dy = -dx, -dy
        elif dx == 0:
            dy = 1
        pts.append((dx,dy))
    c = Counter(pts)
    for v in c.values():
        answer -= pow(2,v,MOD) - 1

answer %= MOD
print(answer)",text_b
3859,"import sys
input = sys.stdin.readline
INF = 10**18

N = int(input())
balls = [tuple(map(str, input().split())) for _ in range(2*N)]
balls = [(c, int(a)) for c, a in balls]

dp = [[INF]*(N+1) for _ in range(N+1)]
dp[0][0] = 0

W = [0]*(N+1)
B = [0]*(N+1)

for i in range(2*N):
    c, a = balls[i]
    if c == 'W':
        W[a] = i+1
    else:
        B[a] = i+1

for i in range(N+1):
    for j in range(N+1):
        if i > 0:
            dp[i][j] = min(dp[i][j], dp[i-1][j] + sum(1 for k in range(j+1, N+1) if B[k] < W[i]))
        if j > 0:
            dp[i][j] = min(dp[i][j], dp[i][j-1] + sum(1 for k in range(i+1, N+1) if W[k] < B[j]))

print(dp[N][N])
","N = int(input())
X = [i for i in range(N+1)]
Y = [[] for _ in range(N)]
B, W = [], []
ans = 0
for i in range(2 * N):
    c, a = input().split()
    a = int(a) - 1
    if c == ""B"":
        X = [X[i] + 1 if i <= a else X[i] - 1 for i in range(N+1)]
        B.append(a)
        ans += len([b for b in B if b > a])
    else:
        Y[a] = X[:]
        W.append(a)
        ans += len([b for b in W if b > a])

Z = [0] * (N+1)
for y in Y:
    for i in range(N+1):
        Z[i] += y[i]
    for i in range(1, N+1):
        Z[i] = min(Z[i], Z[i-1])

ans += Z[-1]
print(ans)",text_b
3860,"b = int(input())
g = int(input())
n = int(input())

print(min(b, g, n) - max(0, n - max(b, g)) + 1)","def main():
    import sys
    input = sys.stdin.readline
    
    b = int(input())
    g = int(input())
    n = int(input())
    
    ans = n + 1
    if b < n:
        ans -= n - b
    if g < n:
        ans -= n - g
    
    print(ans)
    
    return 0

main()
",text_b
3861,"import math
n = int(input())
a = list(map(int, input().split()))
a.sort(reverse=True)
for i in a:
    if math.sqrt(i) != int(math.sqrt(i)):
        print(i)
        break
","n = int(input())
a = [int(i) for i in input().split()]
a.sort()
a.reverse()
for i in a:
    if i < 0:
        print(i)
        return
    if int(i ** 0.5) ** 2 != i:
        print(i)
        return",text_b
3862,"from heapq import *
from sys import stdin, stdout
n, k = map(int, stdin.readline().split())
a = list(map(int, stdin.readline().split()))
a = list(set(a))
a.sort()
k = len(a)
l = 0
r = k - 1
d = [0] * 2005
q = []
for i in range(2005):
    d[i] = 10**9
d[a[l] - n + 1000] = a[l]
d[a[r] - n + 1000] = a[r]
heappush(q, (a[l], a[l] - n + 1000))
heappush(q, (a[r], a[r] - n + 1000))
while len(q) > 0:
    v, p = heappop(q)
    if p == 1000:
        stdout.write(str(v) + ""\n"")
        exit(0)
    if l > 0 and p - a[l - 1] + 1000 >= 0 and d[p - a[l - 1] + 1000] > v + a[l - 1]:
        d[p - a[l - 1] + 1000] = v + a[l - 1]
        heappush(q, (v + a[l - 1], p - a[l - 1] + 1000))
    if r + 1 < k and p + a[r + 1] - 1000 >= 0 and d[p + a[r + 1] - 1000] > v + a[r + 1]:
        d[p + a[r + 1] - 1000] = v + a[r + 1]
        heappush(q, (v + a[r + 1], p + a[r + 1] - 1000))
stdout.write(""-1\n"")
","##
##
##
import sys
def line():
    return sys.stdin.readline()

def numbers():
    return list(map(int, line().split()))

def number():
    return int(line())

adjlist = {}
n, k = 0, 0
mark = [False]*2010
edges = [False]*1010

# bfs for ""ssph""
def bfs(s):
    
    i = 0
    frontier = [s]
    while frontier:

        if mark[s]:
            break;

        next_frontier = []
        for u in frontier:

            # check next state
            for v, isState in enumerate(edges):
                if isState:
                    # check new node
                    state = u + (n - 1000) - v

                    if state >= 0 and state <= 2000 and not mark[state]:
                        mark[state] = True
                        next_frontier.append(state)

        frontier = next_frontier
        i += 1

    if mark[s]:
        return i
    else:
        return -1

# main program
[n, k] = numbers()
concentrations = numbers()

# reading edges
for x in concentrations:
    edges[x] = True

n = n + 1000
ans = bfs(1000)
print(ans)

# 1496438704903
",text_b
3863,"This problem cannot be solved using Python as it requires a deep understanding of number theory and combinatorics, which are beyond the scope of Python's capabilities. The solution involves calculating the number of ways to arrange the integers in a palindrome sequence and then rotating the sequence an arbitrary number of times. This requires the use of mathematical formulas and algorithms that cannot be implemented in Python.","N, K = map(int, input().split())
S = []; T = []
for x in range(1, int(N**.5)+1):
    if N % x == 0:
        S.append(x)
        if x*x < N:
            T.append(N//x)
T.reverse()
S += T
M = len(S)
U = []

MOD = 10**9 + 7
ans = 0
v = 0
for i in range(M):
    x = S[i]
    v = pow(K, (x+1)//2, MOD)
    for j in range(i):
        y = S[j]
        if x % y == 0:
            v -= U[j]
    U.append(v % MOD)
    ans = (ans + (v * x if x & 1 else v * (x//2))) % MOD
print(ans)",text_b
3864,"MOD = 998244353
n = int(input())
inv = [0, 1]
for i in range(2, n+2):
    inv.append((MOD - MOD//i)*inv[MOD%i]%MOD)
s = [0, 0]
t = [0, 1]
for i in range(2, n+2):
    s.append((s[-1]+t[-1]*2)%MOD)
    t.append((t[-1]+s[-2]*2)%MOD)
x = [0, 1]
y = [0, 1]
for i in range(2, n+2):
    x.append((x[-1]+y[-1]*inv[i])%MOD)
    y.append((y[-1]+x[-2]*inv[i])%MOD)
for i in range(1, n+1):
    print((500000004*(s[n+1-i]+s[i]-1)+x[n+1-i]*t[i-1]+y[i]*s[n+1-i])%MOD)
","N=int(input())
mod=998244353
inv4=249561088
A=[inv4,0,3]
for i in range(N):
    A.append(9*A[-1]-24*A[-2]+16*A[-3])
    A[-1]%=mod
A[0]-=inv4
B=[0 for i in range(N)]
for i in range(N):
    x=i
    y=N-i-1
    if x<=y:
        B[x]=A[i]
        B[y]=A[i]

P=N*pow(2,N-2+mod-1,mod)
for i in range(N):
    B[i]+=P
    B[i]%=mod
Q=pow(2,N-1,mod)
Qinv=pow(Q,mod-2,mod)
for i in range(N):
    B[i]*=Qinv
    B[i]%=mod
for i in range(N):
    print((B[i]))
",text_b
3865,"a = int(input().strip())
if a % 3 == 0:
    print(-1)
else:
    print('1' * a)
","#!/bin/pypy3
from itertools import*
from timeit import*
from typing import Optional

S=lambda x:sum(map(int,str(x)))

def ceil_s_divisible_a(x:int,a:int) -> Optional[int]:
	z=S(x)%a
	if z:
		z=a-z
		tail=[]
		x=list(str(x))
		while x:
			digit=x.pop()
			diff=min(z,9-int(digit))
			z-=diff
			tail.append(str(int(digit)+diff))
			if z==0:break
		else:
			return ceil_s_divisible_a(10**len(tail),a)
		x=''.join(x) + ''.join(reversed(tail))

	assert S(x)%a==0
	x=int(x)
	return x

def smooth25(a):
	a=int(bin(a).rstrip('0'),2)
	while a%5==0: a//=5
	return a==1

def solve(a):
	for first in range(1,60): # 120
		q=str((first*10**3000+a-1) // a) # 5000
		for s1 in range(1,200):
			i=1
			s2=int(q[0])
			while i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1
			for len1 in range(i,min(i+10,len(q))):
				small=int(q[:len1])
				for z in range(4): # 10
					small=ceil_s_divisible_a(small,a)
					if S(small*a)*a==S(small):
						return small
					small+=1

	return None

def powform(x:int)->str:
	s=str(x)
	try:
		i=s.find('00000')
		return f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'
	except IndexError:
		return str(x)

if 0:
	#for a in (a for a in range(2,1000)):
	for a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:
	#for a in [32]:

		def work():
			nonlocal x
			x=solve(a)

		t=timeit(work,number=1)
		if t>0.5 or x==None:
			if x!=None:
				print(a,t,'>>',powform(a*x))
			else:
				print(a,t,'>> ?????')

	#print(solve(int(input())))


special='''
660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340
803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614
912 0.5136937369998122 >> 3 * 10 ** 1825 + 240
918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104
582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116
612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348
495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305
927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003
636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004
531 0.5475810970001476 >> 2 * 10 ** 2140 + 439
64 0.5633312410000144 >> ?????
200 0.5639609099998779 >> ?????
100 0.565854023000611 >> ?????
125 0.5663040710005589 >> ?????
160 0.5668467480008985 >> ?????
800 0.5676178080002501 >> ?????
128 0.5676772269998764 >> ?????
80 0.5682811480000964 >> ?????
256 0.5685735130000467 >> ?????
250 0.5691464900000938 >> ?????
512 0.569266141999833 >> ?????
32 0.5692826909998985 >> ?????
50 0.5692834940000466 >> ?????
25 0.5696684799995637 >> ?????
400 0.5703751219998594 >> ?????
20 0.5706145570002263 >> ?????
500 0.5742691679997733 >> ?????
640 0.5749700739997934 >> ?????
40 0.5768258159996549 >> ?????
625 0.5775357299999087 >> ?????
16 0.5789494729997386 >> ?????
833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404
792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008
320 0.6031684260005932 >> ?????
10 0.6464516910000384 >> ?????
546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454
5 0.6617960960002165 >> ?????
907 0.664109037000344 >> 3 * 10 ** 2538 + 2223
923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141
723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185
825 0.701172955000402 >> 4 * 10 ** 2476 + 123350
906 0.7062042559991824 >> 4 * 10 ** 1998 + 104
905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540
911 0.711649564000254 >> 2 * 10 ** 2612 + 2044
934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112
765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725
981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022
333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934
663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634
444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956
720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280
867 0.9858260920000248 >> 5 * 10 ** 1739 + 121
914 1.0558696210000562 >> 3 * 10 ** 1831 + 222
606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318
948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020
1000 1.2245053040005587 >> ?????
741 1.2366985769995154 >> 5 * 10 ** 2669 + 175
819 1.292531102999419 >> 8 * 10 ** 2949 + 31312
867 1.293641017000482 >> 5 * 10 ** 1739 + 121
961 1.431375496000328 >> 4 * 10 ** 1935 + 1112
913 2.0632996949998414 >> 5 * 10 ** 2323 + 16
861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114
992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504
936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112
996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300
951 2.380345242999283 >> 11 * 10 ** 1820 + 412
969 2.471255187000679 >> 11 * 10 ** 1942 + 241
828 2.504634874999283 >> 11 * 10 ** 1595 + 11212
693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014
840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120
983 2.618962229999852 >> 11 * 10 ** 1968 + 5011
963 2.641272683999887 >> 11 * 10 ** 2026 + 133
972 2.741184581000198 >> 12 * 10 ** 2130 + 312
555 2.787974407000547 >> 11 * 10 ** 2497 + 444445
873 2.8377116049996403 >> 11 * 10 ** 1774 + 133
903 2.898315477000324 >> 13 * 10 ** 1726 + 32
804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500
864 3.032601443999738 >> 13 * 10 ** 2747 + 34016
759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441
871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405
902 4.413119433999782 >> 12 * 10 ** 1506 + 1110
997 4.446912733999852 >> 11 * 10 ** 1999 + 7
993 5.025415283999791 >> 23 * 10 ** 2130 + 31
837 5.286188959000356 >> 25 * 10 ** 2722 + 11063
786 5.390603378999913 >> 21 * 10 ** 1572 + 4002
801 5.4837765329994 >> 22 * 10 ** 1645 + 212
882 6.045185064999714 >> 22 * 10 ** 1822 + 1130
990 6.413724044000446 >> 39 * 10 ** 2970 + 302010
666 6.967028857000514 >> 33 * 10 ** 2997 + 32934
941 6.982767053000316 >> 21 * 10 ** 1885 + 312
924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152
858 8.089877333000004 >> 41 * 10 ** 2573 + 12201142
939 8.241953895999359 >> 33 * 10 ** 1879 + 20001
813 3.1825667919993066 >> 3 * 10 ** 4065 + 7314
921 1.9310127280004963 >> 1 * 10 ** 3762 + 18008
831 1.683305384999585 >> 1 * 10 ** 3702 + 1646
846 1.4100486610004737 >> 1 * 10 ** 3419 + 44234
888 6.891388972000641 >> 3 * 10 ** 3998 + 27672
909 11.340291348999926 >> 7 * 10 ** 4673 + 17201
957 1.3982879649993265 >> 1 * 10 ** 4347 + 28403
933 0.9980270719997861 >> 1 * 10 ** 3746 + 233234
891 0.8806926099996417 >> 1 * 10 ** 3957 + 1079
783 0.6478317080000124 >> 1 * 10 ** 3162 + 22814
999 102.2252583720001 >> 89 * 10 ** 4760 + 20071
777 37.847382832999756 >> 24 * 10 ** 4661 + 474123
855 0.934857464999368 >> 1 * 10 ** 3420 + 21545
942 1.0410122209996189 >> 1 * 10 ** 4198 + 310058
807 0.7532789589995446 >> 1 * 10 ** 3234 + 1307123
'''

a=int(input())
for line in special.splitlines():
	if line:
		expr,out=line.split('>>')
		expr=expr.split()[0]
		if int(expr)==a:
			print(-1 if out.strip()=='?????' else eval(out)//a)
			break
else:
	print(solve(a))
",text_b
3866,"n = int(input())
if n % 2 == 0:
    print(-1)
else:
    a = [i for i in range(n)]
    b = a.copy()
    c = [(2 * i) % n for i in range(n)]
    print(*a)
    print(*b)
    print(*c)
","n = int(input())
if n % 2 == 0:
  print(-1)
else:
  print(*range(n))
  print(*range(n))
  print(*map(lambda x: x * 2 % n, range(n)))",text_b
3867,"from collections import deque
from sys import stdin, stdout

def bfs(n, graph, bfs_order):
    visited = [0] * (n + 1)
    queue = deque([1])
    visited[1] = 1
    bfs_index = 1

    while queue:
        node = queue.popleft()
        unvisited = [child for child in graph[node] if not visited[child]]
        expected = bfs_order[bfs_index:bfs_index + len(unvisited)]
        if set(unvisited) != set(expected):
            return False
        bfs_index += len(unvisited)
        queue.extend(expected)
        for child in expected:
            visited[child] = 1
    return True

n = int(stdin.readline())
graph = [set() for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, stdin.readline().split())
    graph[u].add(v)
    graph[v].add(u)
bfs_order = list(map(int, stdin.readline().split()))
stdout.write(""Yes\n"" if bfs(n, graph, bfs_order) else ""No\n"")
","n = int(input())
graph = [set() for tr in range(n+2)]
i = 1
while i < n:
	x, y = list(map(int, input().split()))
	graph[x].add(y)
	graph[y].add(x)
	i += 1
a = iter(map(int, input().split()))
try:
	assert next(a) == 1
	q = [1]
	for v in q:
		gv = graph[v]
		gv1 = tuple(gv)
		for tr2 in gv1:
			u = next(a)
			assert u in gv
			gv.remove(u)
			graph[u].remove(v)
			q.append(u)
	print(""Yes"")
except AssertionError:
	print(""No"")
",text_b
3868,"import sys
from heapq import *
n, m, k = map(int, sys.stdin.readline().split())
flights = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]
flights.sort()
arrive = [10**9]*n
depart = [10**9]*n
arrive_time = [0]*n
depart_time = [10**6]*n
arrive_sum = [0]
depart_sum = [0]
for d, f, t, c in flights:
    if t == 0:
        if c < arrive[f-1]:
            arrive_sum.append(arrive_sum[-1]-arrive[f-1]+c)
            arrive[f-1] = c
            arrive_time[f-1] = d
    else:
        if c < depart[t-1] and d > depart_time[t-1]:
            depart_sum.append(depart_sum[-1]-depart[t-1]+c)
            depart[t-1] = c
            depart_time[t-1] = d
arrive_sum = arrive_sum[1:]
depart_sum = depart_sum[1:]
depart_sum.reverse()
depart_time.reverse()
i = 0
j = 0
while i < len(arrive_sum) and j < len(depart_sum):
    if arrive_time[i]+k <= depart_time[j]:
        i += 1
        j += 1
    else:
        j += 1
if i == len(arrive_sum):
    print(-1)
else:
    print(min(arrive_sum[i:])+min(depart_sum[:j])*n)
","N,M,K = map(int,input().split())

INF = 10**6+1
from collections import defaultdict

incoming = defaultdict(list)
outgoing = defaultdict(list)

for _ in range(M):
  d,f,t,c = map(int,input().split())
  if t == 0:
    incoming[d].append((c,f-1))
  if f == 0:
    outgoing[d].append((c,t-1))

incoming_dates = sorted(incoming.keys())
outgoing_dates = sorted(outgoing.keys(),reverse=True)



Li = []
mark = [False]*N
cnt = 0
costs = [0]*N
total_cost = 0

for d in incoming_dates:
  for c,x in incoming[d]:
    if mark[x]:
      if costs[x] > c:
        total_cost += c-costs[x]
        costs[x] = c
    else:
      mark[x] = True
      cnt += 1
      costs[x] = c
      total_cost += c

  if cnt == N:
    Li.append((d,total_cost))


Lo = []
mark = [False]*N
cnt = 0
costs = [0]*N
total_cost = 0

for d in outgoing_dates:
  for c,x in outgoing[d]:
    if mark[x]:
      if costs[x] > c:
        total_cost += c-costs[x]
        costs[x] = c
    else:
      mark[x] = True
      cnt += 1
      costs[x] = c
      total_cost += c

  if cnt == N:
    Lo.append((d,total_cost))

Lo.reverse()


if not Li or not Lo:
  print(-1)
  return


# print(Li,Lo)

from bisect import bisect

best = float('inf')

for d,c in Li:
  i = bisect(Lo,(d+K+1,0))
  if i >= len(Lo):
    break
  else:
    best = min(best,c+Lo[i][1])

if best == float('inf'):
  print(-1)
else:
  print(best)",text_b
3869,"import math

def solve(w, h, a):
    if w < h:
        w, h = h, w
    if a > 90:
        a = 180 - a
    a = math.radians(a)
    if a >= math.atan(h / w):
        return h * h / math.sin(a)
    else:
        return w * h - (math.pow(w, 2) + math.pow(h, 2) - math.pow(w * h * math.sin(a), 2) / 4) / 2

w, h, a = map(int, input().split())
print(""{0:.15f}"".format(solve(w, h, a)))
","from math import sin, cos, tan, atan, pi


def main():
    w, h, a = map(int, input().split())
    a = min(a, 180 - a) * pi / 180
    if h > w:
        h, w = w, h
    if h * (1 + cos(a)) < w * sin(a):
        res = h * h / sin(a)
    else:
        res = h * w - ((w - h * tan(a / 2)) ** 2 * tan(a) + (h - w * tan(a / 2)) ** 2 * tan(a)) / 4
    print('{:.9f}'.format(res))


def __starting_point():
    main()
__starting_point()",text_b
3870,"def solve():
    n, m = map(int, input().split())
    a = []
    b = []
    for _ in range(n):
        s, x = input().split()
        x = int(x)
        if s == ""ATK"":
            a.append(x)
        else:
            b.append(x)
    a.sort()
    b.sort()
    c = list(map(int, input().split()))
    c.sort()
    ans = 0
    while a and c and c[-1] >= a[0]:
        ans += c[-1] - a[0]
        a.pop(0)
        c.pop()
    while b and c and c[-1] > b[-1]:
        b.pop()
        c.pop()
    if b:
        print(ans)
    else:
        ans += sum(c)
        print(ans)


solve()
","n, m = map(int, input().split())
u = [[], []]

for q in range(n):
    p, s = input().split()
    u[p == 'ATK'].append(int(s))

d, a = [sorted(q) for q in u]
v = sorted(int(input()) for q in range(m))
k, s = 0, sum(v)

i = j = 0
for q in v:
    if i < len(d) and q > d[i]:
        s -= q
        i += 1
    elif j < len(a) and q >= a[j]:
        s -= a[j]
        j += 1
if i + j - len(a) - len(d): s = 0
for q in v:
    if k < len(a) and q >= a[k]: k += 1

x = y = 0
v.reverse()
for i in range(k):
    x += a[i]
    y += v[i]
    s = max(s, y - x)
print(s)",text_b
3871,"import sys
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    l = list(map(int, input().split()))
    s = list(map(int, input().split()))
    c = list(map(int, input().split()))
    l = [(l[i], s[i]) for i in range(n)]
    l.sort(reverse=True)
    dp = [[-sys.maxsize] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    for i in range(n):
        for j in range(i + 1):
            dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + c[l[i][0]] - l[i][1])
            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])
        for j in range(i + 2, 0, -1):
            dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i + 1][j] + c[l[i][0] + 1])
    print(max(dp[n]))

solve()
","import sys
input = sys.stdin.readline

n,m=list(map(int,input().split()))
A=list(map(int,input().split()))
C=list(map(int,input().split()))
P=list(map(int,input().split()))

DP=[[-1<<30]*(n+1) for i in range(5001)]
# DP[k][cnt] = Aのmaxがkで, そういう人間がcnt人いるときのprofitの最大値

for i in range(5001):
    DP[i][0]=0

for i in range(n-1,-1,-1):
    a,c = A[i]-1,C[i]

    for j in range(n,-1,-1):
        if DP[a][j]==-1<<30:
            continue
        
        if DP[a][j] - c + P[a] > DP[a][j+1]:
            DP[a][j+1] = DP[a][j] - c + P[a]

            x, w=a, j+1
            while x+1<n+m:
                if DP[x+1][w//2] < DP[x][w] + w//2 * P[x+1]:
                    DP[x+1][w//2] = DP[x][w] + w//2 * P[x+1]

                    x,w=x+1,w//2
                else:
                    break

ANS=0
for i in range(5001):
    ANS=max(ANS,DP[i][0],DP[i][1])

print(ANS)


                    
                

        

    



    

",text_b
3872,"def solve(s):
    if len(s) % 2:
        return s
    else:
        s1 = solve(s[:len(s)//2])
        s2 = solve(s[len(s)//2:])
        if s1 < s2:
            return s1 + s2
        else:
            return s2 + s1

s1 = input().strip()
s2 = input().strip()

if solve(s1) == solve(s2):
    print(""YES"")
else:
    print(""NO"")
","def main():
    a = list(input())
    b = list(input())

    n = len(a)
    k = n
    while k % 2 == 0:
        k = k // 2

    while k != n:
        pairs = n // (k * 2)
        for i in range(0, pairs * 2, 2):
            if a[k * i:k * (i + 1)] > a[k * (i + 1):k * (i + 2)]:
                a[k * i:k * (i + 1)], a[k * (i + 1):k * (i + 2)] = a[k * (i + 1):k * (i + 2)], a[k * i:k * (i + 1)]
            if b[k * i:k * (i + 1)] > b[k * (i + 1):k * (i + 2)]:
                b[k * i:k * (i + 1)], b[k * (i + 1):k * (i + 2)] = b[k * (i + 1):k * (i + 2)], b[k * i:k * (i + 1)]
        k *= 2

    if a == b:
        print('YES')
    else:
        print('NO')


main()
",text_b
3873,"n = int(input().strip())
if n % 4 > 1:
    print(""NO"")
else:
    print(""YES"")
    for i in range(1, n + 1, 4):
        for j in range(i + 1, min(n + 1, i + 4)):
            for k in range(i, j):
                print(k, j)
    for i in range(2, n + 1, 4):
        for j in range(i + 1, min(n + 1, i + 4)):
            for k in range(i, j):
                print(k, j)
","n = int(input())
p = lambda a,b: print(a+1,b+1)
if n % 4 > 1:
	print(""NO"")
else:
	print(""YES"")
	for i in range(n%4,n,4):
		for x in range(2):
			for j in range(i): p(j,i+2*x)
			p(i+2*x,i+2*x+1)
			for j in range(i,0,-1): p(j-1,i+2*x+1)
		p(i,i+3)
		p(i+1,i+2)
		p(i,i+2)
		p(i+1,i+3)
",text_b
3874,"n, m = map(int, input().split())
files = [input() for _ in range(n)]
to_delete = list(map(int, input().split()))
to_delete = [files[i-1] for i in to_delete]
pattern = list(to_delete[0])
for file in to_delete[1:]:
    if len(file) != len(pattern):
        print('No')
        exit(0)
    for i in range(len(file)):
        if file[i] != pattern[i]:
            pattern[i] = '?'
for file in files:
    if file not in to_delete:
        if len(file) == len(pattern) and all(file[i] == pattern[i] or pattern[i] == '?' for i in range(len(file))):
            print('No')
            exit(0)
print('Yes')
print(''.join(pattern))
","m,n=list(map(int,input().split()))
s=[input().strip() for i in range(m)]
a=list([int(x)-1 for x in input().split()])
stmpl=s[a[0]]
f=1
def peres(s1,s2):
	return ''.join([i if i==j else '?' for i,j in zip(s1,s2)])
for i in a:
	if len(stmpl)!=len(s[i]):
		f=0
		break
	stmpl=peres(stmpl,s[i])
for i,e in enumerate(s):
	if i in a:
		continue
	if len(stmpl)==len(e) and stmpl==peres(stmpl,e):
		f=0
		break
if f:
	print('Yes')
	print(stmpl)
else:
	print('No')
",text_b
3875,"MOD = 10**9+7
N = int(input())
A = list(map(int, input().split()))
A.sort()
dp = [0]*(N+1)
dp[0] = 1
for a in A:
    ndp = dp[:]
    for i in range(N):
        if a >= i+1:
            ndp[i+1] += dp[i]
            ndp[i+1] %= MOD
    dp = ndp
print(sum(dp[i]*i%MOD for i in range(N+1))%MOD)
","from itertools import permutations
from bisect import bisect_left
inf = 10 ** 18
mod = 10 ** 9 + 7


def nCr(n, r, mod=10**9+7):
    if r < 0 or r > n:
        return 0
    res = 1
    div = 1
    r = min(r, n - r)
    for i in range(r):
        res = res * (n - i) % mod
        div = div * (i + 1) % mod
    return res * pow(div, mod-2, mod) % mod


def calc_lis(A):
    L = [A[0]]
    for a in A[1:]:
        if a > L[-1]:
            L.append(a)
        else:
            L[bisect_left(L, a)] = a
    return len(L)


def enum(N, A):
    diff = [A[0]] + [r - l for l, r in zip(A[:-1], A[1:])]
    dp = [[0] * (N + 1) for _ in range(N + 1)]
    dp[0][0] = 1
    for i in range(1, N + 1):
        for j in range(i, N + 1):
            for k in range(i - 1, j + 1):
                dp[i][j] += dp[i - 1][k] * nCr(diff[i - 1], j - k)
                dp[i][j] %= mod
    return dp[N][N]


def main():
    N = int(input())
    A = list(map(int, input().split()))

    pair = [(0,)]
    for _ in range(1, N):
        nxt = []
        for p in pair:
            v = p[-1]
            nxt.append(p + (v,))
            nxt.append(p + (v+1,))
        pair = nxt

    ans = 0
    for p in pair:
        sz = p[-1] + 1
        for order in set(permutations(p)):
            arr = [inf] * sz
            for i, a in zip(order, A):
                arr[i] = min(arr[i], a)
            for i in reversed(range(sz - 1)):
                arr[i] = min(arr[i], arr[i + 1])
            ans += enum(sz, arr) * calc_lis(order)
            ans %= mod
    for a in A:
        ans *= pow(a, mod - 2, mod)
        ans %= mod
    print(ans)


main()",text_b
3876,"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)
mod = 10**9+7

N = int(input())
G = [[] for _ in range(N+1)]
for _ in range(N-1):
    a, b = map(int, input().split())
    G[a].append(b)
    G[b].append(a)

size = [0]*(N+1)
dp = [[0]*(N+1) for _ in range(N+1)]
dp[0][0] = 1
for i in range(N):
    dp[i+1][0] = 1
    for j in range(i+1):
        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod
        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j+1]) % mod

def dfs(v, p=-1):
    size[v] = 1
    tmp = [0]*(N+1)
    tmp[0] = 1
    for u in G[v]:
        if u == p:
            continue
        dfs(u, v)
        for i in range(size[v], -1, -1):
            for j in range(size[u]+1):
                tmp[i+j] = (tmp[i+j] + dp[size[u]][j]*tmp[i]) % mod
        size[v] += size[u]
    for i in range(size[v]+1):
        dp[v][i] = tmp[i]

dfs(1)
ans = 0
for i in range(N+1):
    if i % 2 == 1:
        continue
    ans = (ans + dp[1][i]) % mod
print((pow(2, N, mod) - ans + mod) % mod)
","import sys

sys.setrecursionlimit(5001)
MOD = 10 ** 9 + 7

n = int(input())
links = [set() for _ in range(n)]
for line in sys.stdin.readlines():
    x, y = list(map(int, line.split()))
    x -= 1
    y -= 1
    links[x].add(y)
    links[y].add(x)

double_factorial_odd = [0] * (n // 2)
prev = 1
for i in range(n // 2):
    prev = double_factorial_odd[i] = (2 * i + 1) * prev % MOD


def dfs(v, p):
    ret = [0, 1]
    for u in links[v]:
        if u == p:
            continue
        res = dfs(u, v)
        lt, ls = len(ret), len(res)
        mrg = [0] * (lt + ls - 1)
        for i in range(1 - lt % 2, lt, 2):
            c = ret[i]
            for j in range(1 - ls % 2, ls, 2):
                mrg[i + j] = (mrg[i + j] + c * res[j]) % MOD
        ret = mrg

    if len(ret) % 2 == 1:
        ret[0] = -sum(pattern * df % MOD for pattern, df in zip(ret[2::2], double_factorial_odd)) % MOD

    return ret


print((MOD - dfs(0, -1)[0]))
",text_b
3877,"def solve(n, l, r):
    def count_ones(n, l, r):
        if n == 0 or r <= 0 or l > n:
            return 0
        m = (n + 1) // 2
        if r <= m:
            return count_ones(m, l, r)
        elif l > m:
            return count_ones(m, l - m, r - m)
        else:
            return count_ones(m, l, m) + count_ones(m, 1, r - m)
    return count_ones(2 ** n.bit_length(), l, r)

n, l, r = map(int, input().split())
print(solve(n, l, r))
","
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

n,l,r=list(map(int,input().split()))

a1=0

layers=1
while layers*2<=n: layers*=2

# abacaba pattern
for i in range(l,r+1):
    layer=layers
    while i%2==0:
        layer//=2
        i//=2
    if (n//layer)%2==1:
        a1+=1
    #print(i,n&layer)

print(a1)
",text_b
3878,"import sys
from itertools import combinations

def solve():
    n, m = map(int, input().split())
    if m == n * (n - 1) // 2:
        print(0)
        return
    g = [0] * n
    for _ in range(m):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        g[u] |= 1 << v
        g[v] |= 1 << u
    for i in range(n):
        g[i] |= 1 << i
    dp = [float('inf')] * (1 << n)
    dp[0] = 0
    for mask in range(1 << n):
        for submask in range(mask):
            if submask & mask == submask and dp[mask] > dp[mask ^ submask] + 1:
                dp[mask] = dp[mask ^ submask] + 1
    print(dp[(1 << n) - 1])
    mask = (1 << n) - 1
    while mask:
        for submask in range(mask):
            if submask & mask == submask and dp[mask] == dp[mask ^ submask] + 1:
                print(bin(mask ^ submask).count('1'), end=' ')
                mask ^= submask
                break
    print()

solve()
","from collections import defaultdict
def count(x):
    c=0
    while x > 0:
        c+=1
        x &= (x-1)
    return c

n,m=list(map(int,input().split()))
g=defaultdict(list)
for _ in range(m):
    u, v = list(map(int,input().split()))
    u-=1;v-=1
    g[u].append(v)
    g[v].append(u)

mask1=0;mask2=0;MAX=(1<<n)-1
a=[0]*(1 << n)
dp=[MAX]*(1 << n)
if m == (n*(n-1))//2:
    print(0)
    return
for i,j in list(g.items()):
    mask1  = (1 << i);mask2=0;mask2 |= mask1
    for k in j:
        mask2 |= (1 << k)
        
    dp[mask2]=mask1
    a[mask1]=mask2
    
for i in range(0,(1 << n)-1):
    if dp[i] != MAX:
        #print('HEllo')
        temp = dp[i] ^ i 
        for j in range(n):
            if temp & (1 << j) != 0:
                nmask = i | a[(1 << j)]
                dp[nmask]=dp[i] | (1 << j) if count(dp[i] | (1 << j)) < count(dp[nmask]) else dp[nmask]
                
ans = []
for i in range(n):
    if dp[-1] & (1 << i) != 0:
        ans.append(i+1)
print(len(ans))
print(*ans)
",text_b
3879,"n = int(input())
a = list(map(int, input().split()))
for i in range(n):
    while a[i] % 2 == 0:
        a[i] //= 2
    while a[i] % 3 == 0:
        a[i] //= 3
if len(set(a)) == 1:
    print(""Yes"")
else:
    print(""No"")
","def i23(x):
    while x%2==0:
        x//=2
    while x%3==0:
        x//=3
    return x == 1
import fractions
from fractions import gcd
x = int(input())
y = list(map(int, input().split(' ')))

gcdx = y[0]
for i in y:
    gcdx = gcd(i, gcdx)

for i in y:
    if not i23(i/gcdx):
        print(""No"")
        quit()
print(""Yes"")
",text_b
3880,"n = int(input())
a = list(map(int, input().split()))
a.sort()
if n % 2 == 1 or a.count(0) > 0:
    print(sum(map(abs, a)))
else:
    print(sum(map(abs, a)) - 2 * min(map(abs, a)))
","n = int(input())
a = list(map(int, input().split()))

abs_a = [abs(v) for v in a]
neg = sum(v < 0 for v in a)
if n % 2 == 1 or neg % 2 == 0 or any(v == 0 for v in a):
    print(sum(abs_a))
else:
    print(sum(abs_a) - 2 * min(abs_a))
",text_b
3881,"def solve(n, q, a, b):
    dp = [[0]*6 for _ in range(n+1)]
    dp[1][0] = 1
    for i in range(2, n+1):
        for j in range(6):
            for k in range(q):
                if b[k] == chr(ord('a')+j):
                    dp[i][j] += dp[i-1][ord(a[k][0])-ord('a')] * dp[i-1][ord(a[k][1])-ord('a')]
    return dp[n][0]

n, q = map(int, input().split())
a = []
b = []
for _ in range(q):
    ai, bi = input().split()
    a.append(ai)
    b.append(bi)
print(solve(n, q, a, b))
","n, q = list(map(int, input().split()))
go = dict()
for i in range(q):
    fr, to = input().split()
    go[fr] = to

ans = 0

for i in range(6 ** n):
    cur = i
    s = ''
    for j in range(n):
        s += chr(ord('a') + (cur % 6))
        cur //= 6

    while len(s) > 1:
        fr = s[:2]
        if fr not in go:
            break
        s = go[fr] + s[2:]

    if s == 'a':
        ans += 1

print(ans)
",text_b
3882,"MOD = 10**9 + 7
n = int(input().strip())
C = [[0 for _ in range(n+1)] for _ in range(n+1)]
C[0][0] = 1
for i in range(1, n+1):
    C[i][0] = 1
    for j in range(1, i+1):
        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD
dp = [0 for _ in range(n+1)]
dp[0] = dp[1] = 1
for i in range(2, n+1):
    dp[i] = pow(2, pow(2, i-1, MOD-1), MOD)
    for j in range(1, i):
        dp[i] -= C[i][j] * dp[j] % MOD
        dp[i] %= MOD
print(dp[n])
","from math import factorial
cat = [1, 1]
p = 10**9 + 7
n = int(input())
ans = 0
fac = [1]
mat = [[0 for i in range(n + 1)] for j in range(n + 1)]


mat[0][0] = 1
for i in range(1, n + 1):
    mat[i][0] = mat[i - 1][i - 1]
    for j in range(i):
        mat[i][j + 1] = (mat[i][j] + mat[i - 1][j]) % p

print(mat[n][n - 1] % p)
",text_b
3883,"a, b = map(int, input().split())
if a < b:
    print(-1)
elif a == b:
    print(a)
else:
    k = a // (2 * b)
    if a % (2 * b) <= b:
        print(a / (2 * k))
    else:
        print(a / (2 * k + 1))
","n,m=map(int,input().split())
if m>n:print(-1)
else:
	q=int((1.+n/m)/2.)
	v=(m+n)/(2*q)
	print(v)",text_b
3884,"n = int(input())
m = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
a = a[::-1] + a
b = b[::-1] + b
f = [0] * (2 * n + 1)
f[0] = m
for i in range(1, 2 * n + 1):
    f[i] = (f[i - 1] + a[i - 1] - 1) / a[i - 1]
    if i != 2 * n:
        f[i] = (f[i] + b[i] - 1) / b[i]
if f[n] < m:
    print(-1)
else:
    print(f[2 * n] - m)
","#      
import collections, atexit, math, sys
from functools import cmp_to_key
#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

import bisect 
try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass


def memo(func):  
    cache={}  
    def wrap(*args):  
        if args not in cache:  
            cache[args]=func(*args)  
        return cache[args]  
    return wrap

@memo
def comb (n,k):
    if k==0: return 1
    if n==k: return 1
    return comb(n-1,k-1) + comb(n-1,k)

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
M, = getIntList()
za = getIntList()
zb = getIntList()

if 1 in za or 1 in zb:
    print(-1)
    return
    

def trywork(fuel):
    for i in range(N):
        now = fuel + M
        cost = now / za[i]
        fuel-=cost
        if fuel <0: return False
        now = fuel +M
        cost = now / zb[ (i+1)%N]
        fuel-=cost
        if fuel<0: return False
    return True

r0 = 0
r1 = 10**9+1


while r1-r0 > 1e-7 and (r1-r0) *10000000 >r1:
    m = (r1+r0)/2
    f = trywork(m)
    if f:
        r1 = m
    else:
        r0 = m

print(r1)
    









",text_b
3885,"n = int(input())
print(n // 2)
","n = int(input())
print((n-1) // 2)",text_b
3886,"import sys
input = sys.stdin.readline
q = int(input())
queries = [list(map(int, input().split())) for _ in range(q)]
s = ""What are you doing at the end of the world? Are you busy? Will you save us?""
a, b, c = ""What are you doing while sending '"", ""'? Are you busy? Will you send '"", ""'?""
f = [len(s)]
for i in range(1, 55):
    f.append(f[-1]*2 + len(a) + len(b) + len(c))
def solve(n, k):
    if n == 0 or k <= len(a):
        return a[k-1] if n == 0 or k <= len(a) else b[k-len(a)-1]
    if k <= len(a) + f[n-1]:
        return solve(n-1, k-len(a))
    if k <= len(a) + f[n-1] + len(b):
        return b[k-len(a)-f[n-1]-1]
    if k <= len(a) + f[n-1]*2 + len(b):
        return solve(n-1, k-len(a)-f[n-1]-len(b))
    if k <= len(a) + f[n-1]*2 + len(b) + len(c):
        return c[k-len(a)-f[n-1]*2-len(b)-1]
    return '.'
for n, k in queries:
    sys.stdout.write(solve(n, k) if n < 55 and k <= f[n] else '.')
","f0 = 'What are you doing at the end of the world? Are you busy? Will you save us?'
ft1, ft2, ft3 = 'What are you doing while sending ""', '""? Are you busy? Will you send ""', '""?'

flen = [2 * 10 ** 18] * (10 ** 5 + 1)
flen[0] = len(f0)
for i in range(1, 56):
    flen[i] = len(ft1) + len(ft2) + len(ft3) + 2 * flen[i-1]

def ans(n, k):
    while True:
        if n == 0:
            return f0[k]
        if k < len(ft1):
            return ft1[k]
        k -= len(ft1)
        if k < flen[n-1]:
            n -= 1
            continue
        k -= flen[n-1]
        if k < len(ft2):
            return ft2[k]
        k -= len(ft2)
        if k < flen[n-1]:
            n -= 1
            continue
        k -= flen[n-1]
        return ft3[k]

q = int(input())
a = ''
for _ in range(q):
    n, k = list(map(int, input().split()))
    k -= 1
    if k >= flen[n]:
        a += '.'
        continue
    a += ans(n, k)
print(a)
",text_b
3887,"s = input().strip().split()
n = int(s[-1])
s = s[:-2]
p = [i for i in range(len(s)) if s[i] == '+']
m = [i for i in range(len(s)) if s[i] == '-']
if len(p) + 1 - len(m) > n or len(p) + 1 < n - len(m):
    print('Impossible')
else:
    print('Possible')
    a = [1] * (len(s) + 1)
    d = n - len(p) - len(m) - 1
    for i in p + [-1]:
        while d > 0 and a[i + 1] < n:
            a[i + 1] += 1
            d -= 1
    d = n - sum(a[i + 1] for i in p) + sum(a[i + 1] for i in m)
    for i in m:
        while d > 0 and a[i + 1] < n:
            a[i + 1] += 1
            d -= 1
    for i in range(len(s)):
        print(a[i], s[i], end=' ')
    print(a[-1], '=', n)
","#!/bin/python3

a = input()
while a:
    expr, n = a.split('=')
    n = int(n.strip())
    pos = 1
    neg = 0
    sg = [1]
    for c in expr:
        if c == '+':
            pos += 1
            sg.append(1)
        elif c == '-':
            neg += 1
            sg.append(0)
    csum = pos - neg
    rez = []
    for i in sg:
        if csum < n:
            if i > 0:
                v = min(n-csum, n-1)
                csum += v
                rez.append(1+v)
            else:
                rez.append(-1)
        else:
            if i > 0:
                rez.append(1)
            else:
                v = min(csum - n, n-1)
                csum -= v
                rez.append(-1-v)
    if csum == n:
        print(""Possible"")
        ans = str(rez[0])
        for j in rez[1:]:
            ans += "" "" + (""+"" if j > 0 else ""-"") + "" ""
            ans += str(abs(j))
        ans += "" = "" + str(n)
        print(ans)
    else:
        print(""Impossible"")
    break
    a = input()
",text_b
3888,"import sys
input = sys.stdin.readline

N = int(input())
A = [list(map(int, input().split())) for _ in range(N)]
B = [A[i][0] for i in range(N)]
A = A[0]

mex = [[0]*3 for _ in range(3)]
mex[0][1] = mex[1][0] = 1
mex[0][2] = mex[2][0] = 1
mex[1][2] = mex[2][1] = 0

C = [[0]*3 for _ in range(N+1)]
D = [[0]*3 for _ in range(N+1)]
for i in range(N):
    for j in range(3):
        C[i+1][j] = C[i][j] + (A[i] == j)
        D[i+1][j] = D[i][j] + (B[i] == j)

dp = [[0]*3 for _ in range(3)]
for i in range(N):
    ndp = [[0]*3 for _ in range(3)]
    for j in range(3):
        for k in range(3):
            for l in range(3):
                for m in range(3):
                    if mex[j][k] == l and mex[l][m] == j:
                        cnt = [C[i+1][j] - C[i][l], D[i+1][j] - D[i][l], N - C[i+1][j] - D[i+1][j] + C[i][l] + D[i][l]]
                        ndp[k][m] = max(ndp[k][m], dp[j][k] + cnt[0] + cnt[1] + cnt[2])
    dp = ndp

print(N*N - max(max(dp)))
","def met(x,y):
  if x*y>0:return 0
  if (x+y)%2==0:return 1
  return 2
def main0(n,a0,a1):
  ret=[0]*3
  mat=[[0]*n for _ in range(n)]
  for i in range(1,n):
    mat[0][i]=a0[i]
    mat[i][0]=a1[i-1]
    ret[a1[i-1]]+=1
    ret[a0[i]]+=1
  mat[0][0]=a0[0]
  ret[a0[0]]+=1
  for j in range(1,n):
    for i in range(1,n):
      mat[i][j]=met(mat[i][j-1],mat[i-1][j])
      ret[mat[i][j]]+=1
  #for x in mat:print(*x)
  return ret

def main1(n,a0,a1):
  ret=[0]*3

  a1=[a0[0]]+a1
  for i in range(1,n):
    ret[a1[i]]+=1
    ret[a0[i]]+=1
  ret[a0[0]]+=1

  b0,b1=[a1[1]],[a0[1]]
  for i in range(1,n):
    b0.append(met(b0[-1],a0[i]))
    b1.append(met(b1[-1],a1[i]))
    ret[b0[-1]]+=1
    ret[b1[-1]]+=1
  ret[b0[1]]-=1

  c0=[a1[2],b1[2]]
  c1=[a0[2],b0[2]]
  for i in range(2,n):
    c0.append(met(c0[-1],b0[i]))
    c1.append(met(c1[-1],b1[i]))
    ret[c0[-1]]+=1
    ret[c1[-1]]+=1
  ret[c0[2]]-=1

  d0=[a1[3],b1[3],c1[3]]
  d1=[a0[3],b0[3],c0[3]]
  for i in range(3,n):
    d0.append(met(d0[-1],c0[i]))
    d1.append(met(d1[-1],c1[i]))
    ret[d0[-1]]+=1
    ret[d1[-1]]+=1
  ret[d0[3]]-=1

  for i in range(4,n):
    ret[d0[i]]+=n-i-1
    ret[d1[i]]+=n-i-1
  ret[d0[3]]+=n-4
  """"""
  print(*a0)
  print(*b0)
  print(*c0)
  print(*d0)
  for i in range(4,n):
    print(a1[i],b1[i],c1[i],d1[i])
  """"""
  return ret


n=int(input())
a0=list(map(int,input().split()))
a1=[int(input()) for _ in range(n-1)]
if n<10:
  ret=main0(n,a0,a1)
else:
  ret=main1(n,a0,a1)
print((*ret))
",text_b
3889,"n = int(input())
s = input()
counts = [0]*26
for i in range(n):
    counts[ord(s[i])-97] += 1
if n == 1 or max(counts) >= 2:
    print(""Yes"")
else:
    print(""No"")
","import collections

n = int(input())
s = collections.Counter(input())
print('Yes' if n == 1 or max(s.values()) > 1 else 'No')
",text_b
3890,"def main():
    n, k = map(int, input().split())
    MOD = 10**9 + 7
    ans = pow(k, k - 1, MOD) * pow(n - k, n - k, MOD) % MOD
    print(ans)

main()
","n,k=list(map(int,input().split()))
M=10**9+7
print(k**~-k*pow(n-k,n-k,M)%M)
",text_b
3891,"n, m = map(int, input().split())
table = [list(input()) for _ in range(n)]
x1 = y1 = 115
x2 = y2 = -1
for i in range(n):
    for j in range(m):
        if table[i][j] == 'B':
            x1 = min(x1, i)
            y1 = min(y1, j)
            x2 = max(x2, i)
            y2 = max(y2, j)
print((x1 + x2) // 2 + 1, (y1 + y2) // 2 + 1)
","n, m = map(int, input().split())
vert = []
gor = []
for i in range(n):
    s = input()
    for j in range(m):
        if s[j] == 'B':
            vert.append(i)
            gor.append(j)
vert.sort()
gor.sort()
print(vert[len(vert) // 2] + 1, gor[len(gor) // 2] + 1)",text_b
3892,"from sys import stdin, stdout
from collections import defaultdict
n, m = map(int, stdin.readline().split())
a = [0]*n
b = [0]*n
c = [0]*n
d = defaultdict(list)
for _ in range(m):
    x, y = map(int, stdin.readline().split())
    x -= 1
    y -= 1
    a[x] += 1
    d[x].append((y-x+n)%n)
for i in range(n):
    if d[i]:
        d[i].sort()
        b[i] = d[i][0]
        c[i] = d[i][-1]
maxi = max(a[i]*n+c[i] for i in range(n))
for i in range(n):
    if a[i]:
        stdout.write(str(max(maxi-b[i], (a[i]-1)*n+c[i]))+' ')
    else:
        stdout.write(str(maxi)+' ')
","
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline
mii=lambda:list(map(int,input().split()))

n,m=mii()
a=[[] for _ in range(n)]
c=[123456 for _ in range(n)]
for _ in range(m):
    u,v=mii()
    u%=n
    v%=n
    if v<u: v+=n
    a[u].append(v)
    if c[u]>v: c[u]=v

ans=[]
for i in list(range(1,n))+[0]:
    out=0
    for j in range(i,n):
        if not a[j]: continue
        tmp=(j-i)+(len(a[j])-1)*n+(c[j]-j)
        out=max(out,tmp)
        #print(1,i,j,tmp)
    for j in range(i):
        if not a[j]: continue
        tmp=(j+n-i)+(len(a[j])-1)*n+(c[j]-j)
        out=max(out,tmp)
        #print(2,i,j,tmp)
    ans.append(out)
print("" "".join(map(str,ans)))
",text_b
3893,"x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
n = int(input())
lines = [list(map(int, input().split())) for _ in range(n)]
home_blocks = [a*x1 + b*y1 + c > 0 for a, b, c in lines]
university_blocks = [a*x2 + b*y2 + c > 0 for a, b, c in lines]
steps = sum(h != u for h, u in zip(home_blocks, university_blocks))
print(steps)
","""""""
Codeforces Contest 284 Div 1 Problem A

Author  : chaotic_iak
Language: Python 3.4.2
""""""

################################################### SOLUTION

def main():
    x1,y1 = read()
    x2,y2 = read()
    n, = read()
    ct = 0
    for i in range(n):
        a,b,c = read()
        if (a*x1+b*y1+c)*(a*x2+b*y2+c) < 0: ct += 1
    print(ct)

#################################################### HELPERS



def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0: return inputs
    if mode == 1: return inputs.split()
    if mode == 2: return list(map(int, inputs.split()))

def write(s=""\n""):
    if s is None: s = """"
    if isinstance(s, list): s = "" "".join(map(str, s))
    s = str(s)
    print(s, end="""")

write(main())",text_b
3894,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    if k % 2 == 0:
        f = [0, 1, 0, 1, 2, 0, 2, 0]
        for i in range(8, 100005):
            if i % 2 == 0:
                f.append(1)
            else:
                f.append(0)
    else:
        f = [0, 1, 2, 0, 1, 2, 0, 1]
        for i in range(8, 100005):
            if i % 2 == 0:
                f.append(i - 2)
            else:
                f.append(0)
    xor = 0
    for i in range(n):
        if a[i] < 100005:
            xor ^= f[a[i]]
        else:
            xor ^= f[a[i] % 2]
    if xor == 0:
        print(""Nicky"")
    else:
        print(""Kevin"")

solve()
","def grundy(n, k):
    if k % 2 == 0:
        if n <= 2:
            return n
        else:
            return n % 2 == 0
    else:
        if n <= 4:
            return [0, 1, 0, 1, 2][n]
        elif n % 2 == 1:
            return 0
        else:
            return 2 if grundy(n // 2, k) == 1 else 1


def __starting_point():
    n, k = list(map(int, input().split()))
    xList = list(map(int, input().split()))
    res = 0
    for x in xList:
        res ^= grundy(x, k)
    print(""Kevin"" if res else ""Nicky"")


__starting_point()",text_b
3895,"n = int(input())
f = list(map(int, input().split()))
f = [x-1 for x in f]
g = [-1]*n
h = [-1]*n
m = 0
for i in range(n):
    if h[f[i]] == -1:
        h[f[i]] = m
        m += 1
    g[i] = h[f[i]]
for i in range(m):
    if h[i] == -1:
        print(-1)
        exit(0)
print(m)
for i in range(n):
    print(g[i]+1, end=' ')
print()
for i in range(m):
    print(h[i]+1, end=' ')
","n = int(input())
f = [int(x) - 1 for x in input().split()]
p = [-1] * n
g = [0] * n
h = [0] * n
m = 0
for i in range(n):
    if f[i] == i:
        p[i] = m
        h[m] = i + 1
        m += 1

h = h[:m]

for i in range(n):
    if p[f[i]] == -1:
        print(-1)
        return
    g[i] = p[f[i]] + 1

print(m)
print("" "".join([str(x) for x in g]))
print("" "".join([str(x) for x in h]))

",text_b
3896,"MOD = 10**9 + 7
x = input().strip()
n = len(x)
x = int(x, 2)
ans = 0
for i in range(n):
    if (x >> i) & 1:
        ans += pow(2, i+1, MOD)
        ans %= MOD
print((ans * pow(2, n-1, MOD)) % MOD)
","M = 10 ** 9 + 7
def solve1(x):
    n = len(x)
    x = int(x, 2)
    ans = 0
    for a in range(2 ** n):
        for c in range(2 ** n):
            b = a ^ x
            d = c ^ x
            if a < c and b > d:
                ans += 1
    return ans % M

def solve2(x):
    return int(x, 2) * pow(2, (len(x) - 1), M) % M

x = input()
# print(solve1(x))
print(solve2(x))


",text_b
3897,"from collections import Counter
from math import sqrt
from sys import stdin, stdout

MOD = 10**9 + 7
MAX = 10**4 + 10
fact = [1] * MAX
inv = [1] * MAX
invfact = [1] * MAX

def power(a, b):
    res = 1
    while b:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def C(n, k):
    if k > n or k < 0:
        return 0
    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD

for i in range(1, MAX):
    fact[i] = i * fact[i - 1] % MOD
    inv[i] = power(i, MOD - 2)
    invfact[i] = inv[i] * invfact[i - 1] % MOD

n = int(stdin.readline())
a = list(map(int, stdin.readline().split()))
m = 1
for x in a:
    m *= x
factors = Counter()
for i in range(2, int(sqrt(m)) + 1):
    while m % i == 0:
        factors[i] += 1
        m //= i
if m > 1:
    factors[m] += 1
res = 1
for x in factors.values():
    res = res * C(x + n - 1, n - 1) % MOD
stdout.write(str(res))
","from collections import defaultdict
m = 1000000007

f = [0] * 15001
f[0] = 1
for i in range(1, 15001): f[i] = (f[i - 1] * i) % m

def c(n, k): return (f[n] * pow((f[k] * f[n - k]) % m, m - 2, m)) % m
def prime(n):
    m = int(n ** 0.5) + 1
    t = [1] * (n + 1)
    for i in range(3, m):
        if t[i]: t[i * i :: 2 * i] = [0] * ((n - i * i) // (2 * i) + 1)
    return [2] + [i for i in range(3, n + 1, 2) if t[i]]

p = prime(31650)
s = defaultdict(int)

def g(n):
    for j in p:
        while n % j == 0:
            n //= j
            s[j] += 1
        if j * j > n:
            s[n] += 1
            break

n = int(input()) - 1
a = list(map(int, input().split()))

for i in a: g(i)
if 1 in s: s.pop(1)

d = 1
for k in list(s.values()): d = (d * c(k + n, n)) % m
print(d)
",text_b
3898,"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
a0 = a.index(0)
b0 = b.index(0)
a = a[a0:] + a[:a0]
b = b[b0:] + b[:b0]
if a == b or a == b[::-1]:
    print(""YES"")
else:
    print(""NO"")
","#!/usr/bin/env python3
n = int(input())
a = list(map(int,input().split()))
b = list(map(int,input().split()))
if n <= 3:
    print('YES')
else:
    a.remove(0)
    b.remove(0)
    i = a.index(1)
    a = a[i:] + a[:i]
    i = b.index(1)
    b = b[i:] + b[:i]
    print(['NO','YES'][a == b])
",text_b
3899,"import math
from heapq import *
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    tasks = sorted([(a[i], b[i]) for i in range(n)], reverse=True)
    l = 0
    r = 10**11
    while r - l > 1:
        mid = (l + r) // 2
        q = []
        cur = 0
        for i in range(n):
            while len(q) > 0 and cur + q[0] <= tasks[i][1]:
                cur += heappop(q)
            heappush(q, tasks[i][1] - cur)
            cur = tasks[i][1]
            if len(q) > 0 and q[0] < 0:
                cur += heappop(q)
        while len(q) > 0:
            cur += heappop(q)
        if cur * mid <= sum(a[i] * b[i] for i in range(n)):
            r = mid
        else:
            l = mid
    print(math.ceil(r * 1000))

solve()
","#     Codeforces Round #488 by NEAR (Div. 2)
import collections
from functools import cmp_to_key
#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )
import math
import sys
def getIntList():
    return list(map(int, input().split()))    

import bisect 

def makePair(z):
    return  [(z[i], z[i+1]) for i in range(0,len(z),2) ]
            
N, =  getIntList()
za = getIntList() 
zb = getIntList()
 
sa = set(za)

xa = list(sa)
xa.sort(reverse = True)

zz = [(t, sorted([zb[i]  for i in range(N) if za[i] == t]) )  for t in xa ]
#print(zz)


lastdp = [[] for i in range(52)]
lastdp[0] = [(0,0)]


def addres(z, t):
    if len(z) ==0:
        z.append(t)
        return
    i = bisect.bisect_right(z,t)
    if i>0 and z[i-1][1] >= t[1]: return
    if i<len(z) and t[1] >= z[i][1]:
        z[i] = t
        return
    z.insert(i,t)
    

for x in zz:
    nowdp  = [[] for i in range(52)]
    for i in range(len(lastdp)):
        tz = lastdp[i]
        if len( tz ) ==0 : continue
        num = len(x[1])
        hide = min(i, num )
        
        tb = sum(x[1])
        acc =0;
        
        for j in range(hide + 1):
            la = x[0] * (num-j)
            lb = tb - acc
            if j<num: acc += x[1][j]
            for t in tz:
                # t = (0,0)
                tr = (t[0] + la, t[1] + lb)
                addres(nowdp[ i -j + num -j] ,tr)
    lastdp = nowdp
    #print(lastdp)

res = 10 ** 20
for x in lastdp:
    for y in x:
        t = math.ceil(y[0] *1000   /  y[1] )
        res = min( res,t)

print(res)
",text_b
3900,"import sys
from collections import defaultdict
from bisect import bisect_right

n, p = map(int, input().split())
a = [0] * n
b = [0] * n
cnt = defaultdict(int)
cnt2 = [0] * (n + 1)
for i in range(n):
    x, y = map(int, input().split())
    if x > y:
        x, y = y, x
    a[i] = x - 1
    b[i] = y - 1
    cnt[(x - 1, y - 1)] += 1
a.sort()
b.sort()
res = 0
for x, y in cnt.keys():
    cnt2[cnt[(x, y)]] += 1
    res += bisect_right(a, y - 1) - cnt[(x, y)]
for i in range(n, 0, -1):
    cnt2[i - 1] += cnt2[i]
for x, y in cnt.keys():
    if cnt[(x, y)] < p:
        res -= cnt2[p - cnt[(x, y)]]
    if cnt[(x, y)] + bisect_right(a, x - 1) >= p and cnt[(x, y)] + bisect_right(a, y - 1) < p:
        res += 1
print(res)
","from collections import defaultdict
from bisect import bisect_left as lower
import sys
input = sys.stdin.readline
def put():
    return list(map(int, input().split()))

try:
    n,m = put()
    cnt, mp, ans = [0]*n, defaultdict(), [0]*n
    for _ in range(n):
        x,y = put()
        x,y = x-1,y-1
        key = (min(x,y), max(x,y))
        if key in mp:
            mp[key]+=1
        else:
            mp[key]=1
        cnt[x]+=1
        cnt[y]+=1

except:
    print('lol')

for (x,y),val in list(mp.items()):
    if cnt[x]+cnt[y]>= m and cnt[x]+cnt[y]-val<m:
        ans[x]-=1
        ans[y]-=1


scnt = cnt.copy()
scnt.sort()
for i in range(n):
    ans[i]+= n-lower(scnt, m-cnt[i])
    if 2*cnt[i]>=m:
        ans[i]-=1

print(sum(ans)//2)
",text_b
3901,"from math import gcd
from sys import stdin, stdout

def solve():
    n = int(stdin.readline())
    a = list(map(int, stdin.readline().split()))
    if 1 in a:
        stdout.write(str(n - a.count(1)) + '\n')
        return
    ans = float('inf')
    for i in range(n):
        g = a[i]
        for j in range(i + 1, n):
            g = gcd(g, a[j])
            if g == 1:
                ans = min(ans, j - i)
                break
    if ans == float('inf'):
        stdout.write('-1\n')
    else:
        stdout.write(str(ans + n - 1) + '\n')

solve()
","def gcd(a, b):
    while b:
        a, b = b, a%b
    return a

def gcda(a):
    ans = a[0]
    for i in range(1, len(a)):
        ans = gcd(a[i], ans)
    return ans

n = int(input())
a = list(map(int, input().split()))
if 1 in a:
    print(sum([1 for i in a if i != 1]))
    return
    
if gcda(a) != 1:
    print(-1)
    return

mr=n+1
for i in range(n):
    g = a[i]
    for j in range(i+1, n):
        g = gcd(g, a[j])
        if g == 1:
            mr = min(mr, j-i)
            break
            
print(mr + n - 1)    ",text_b
3902,"s = input()
n = len(s)
dp = [[0]*n for _ in range(4)]
dp[2][n-2] = dp[3][n-3] = 1
suffixes = set([s[n-2:], s[n-3:]])
for i in range(n-4, -1, -1):
    if s[i:i+2] != s[i+2:i+4]:
        dp[2][i] = dp[2][i+2] or dp[3][i+2]
    if s[i:i+3] != s[i+3:i+6]:
        dp[3][i] = dp[2][i+3] or dp[3][i+3]
    if dp[2][i]:
        suffixes.add(s[i:i+2])
    if dp[3][i]:
        suffixes.add(s[i:i+3])
suffixes = sorted(list(suffixes))
print(len(suffixes))
for suffix in suffixes:
    print(suffix)
","s = input()
s = s[5:]

if len(s) < 2:
    print(0)
elif len(s) == 2:
    print(1)
    print(s)
elif len(s) == 3:
    print(2)
    for suff in sorted([s, s[-2:]]):
        print(suff)
else:
    D = [[False for _ in range(2)] for _ in range(len(s))]

    suffixes = { s[-2:], s[-3:] }

    D[-2][0] = True
    D[-3][1] = True

    for i in range(len(s) - 4, -1, -1):
        if (s[i:i+2] != s[i+2:i+4] and D[i+2][0]) or D[i+2][1]:
            D[i][0] = True
            suffixes |= { s[i:i+2] }
        if (i <= len(s) - 6 and s[i:i+3] != s[i+3:i+6] and D[i+3][1]) or D[i+3][0]:
            D[i][1] = True
            suffixes |= { s[i:i+3] }

    print(len(suffixes))
    for suffix in sorted(suffixes):
        print(suffix)
",text_b
3903,"from collections import deque
from sys import stdin, stdout

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def bfs(x, y, z):
    d = [[-1]*m for _ in range(n)]
    d[x][y] = 0
    q = deque()
    q.append((x, y))
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if nx>=0 and nx<n and ny>=0 and ny<m and d[nx][ny]==-1 and s[nx][ny]!='#':
                d[nx][ny] = d[x][y] + 1
                q.append((nx, ny))
    for i in range(n):
        for j in range(m):
            if s[i][j] == '.':
                dist[z][i][j] = d[i][j]
            elif s[i][j] == '1':
                dist[z][0][0] = min(dist[z][0][0], d[i][j])
            elif s[i][j] == '2':
                dist[z][0][1] = min(dist[z][0][1], d[i][j])
            elif s[i][j] == '3':
                dist[z][0][2] = min(dist[z][0][2], d[i][j])
    return d

n, m = map(int, stdin.readline().split())
s = [list(stdin.readline().strip()) for _ in range(n)]
dist = [[[1e9]*3 for _ in range(m)] for _ in range(3)]
for i in range(n):
    for j in range(m):
        if s[i][j] == '1':
            d1 = bfs(i, j, 0)
        elif s[i][j] == '2':
            d2 = bfs(i, j, 1)
        elif s[i][j] == '3':
            d3 = bfs(i, j, 2)
res = min(dist[0][0][1] + dist[0][0][2], dist[1][0][0] + dist[1][0][2], dist[2][0][0] + dist[2][0][1])
for i in range(n):
    for j in range(m):
        if s[i][j] == '.':
            res = min(res, dist[0][i][j] + dist[1][i][j] + dist[2][i][j] - 2)
if res >= 1e9:
    stdout.write('-1\n')
else:
    stdout.write(str(res) + '\n')
","#!/usr/bin/env python3
#
# Three States
#
import sys, os
from collections import deque
from pprint import pprint

def read_ints(): return list(map(int, input().split()))
def read_str(): return input().strip()

n, m = read_ints()
s = [read_str() for _ in range(n)]

t = [set(), set(), set()]

for i in range(n):
	for j in range(m):
		if s[i][j] in '123':
			for ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
				if 0 <= ii < n and 0 <= jj < m:
					if s[ii][jj] in '123.' and s[i][j] != s[ii][jj]:
						t[int(s[i][j]) - 1].add((i, j))
						break

z = [[[1e18] * 3 for j in range(m)] for i in range(n)]
ans = 1e18
for root in range(3):
	q = deque()
	vi = [[False] * m for _ in range(n)]
	for i, j in t[root]:
		q.append((i, j, 0))
		vi[i][j] = True
		z[i][j][root] = 0
	dist = [1e18] * 3
	dist[root] = 0
	while q:
		i, j, d = q.popleft()
		for ii, jj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
			if 0 <= ii < n and 0 <= jj < m and not vi[ii][jj]:
				if s[ii][jj] == '.':
					vi[ii][jj] = True
					q.append((ii, jj, d + 1))
					z[ii][jj][root] = min(z[ii][jj][root], d + 1)
				elif s[ii][jj] != s[i][j] and s[ii][jj] in '123':
					dist[int(s[ii][jj]) - 1] = min(dist[int(s[ii][jj]) - 1], d)
	ans = min(ans, sum(dist))

if ans >= 1e18:
	print(-1)
else:
	for i in range(n):
		for j in range(m):
			if s[i][j] == '.':
				ans = min(ans, sum(z[i][j]) - 2)
	print(ans)
",text_b
3904,"n = int(input().strip())
s = input().strip()
cnt = 0
res = 0
for i in range(n):
    if s[i] == '(':
        cnt += 1
    else:
        cnt -= 1
    if cnt < 0:
        res += 1
    if cnt == 0 and s[i] == ')':
        res += 1
if cnt != 0:
    print(-1)
else:
    print(res)","__, s = input(), input()
a, n = 0, 0
pt = {'(': 1, ')': -1}
for c in s:
  da = pt.get(c, 0)
  if a < 0 or a + da < 0:
    n += 1
  a += da
if a != 0:
  print(-1)
else:
  print(n)",text_b
3905,"import sys
from collections import defaultdict

def dfs1(v):
    used[v] = True
    for to in g[v]:
        if not used[to]:
            dfs1(to)
    order.append(v)

def dfs2(v, cl):
    comp[v] = cl
    for to in gr[v]:
        if comp[to] == -1:
            dfs2(to, cl)

n, m, h = map(int, sys.stdin.readline().split())
u = list(map(int, sys.stdin.readline().split()))
g = defaultdict(list)
gr = defaultdict(list)
for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    a -= 1
    b -= 1
    if (u[a] + 1) % h == u[b]:
        g[a].append(b)
        gr[b].append(a)
    if (u[b] + 1) % h == u[a]:
        g[b].append(a)
        gr[a].append(b)
used = [False] * n
order = []
comp = [-1] * n
for i in range(n):
    if not used[i]:
        dfs1(i)
order = order[::-1]
j = 0
for i in range(n):
    v = order[i]
    if comp[v] == -1:
        dfs2(v, j)
        j += 1
cnt = [0] * j
for i in range(n):
    cnt[comp[i]] += 1
min_comp = min(range(j), key=lambda i: cnt[i])
print(cnt[min_comp])
for i in range(n):
    if comp[i] == min_comp:
        print(i + 1, end=' ')
","import sys

# sys.stind.readline lee datos el doble de
# rápido que la funcion por defecto input
input = sys.stdin.readline
length = len


def get_input():
    n, m, h = [int(x) for x in input().split(' ')]

    digraph = [[] for _ in range(n + 1)]
    transpose = [[] for _ in range(n + 1)]
    mantainence = [0] + [int(x) for x in input().split(' ')]

    for _ in range(m):
        c1, c2 = [int(x) for x in input().split(' ')]

        if (mantainence[c1] + 1) % h == mantainence[c2]:
            digraph[c1].append(c2)
            transpose[c2].append(c1)
        if (mantainence[c2] + 1) % h == mantainence[c1]:
            digraph[c2].append(c1)
            transpose[c1].append(c2)

    return digraph, transpose


def dfs_cc_1_visit(graph, node, color, finalization_stack):
    stack = [node]

    while stack:
        current_node = stack[-1]

        if color[current_node] != 'white':
            stack.pop()
            if color[current_node] == 'grey':
                finalization_stack.append(current_node)
                color[current_node] = 'black'
            continue

        color[current_node] = 'grey'
        for adj in graph[current_node]:
            if color[adj] == 'white':
                stack.append(adj)


def dfs_cc_1(graph):
    n = length(graph)
    finalization_stack = []
    color = ['white'] * n
    for i in range(1, n):
        if color[i] == 'white':
            dfs_cc_1_visit(graph, i, color, finalization_stack)    
    return finalization_stack


def dfs_cc_2_visit(graph, node, color, scc, component):
    stack = [node]

    while stack:
        current_node = stack[-1]

        if color[current_node] != 'white':
            stack.pop()
            color[current_node] = 'black'
            scc[current_node] = component
            continue

        color[current_node] = 'grey'
        for adj in graph[current_node]:
            if color[adj] == 'white':
                stack.append(adj)


def dfs_cc_2(graph, stack_time):
    n = length(graph)
    color = ['white'] * n
    scc = [0] * n
    component = 0
    while stack_time:
        current_node = stack_time.pop()
        if color[current_node] == 'white':
            dfs_cc_2_visit(graph, current_node, color, scc, component)
            component += 1

    return scc, component


def strongly_connected_components(digraph, transpose):
    stack_time = dfs_cc_1(digraph)
    scc, max_component = dfs_cc_2(transpose, stack_time)

    # create the components
    out_deg = [0] * max_component
    scc_nodes = [[] for _ in range(max_component)]
    for node in range(1, length(digraph)):
        scc_nodes[scc[node]].append(node)
        for adj in digraph[node]:
            if scc[node] != scc[adj]:
                out_deg[scc[node]] += 1
    
    # searching minimum strongly connectected component with out degree 0
    minimum_component = None
    for i, value in enumerate(out_deg):
        if value == 0 and (minimum_component is None or length(scc_nodes[i]) < length(scc_nodes[minimum_component])):
            minimum_component = i
    
    # return the size of the component and the nodes
    return length(scc_nodes[minimum_component]), scc_nodes[minimum_component]


def __starting_point():
    digraph, transpose = get_input()
    count, nodes = strongly_connected_components(digraph, transpose)
    
    print(count)
    print(' '.join([str(x) for x in nodes]))

__starting_point()",text_b
3906,"MOD = 10**9 + 7
n, m = map(int, input().split())
dp = [0]*max(n, m)
dp[0] = 2
dp[1] = 4
for i in range(2, max(n, m)):
    dp[i] = (dp[i-1] + dp[i-2]) % MOD
print((dp[n-1] + dp[m-1] - 2) % MOD)
","N, M = list(map(int, input().split()))
P = 10**9+7
F = [1, 2]
for i in range(101010):
    F.append((F[-1]+F[-2])%P)
print((F[N-1]+F[M-1]-1)*2%P)

",text_b
3907,"import heapq
n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(m)]
a.sort(key=lambda x: -x[1])
heap = []
ans = 0
for q, w in a:
    heapq.heappush(heap, w)
    if len(heap) > 1:
        ans += heapq.heappop(heap)
    if len(heap) > 1:
        ans += heapq.heappop(heap)
while len(heap) > 1:
    ans += heapq.heappop(heap)
print(ans)
","import itertools

def f(n):
    return n * (n - 1) / 2 + 1 if n % 2 else n * (n - 1) / 2 + n / 2

n, m = list(map(int, input().split()))
table = sorted([int(input().split()[1]) for _ in range(m)], reverse = True)
ans = 1
while f(ans) <= n:
    ans += 1
ans -= 1
print(list(itertools.accumulate(table))[min(ans - 1, m - 1)])
",text_b
3908,"s = input()
n = len(s)
cnt = [0]*26
dp = [[0]*26 for _ in range(26)]
for i in range(n-1, -1, -1):
    for j in range(26):
        if ord(s[i])-ord('a') != j:
            dp[ord(s[i])-ord('a')][j] += cnt[j]
    cnt[ord(s[i])-ord('a')] += 1
ans = max(max(dp[i]) for i in range(26))
ans = max(ans, max(cnt))
print(ans)
","
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline
mii=lambda:list(map(int,input().split()))

s=input().strip()
d=[0]*1000
e=[0]*1000

hist=[0]*26
for i in s:
    j=ord(i)-ord('a')
    for k in range(26):
        e[k*26+j]+=hist[k]
    hist[j]+=1
    d[j]+=1

print(max(d+e))
",text_b
3909,"n = int(input().strip())
p = 3
while n % p == 0:
    p *= 3
print(n // p + 1)
","n = int(input())

a = 1

while n % a == 0:
    a *= 3

print((n - 1) // a + 1)
",text_b
3910,"n = int(input())
a = [0]*(2*n+1)
b = [0]*(2*n+1)
c = [0]*(2*n+1)
d = [0]*(2*n+1)
e = [0]*(2*n+1)
for i in range(1, n+1):
    x, y = map(int, input().split())
    a[x] = a[y] = i
    b[x] = y
    b[y] = x
for i in range(1, 2*n+1):
    if c[i] == 0:
        c[i] = 1
        c[b[i]] = 2
        j = b[b[i]]
        while c[j] == 0:
            c[j] = 2
            c[b[j]] = 1
            j = b[b[j]]
for i in range(1, 2*n+1):
    d[a[i]] = max(d[a[i]], c[i])
for i in range(1, 2*n+1):
    e[a[i]] = max(e[a[i]], c[b[i]])
for i in range(1, n+1):
    print(d[i], e[i])
","import sys

def solve():
    n = int(input())
    partner = [0]*(2*n)
    pacani = []
    for line in sys.stdin:
        pacan, telka = [int(x) - 1 for x in line.split()]
        partner[pacan] = telka
        partner[telka] = pacan
        pacani.append(pacan)

    khavka = [None]*(2*n)
    for i in range(2*n):
        while khavka[i] is None:
            khavka[i] = 1
            khavka[i^1] = 2
            i = partner[i^1]

    for pacan in pacani:
        print(khavka[pacan], khavka[partner[pacan]])
    
solve()
",text_b
3911,"n = int(input())
a = [0]*20
for i in range(n):
    j = 0
    while a[j] == 1:
        a[j] = 0
        j += 1
    a[j] = 1
for i in range(20):
    if a[i] == 1:
        print(i+1, end = ' ')
","#!/usr/bin/env python3
n = int(input())
arr = []

for i in range(n):
    arr.append(1)
    while len(arr)>=2 and arr[-1] == arr[-2]:
        a, b = arr.pop(), arr.pop()
        arr.append(a+1)

print(' '.join(map(str, arr)))",text_b
3912,"from collections import Counter
from math import gcd
from functools import reduce

def solve():
    n = int(input())
    s = input()
    c = Counter(s)
    g = reduce(gcd, c.values())
    p = [k * (v // g) for k, v in c.items()]
    p.sort()
    print(g)
    for _ in range(g):
        print(''.join(p[i::g]), end=' ')

solve()
","#!/usr/bin/env python3

def main():
    import collections

    n = int(input())
    s = input()
    alph = collections.Counter(s)
    odd = sum(x & 0x1 for x in alph.values())
    dq = collections.deque()
    if odd == 0:
        print(1)
        for c, x in alph.items():
            dq.append(c * (x >> 1))
            dq.appendleft(c * (x >> 1))
        print(*dq, sep="""")
    else:
        for odd in range(odd, n):
            if (n - odd) % (odd << 1) == 0:
                print(odd)
                odds = [c for c, x in alph.items() if x & 0x1]
                items = list(alph.items())
                while len(odds) != odd:
                    for i, x in enumerate(items):
                        if x[1] > 1:
                            items[i] = (x[0], x[1] - 2)
                            odds.append(x[0])
                            odds.append(x[0])
                            break
                req_length = (n - odd) // odd + 1
                cur_length = 0
                while odd > 0:
                    if cur_length == 0:
                        dq.append(odds[-1])
                        cur_length += 1
                        odds.pop()
                    x = min(items[-1][1] >> 1, (req_length - cur_length) >> 1)
                    dq.append(items[-1][0] * x)
                    dq.appendleft(items[-1][0] * x)
                    cur_length += x << 1
                    if items[-1][1] - (x << 1) <= 1:
                        items.pop()
                    else:
                        items[-1] = (items[-1][0], items[-1][1] - (x << 1))
                    if cur_length == req_length:
                        print(*dq, sep="""", end=' ')
                        odd -= 1
                        dq.clear()
                        cur_length = 0
                print()
                break
        else:
            print(n)
            print(*s)

try:
    while True:
        main()
except EOFError:
    pass
",text_b
3913,"n = int(input())
s = input()
m = int(input())
words = [input() for _ in range(m)]
possible = [word for word in words if all(s[i] == '*' or s[i] == word[i] for i in range(n))]
letters = set(''.join(possible))
revealed = set(s.replace('*', ''))
print(len(letters - revealed))
","N = int(input())
p = input()
M = int(input())
words = [input() for _ in range(M)]
cnt = 0
letters = [set() for _ in range(M)]
used = set()
for c in p:
    used.add(c)
fail = [False]*M

for i, w in enumerate(words):
    for j, c in enumerate(w):
        if p[j] == '*':
            letters[i].add(c)
            if c in used:
                fail[i] = True
        elif p[j] != c:
            fail[i] = True

for i in range(26):
    ch = chr(ord('a') + i)
    ok = True
    for i, s in enumerate(letters):
        ok = ok and (ch in s or fail[i])
    if ok: cnt += 1
print(cnt)
",text_b
3914,"import sys
from bisect import bisect_right

def read():
    return list(map(int, sys.stdin.readline().split()))

def solve():
    n, d, b = read()
    a = read()
    s = [0]*(n+1)
    for i in range(1, n+1):
        s[i] = s[i-1] + a[i-1]
    ans = [0]*2
    for _ in range(2):
        l = 0
        for r in range(n, 0, -2):
            while l < n and l <= r and l <= r - d*(r-l+1>>1):
                l += 1
            if l == 0 or s[l-1] < (_+1)*b*(n-r+1>>1):
                ans[_] += 1
        a.reverse()
        s = [0]*(n+1)
        for i in range(1, n+1):
            s[i] = s[i-1] + a[i-1]
    print(min(ans))

solve()
","read = lambda: list(map(int, input().split()))
n, d, b = read()
d += 1
t, a = 0, [0] * (n + 1)
for i, x in enumerate(read()):
    t += x
    a[i + 1] = t
print(max(i - min(a[min(n, i * d)], (a[n] - a[max(0, n - i * d)])) // b for i in range(n + 3 >> 1)))
",text_b
3915,"def is_prime(n):
    if n == 2:
        return True
    if n < 2 or n % 2 == 0:
        return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True

def is_palindromic(n):
    return str(n) == str(n)[::-1]

p, q = map(int, input().split())
primes = [0] * 200000
palindromes = [0] * 200000
prime_count = 0
palindrome_count = 0
for i in range(1, 200000):
    if is_prime(i):
        prime_count += 1
    if is_palindromic(i):
        palindrome_count += 1
    primes[i] = prime_count
    palindromes[i] = palindrome_count

result = -1
for i in range(1, 200000):
    if primes[i] * q <= p * palindromes[i]:
        result = i

if result == -1:
    print(""Palindromic tree is better than splay tree"")
else:
    print(result)
","def primes2(limit):
    if limit < 2: return []
    if limit < 3: return [2]
    lmtbf = (limit - 3) // 2
    buf = [True] * (lmtbf + 1)
    for i in range((int(limit ** 0.5) - 3) // 2 + 1):
        if buf[i]:
            p = i + i + 3
            s = p * (i + 1) + i
            buf[s::p] = [False] * ((lmtbf - s) // p + 1)
    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]

ps = primes2(12*10**6)

def rub2(n):
    lst_odd = []
    lst_even = []
    for head in range(1, n):
        head_str = str(head)
        tail_str = head_str[::-1]
        lst_even.append(int(head_str + tail_str))
        lst_odd.append(int(head_str[:-1] + tail_str))
    lst = lst_odd + lst_even
    lst.sort()
    return lst

rs = rub2(12*10**2)

p, q = map(int, input().split())
idxp = len(ps) - 1
idxr = len(rs) - 1
pi = ps[idxp]
ri = rs[idxr]
while q * (idxp + 1) > p * (idxr + 1):
    if pi < ri:
        idxr -= 1
    elif pi > ri:
        idxp -= 1
    else:
        idxr -= 1
        idxp -= 1
    prev_pi = pi
    prev_ri = ri
    pi = ps[idxp]
    ri = rs[idxr]
print(max(prev_pi-1, prev_ri-1))",text_b
3916,"import sys
input = sys.stdin.readline
n = int(input())
k = list(map(int,input().split()))
k.sort()
cnt = [0]*5001
for i in range(n):
    cnt[k[i]] += 1
for i in range(1,5001):
    cnt[i] += cnt[i-1]
l = 0
r = 5000
while r-l>1:
    mid = (l+r)//2
    if cnt[mid]*2 >= n:
        r = mid
    else:
        l = mid
ans = sum((abs(i-r)+1)*cnt[i] for i in range(r+1,5001))
print(ans)
","T = 1
for test_no in range(T):
	MAXK = 5000
	n = int(input())
	cnt = [0] * (MAXK + 1)
	primeExponential = [[0 for j in range(MAXK + 1)] for i in range(MAXK + 1)]

	line, num = (input() + ' '), 0
	for c in line:
		if c != ' ': num = num * 10 + (ord(c) - 48)
		else:
			cnt[num] += 1
			num = 0

	for i in range(2, MAXK + 1):
		for j in range(0, MAXK + 1): primeExponential[i][j] += primeExponential[i-1][j]
		tmp, x = i, 2
		while x * x <= tmp:
			while tmp % x == 0:
				primeExponential[i][x] += 1
				tmp //= x
			x += 1
		if tmp > 1: primeExponential[i][tmp] += 1

	bestPD = [1] * (MAXK + 1)
	ans, cur = 0, 0

	for i in range(1, MAXK + 1):
		if cnt[i] == 0: continue
		for j in range(1, MAXK + 1):
			ans += primeExponential[i][j] * cnt[i]
			cur += primeExponential[i][j] * cnt[i]
			if primeExponential[i][j]: bestPD[i] = j

	frequency = [0] * (MAXK + 1)
	while max(bestPD) > 1:
		for i in range(MAXK + 1): frequency[i] = 0
		for i in range(MAXK + 1): frequency[bestPD[i]] += cnt[i]

		bestGroup = max(frequency)
		bestPrime = frequency.index(bestGroup)
		if bestGroup * 2 <= n: break
		if bestPrime == 1: break
		cur -= bestGroup
		cur += (n - bestGroup); ans = min(ans, cur)

		for i in range(MAXK + 1):
			if bestPD[i] != bestPrime: bestPD[i] = 1
			if bestPD[i] == 1: continue
			primeExponential[i][bestPD[i]] -= 1
			while bestPD[i] > 1 and primeExponential[i][bestPD[i]] == 0: bestPD[i] -= 1

	print(ans)",text_b
3917,"n = int(input().strip())
a = list(map(int, input().strip().split()))
a = [0] + a
for i in range(2, n + 1):
    a[i] += a[i - 1]
ans = float('inf')
for i in range(1, n + 1):
    for j in range(i + 1, min(n + 1, i + 3)):
        ans = min(ans, (i - j) ** 2 + (a[j - 1] - a[i]) ** 2)
print(ans)
","from sys import stdin, stdout

INF = int(1e9)


class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y


def distance(p1, p2):
    x = p1.x - p2.x
    y = p1.y - p2.y
    return x*x + y*y


def bruteForce(point_set, left, right):
    min_dist = INF
    for i in range(left, right):
        for j in range(i+1, right):
            min_dist = min(min_dist, distance(point_set[i], point_set[j]))
    return min_dist


def stripClosest(point_set, left, right, mid, min_dist):
    point_mid = point_set[mid]
    splitted_points = []
    for i in range(left, right):
        if (point_set[i].x - point_mid.x) ** 2 <= min_dist:
            splitted_points.append(point_set[i])
    splitted_points.sort(key=lambda point: point.y)
    l = len(splitted_points)
    smallest = INF
    for i in range(l):
        for j in range(i+1, l):
            if (splitted_points[i].y - splitted_points[j].y) ** 2 >= min_dist:
                break
            d = distance(splitted_points[i], splitted_points[j])
            smallest = min(smallest, d)
    return smallest


def closestUtil(point_set, left, right):
    if right - left <= 3:
        return bruteForce(point_set, left, right)

    mid = (left + right) // 2
    dist_left = closestUtil(point_set, left, mid)
    dist_right = closestUtil(point_set, mid+1, right)
    dist_min = min(dist_left, dist_right)

    return min(dist_min, stripClosest(point_set, left, right, mid, dist_min))


n = int(stdin.readline())
a = list(map(int, stdin.readline().split()))

pref = [0]
for i in range(n):
    pref.append(pref[i] + a[i])

point_set = []
for i in range(n):
    point_set.append(Point(i, pref[i+1]))

ans = closestUtil(point_set, 0, n)
stdout.write(str(ans))
",text_b
3918,"import heapq

n, k1, k2 = map(int, input().split())
k = k1 + k2
a = list(map(int, input().split()))
b = list(map(int, input().split()))

pq = []

for i in range(n):
    pq.append(-abs(a[i] - b[i]))

heapq.heapify(pq)

while k > 0:
    max_diff = -heapq.heappop(pq)
    heapq.heappush(pq, -abs(max_diff - 1))
    k -= 1

result = 0
for i in range(n):
    diff = -heapq.heappop(pq)
    result += diff * diff

print(result)
","n, k1, k2 = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
r = sorted([abs(a[i] - b[i]) for i in range(n)], reverse=True)
for it in range(k1 + k2):
    if r[0] == 0:
        r[0] = 1
    else:
        r[0] -= 1
        for i in range(n - 1):
            if r[i] < r[i + 1]:
                r[i], r[i + 1] = r[i + 1], r[i]
print(sum(x**2 for x in r))
",text_b
3919,"import sys
input = sys.stdin.readline
mod = 10**9+7
N, M = map(int,input().split())
S = input().strip()
LR = [list(map(int,input().split())) for i in range(M)]
LR.append([N+1,N+1])
S += ""1""
dp = [[0]*(N+2) for i in range(N+2)]
dp[0][0] = 1
cum = [0]*(N+2)
cum[0] = 1
cnt = [0]*(N+2)
cnt[0] = 1
cnt[1] = S[0] == ""1""
for i in range(1,N+1):
    cnt[i+1] = cnt[i] + (S[i] == ""1"")
    for j in range(i+1):
        dp[i][j] = cum[j]
        if j > cnt[i]:
            dp[i][j] -= cum[cnt[i]]
        dp[i][j] %= mod
    for j in range(i+2):
        cum[j] += dp[i][j]
        cum[j] %= mod
idx = 0
for i in range(1,N+1):
    while LR[idx][0] == i+1:
        l, r = LR[idx]
        l -= 1
        r -= 1
        idx += 1
        for j in range(r+1,l-1,-1):
            for k in range(j-l+2):
                dp[j][k] = dp[j-1][k]
                if k > 0:
                    dp[j][k] += dp[j-1][k-1]
                dp[j][k] %= mod
        for j in range(l,r+1):
            cum[j+1] = (cum[j+1]+dp[j][j-l+1])%mod
print(sum(dp[N-1])%mod)
","#!/usr/bin/env python3


M = 10 ** 9 + 7


def solve(n, m, s, lst):

    cnt = [0] * n
    t = 0
    for i in range(n):
        if s[i] == '1':
            t += 1
        cnt[i] = t


    dp = [[0] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    r = 0
    j = 0
    for i in range(n):
        while j < m:
            lj, rj = lst[j]
            if lj <= i:
                r = max(r, rj)
                j += 1
            else:
                break
        if r <= i:
            c = cnt[i]
            if 0 < c:
                dp[i + 1][cnt[i]] = (dp[i][c] + dp[i][c - 1]) % M
            else:
                dp[i + 1][0] = dp[i][0]
        else:
            for k in range(max(0, cnt[r] - r + i), min(i + 1, cnt[r]) + 1):
                if 0 < k:
                    dp[i + 1][k] = (dp[i][k] + dp[i][k - 1]) % M
                else:
                    dp[i + 1][0] = dp[i][0]

    return dp[n][cnt[n - 1]]


def main():
    n, m = input().split()
    n = int(n)
    m = int(m)
    s = input()
    lst = []
    for _ in range(m):
        l, r = input().split()
        l = int(l) - 1
        r = int(r) - 1
        lst.append((l, r))

    print((solve(n, m, s, lst)))


def __starting_point():
    main()


__starting_point()",text_b
3920,,"As = list(map(int, input().split()))

def solve(As):
    L = As[0] + As[1] + As[2]
    return L**2 - As[0]**2 - As[2]**2 - As[4]**2

print(max(solve(As), solve(As[1:] + [As[0]])))
",text_b
3921,"import math
from sys import stdin, stdout
from collections import defaultdict as ddic
from bisect import bisect_right as br
from bisect import bisect_left as bl
from collections import deque
from collections import Counter as C
from random import randint as R
from heapq import heapify,heappop,heappush
from itertools import permutations as P
from math import factorial as F
def prime(n):
    if n==1:
        return False
    if n==2 or n==3:
        return True
    if n%2==0 or n%3==0:
        return False
    i=5
    w=2
    while i*i<=n:
        if n%i==0:
            return False
        i+=w
        w=6-w
    return True
def get_prime(n):
    sieve=[True for _ in range(n+1)]
    p=2
    while p*p<=n:
        if sieve[p]==True:
            for i in range(p*p,n+1,p):
                sieve[i]=False
        p+=1
    prime=[p for p in range(2,n) if sieve[p]]
    return prime
def dist(a,b):
    return abs(a[0]-b[0])+abs(a[1]-b[1])
def dist1(a,b):
    return abs(a-b)
def pair(n):
    return [(i,j) for i in range(n) for j in range(i+1,n)]
def sort_dict(d):
    return sorted(d.items(), key=lambda x: x[1], reverse=True)
def sort_list(l):
    l.sort(key=lambda x: x[1], reverse=True)
    return l
def search(l,r,n):
    while l<=r:
        mid=(l+r)//2
        if n==mid:
            return True
        if n<mid:
            r=mid-1
        else:
            l=mid+1
    return False
def search1(l,r,n):
    while l<=r:
        mid=(l+r)//2
        if n==mid:
            return mid
        if n<mid:
            r=mid-1
        else:
            l=mid+1
    return -1
def sieve(n):
    if n<2:
        return []
    prime=[True for _ in range(n+1)]
    p=2
    while p*p<=n:
        if prime[p]==True:
            for i in range(p*p,n+1,p):
                prime[i]=False
        p+=1
    return [p for p in range(2,n+1) if prime[p]]
def lcm(a,b):
    return (a*b)//math.gcd(a,b)
def binary(n):
    return bin(n).replace(""0b"","""")
def isPowerofTwo(n):
    return (n and (not(n&(n-1))))
def decimal(s):
    return int(s,2)
def isPrime(n):
    if n<=1:
        return False
    if n<=3:
        return True
    if n%2==0 or n%3==0:
        return False
    p=5
    while p*p<=n:
        if n%p==0 or n%(p+2)==0:
            return False
        p+=6
    return True
def isPerfectSquare(n):
    p=int(math.sqrt(n))
    return p*p==n
def mostFrequent(arr,n):
    Hash=dict()
    for i in range(n):
        if arr[i] in Hash.keys():
            Hash[arr[i]]+=1
        else:
            Hash[arr[i]]=1
    max_count=0
    res=-1
    for i in Hash:
        if (max_count<Hash[i]):
            res=i
            max_count=Hash[i]
    return res
def allPrimes(n):
    prime=[True for i in range(n+1)]
    p=2
    while(p*p<=n):
        if(prime[p]==True):
            for i in range(p*p,n+1,p):
                prime[i]=False
        p+=1
    return [p for p in range(2,n) if prime[p]]
def factors(n):
    return [i for i in range(1,n+1) if n%i==0]
def nCr(n, r):
    return F(n) / (F(r) * F(n - r))
def nPr(n,r):
    return F(n)//F(n-r)
def lower_bound(li, num):
    answer = len(li) - 1
    start = 0
    end = len(li) - 1
    while (start <= end):
        middle = (end + start) // 2
        if (li[middle] >= num):
            answer = middle
            end = middle - 1
        else:
            start = middle + 1
    return (answer)
def upper_bound(li, num):
    answer = -1
    start = 0
    end = len(li) - 1
    while(start <= end):
        middle = (end + start) // 2
        if (li[middle] <= num):
            answer = middle
            start = middle + 1
        else:
            end = middle - 1
    return (answer + 1)
def abs(x):
    return x if x >=0 else -x
def binary_search(li, val, lb, ub):
    ans = 0
    while(lb <= ub):
        mid = (lb+ub)//2
        if li[mid] > val:
            ub = mid-1
        else:
            lb = mid+1
    return ub
def kadane(x): #maximum sum contiguous subarray
    sum_so_far = 0
    current_sum = 0
    for i in range(len(x)):
        current_sum += x[i]
        if current_sum < 0:
            current_sum = 0
        else:
            sum_so_far = max(sum_so_far,current_sum)
    return sum_so_far
def pref(li):
    pref_sum = [0]
    for i in range(len(li)):
        pref_sum.append(pref_sum[-1]+li[i])
    return pref_sum
def graph(n,m):
    adj=[[] for _ in range(n+1)]
    for _ in range(m):
        a,b=map(int,input().split())
        adj[a].append(b)
        adj[b].append(a)
    return adj
def dfs(v,vis,adj):
    vis[v]=True
    for i in adj[v]:
        if not vis[i]:
            dfs(i,vis,adj)
def bfs(v,vis,adj):
    q=deque([v])
    while q:
        ele=q.popleft()
        if not vis[ele]:
            vis[ele]=True
        for i in adj[ele]:
            if not vis[i]:
                q.append(i)
def bfs_dis(v,vis,adj,dis):
    q=deque([v])
    dis[v]=0
    while q:
        ele=q.popleft()
        if not vis[ele]:
            vis[ele]=True
        for i in adj[ele]:
            if not vis[i]:
                q.append(i)
                dis[i]=dis[ele]+1
def count(li):
    return [C(li[i]) for i in range(len(li))]
def solve():
    n=int(input())
    a=list(map(int,input().split()))
    dp=[0]*100005
    dp[0]=1
    for i in range(1,n):
        dp[i]=1
        for j in range(1,int(a[i]**0.5)+1):
            if a[i]%j==0:
                if j*j!=a[i]:
                    dp[i]=max(dp[i],dp[bl(a,a[i]//j)-1]+1)
                dp[i]=max(dp[i],dp[bl(a,j)-1]+1)
    print(max(dp))
solve()
","n = 100001
p = [0] * n
t = [[] for i in range(n)]
t[1] = [1]
for i in range(2, n):
    if not t[i]:
        t[i] = [i]
        for j in range(2 * i, n, i): t[j].append(i)
input()
a = list(map(int, input().split()))
for i in a:
    x = max(p[j] for j in t[i]) + 1
    for j in t[i]: p[j] = x
print(max(p))",text_b
3922,"from collections import deque

def bfs(start, goal):
    queue = deque([(start, '')])
    visited = set([start])
    while queue:
        state, moves = queue.popleft()
        if state == goal:
            return moves
        for move in generate_moves(state):
            new_state = apply_move(state, move)
            if new_state not in visited:
                queue.append((new_state, moves + move))
                visited.add(new_state)
    return None

def generate_moves(state):
    # Generate all possible moves for the given state.
    # This depends on the position of the empty space and the positions of the organs that can be moved into it.
    # ...

def apply_move(state, move):
    # Apply the given move to the state and return the new state.
    # ...

t = int(input())
for _ in range(t):
    k = int(input())
    grid = [list(map(str, input().split())) for _ in range(2)]
    start = ''.join(sum(grid, []))
    goal = ''.join(map(str, range(1, 4*k+2))) + 'E'
    moves = bfs(start, goal)
    if moves is None:
        print('SURGERY FAILED')
    else:
        print('SURGERY COMPLETE')
        # Print the sequence of moves and the shortcuts.
        # ...
","def flatten(grid):
    k = len(grid[0]) // 2
    seek = list(range(2*k + 2)) + list(range(2*k + 2, 4*k + 2))[::-1]
    return [seek[v] for v in grid[0] + grid[1][::-1] if v]

def solve(grid):
    grid = list(map(list, grid))
    k = len(grid[0]) // 2
    flat = flatten(grid)

    m = {
        'L': 'l'*2*k + 'u' + 'r'*2*k + 'd',
        'R': 'u' + 'l'*2*k + 'd' + 'r'*2*k,
        'C': 'l'*k + 'u' + 'r'*k + 'd',
        'D': 'CC' + 'R'*(2*k + 1) + 'CC' + 'R'*(2*k + 2),
        'F': 'R'*(k - 1) + 'DD' + 'R'*(2*k + 1) + 'D' + 'L'*2*k + 'DD' + 'L'*k,
        'G': 'FF',
    }

    [(i, j)] = [(i, j) for i in range(2) for j in range(2*k + 1) if grid[i][j] == 0]
    st = 'r'*(2*k - j) + 'd'*(1 - i)

    for v in range(2, 4*k + 2):
        ct = flat.index(v)

        if ct >= 2:
            st += 'L'*(ct - 2) + 'GR'*(ct - 2) + 'G'
            flat = flat[ct - 1: ct + 1] + flat[:ct - 1] + flat[ct + 1:]

        if ct >= 1:
            st += 'G'
            flat = flat[1:3] + flat[:1] + flat[3:]

        st += 'L'
        flat = flat[1:] + flat[:1]
        
    if flat[0] == 1: return st, m

def main():
    def get_line():
        return [0 if x == 'E' else int(x) for x in input().split()]

    for cas in range(int(input())):
        k = int(input())
        grid = [get_line() for i in range(2)]
        assert all(len(row) == 2*k + 1 for row in grid)
        res = solve(grid)
        if res is None:
            print('SURGERY FAILED')
        else:
            print('SURGERY COMPLETE')
            st, m = res
            print(st)
            for shortcut in list(m.items()): print(*shortcut)
            print('DONE')

main()
",text_b
3923,"import sys
from collections import deque

def solve():
    n, a, b = map(int, sys.stdin.readline().split())
    if a == 1 or b == 1:
        print(' '.join(map(str, range(1, n + 1))))
        return
    if a == b or a > 2 and b > 2 or n < a and n < b:
        print(-1)
        return
    if n == 1:
        print(1)
        return
    if n == 2:
        if a == 2 or b == 2:
            print('1 2')
        else:
            print(-1)
        return
    if n == 3:
        if a == 2 or b == 2:
            print('1 2 3')
        else:
            print(-1)
        return
    if n < max(a, b):
        print(-1)
        return
    ans = deque()
    for i in range(1, max(a, b) + 1):
        ans.append(i)
    n -= max(a, b)
    while n > 0:
        if n >= min(a, b):
            ans.appendleft(ans[0] - 1)
            n -= min(a, b)
        else:
            ans.appendleft(ans[0] - 1)
            n -= 1
    print(' '.join(map(str, ans)))

solve()
","# python3
# utf-8

n, a, b = (int(x) for x in input().split())

l = -1
for k in range(n // a + 1):
    if (n - k * a) % b == 0:
        l = (n - k * a) // b
        break
if l == -1:
    print(-1)
    quit()

perm = []
curr_last_op = 1
for i in range(k):
    curr_cycle = [curr_last_op + j for j in range(a)]
    curr_last_op = curr_last_op + a
    perm += curr_cycle[1:] + curr_cycle[:1]

for i in range(l):
    curr_cycle = [curr_last_op + j for j in range(b)]
    curr_last_op = curr_last_op + b
    perm += curr_cycle[1:] + curr_cycle[:1]

print(*perm)
",text_b
3924,"n, k = map(int, input().split())
a = list(map(int, input().split()))
bags = 0
left = 0
for i in range(n):
    if a[i] + left <= k:
        bags += 1
        left = 0
    else:
        bags += (a[i] + left) // k
        left = (a[i] + left) % k
if left > 0:
    bags += 1
print(bags)
","n,k=list(map(int,input().split()))
arr=list(map(int,input().split()))
ans=arr[0]//k
val=arr[0]%k
for i in range(1,n):
    if(val==0):
        ans+=arr[i]//k
        val=arr[i]%k
    else:
        val+=arr[i]
        if(val<k):
            val=0
            ans+=1
        else:
            ans+=val//k
            val=val%k
if(val!=0):
    ans+=1
print(ans)
",text_b
3925,"s = input()
s += s
n = len(s)
f = [0]*n
f[0] = 1
for i in range(1, n):
    if s[i] != s[i-1]:
        f[i] = f[i-1] + 1
    else:
        f[i] = 1
print(min(max(f), len(s)//2))
","#!/bin/python3

a = input()

a = a + a

ma = 1
last = 'x'
pos = 0
cur = 0
while pos < len(a):
	if a[pos] != last:
		cur += 1
		ma = max(ma, cur)
	else:
		cur = 1
	last = a[pos]
	pos += 1

print(min(ma, len(a) // 2))
",text_b
3926,"from collections import deque
from sys import stdin, stdout

n, m = map(int, stdin.readline().split())
r, c = map(int, stdin.readline().split())
x, y = map(int, stdin.readline().split())
maze = [list(stdin.readline().strip()) for _ in range(n)]
visited = [[False]*m for _ in range(n)]
dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]
r -= 1
c -= 1
q = deque([(r, c, x, y)])
visited[r][c] = True
cnt = 1
while q:
    x, y, left, right = q.popleft()
    for i in range(4):
        nx, ny = x + dx[i], y + dy[i]
        if nx < 0 or nx >= n or ny < 0 or ny >= m or visited[nx][ny] or maze[nx][ny] == '*':
            continue
        if i == 1 and left > 0:
            visited[nx][ny] = True
            q.append((nx, ny, left-1, right))
            cnt += 1
        elif i == 3 and right > 0:
            visited[nx][ny] = True
            q.append((nx, ny, left, right-1))
            cnt += 1
        elif i == 0 or i == 2:
            visited[nx][ny] = True
            q.appendleft((nx, ny, left, right))
            cnt += 1
stdout.write(str(cnt))
","def main():
    n,m = list(map(int, input().split()))
    r,c = list(map(int, input().split()))
    L,R = list(map(int, input().split()))
    lab = [input() for _ in range(n)]
    
    r -= 1
    c -= 1
 
    inf = n*m+1
    dist = [[inf] * m for _ in range(n)]
    dist[r][c] = 0
    
    Q = [(r,c)]
    for x,y in Q:
        d = dist[x][y]
        if x < n - 1 and dist[x + 1][y] > d and lab[x + 1][y] == '.':
            dist[x + 1][y] = d
            Q.append((x + 1, y))
 
        if 0 < x and dist[x - 1][y] > d and lab[x - 1][y] == '.':
            dist[x - 1][y] = d
            Q.append((x - 1, y))
        
        if 0 < y and dist[x][y - 1] > d and lab[x][y - 1] == '.':
            dist[x][y - 1] = d + 1
            Q.append((x, y - 1))
        
        if y < m - 1 and dist[x][y + 1] > d and lab[x][y + 1] == '.':
            dist[x][y + 1] = d + 1
            Q.append((x, y + 1))
    ans=0
    for i in range(n):
        for j in range(m):
            d = dist[i][j]
            if d < inf:
                right = (d + (j - c))//2
                left =  (d - (j - c))//2
                if right <= R and left <= L:
                    ans+=1
    print(ans)
main()
#Code By:pajenegod
",text_b
3927,"from collections import Counter
from math import factorial as f
def C(n, k):
    return f(n) // f(k) // f(n - k)
n = int(input())
a = list(map(int, input().split()))
c = Counter(a)
dp = [0] * 10005
dp[0] = 1
for x, y in c.items():
    for i in range(sum(a), -1, -1):
        for j in range(1, min(i // x, y) + 1):
            dp[i] = dp[i] + dp[i - j * x] * C(y, j) * C(sum(a) - y + j, j)
            dp[i] %= 10**9 + 7
if len(c) == 1:
    print(n)
else:
    for x, y in c.items():
        if dp[y * x] > 1:
            print(1)
            break
    else:
        print(min(c.values()))
","from collections import defaultdict

def calcBinomials(N):
    nonlocal binom
    N += 1
    binom = [[0]*N for _ in range(N)]
    for n in range(N):
        binom[n][0] = binom[n][n] = 1
        for k in range(1, n):
            binom[n][k] = binom[n-1][k] + binom[n-1][k-1]

n = int(input())
a = list(map(int, input().split()))
S, res = sum(a), 0
dp = [defaultdict(lambda: 0) for _ in range(S+1)]
dp[0][0] = 1

cnt = {_:a.count(_) for _ in a}
for x in a:
    for i in range(len(dp)-1-x, -1, -1):
        for k, v in list(dp[i].items()):
            dp[i+x][k+1] += v

calcBinomials(n)
for x, c in list(cnt.items()):
    for i in range(1, c+1):
        if dp[x*i][i] == binom[c][i] or dp[S - x*i][n-i] == binom[c][c-i]:
            res = max(res, i)
if len(cnt) <= 2: res = n
print(res)
",text_b
3928,"n, a, b = map(int, input().split())
s = input()

dp = [0] * (n + 1)
dp[0] = a
for i in range(1, n):
    dp[i] = dp[i - 1] + a
    p = [0] * 26
    maxl = 0
    for j in range(i - 1, -1, -1):
        if p[ord(s[j]) - ord('a')] != 0:
            maxl = max(maxl, p[ord(s[j]) - ord('a')])
        p[ord(s[j]) - ord('a')] = max(p[ord(s[j]) - ord('a')], min(maxl + 1, i - j))
        if j + p[ord(s[j]) - ord('a')] - 1 == i:
            dp[i] = min(dp[i], dp[j - 1] + b)
print(dp[n - 1])
","def f(x):
    z=[0 for i in range(len(x))]
    l=0
    r=0
    for i in range(1,len(x)):
        if i<=r:
            z[i]=min(z[i-l],r-i+1)
        while i+z[i]<len(x) and x[z[i]]==x[i+z[i]]:
            z[i]+=1
        if i+z[i]-1>r:
            l,r=i,i+z[i]-1
    return z
a=list(map(int,input('').split()))
n,a,b=a[0],a[1],a[2]
s=input('')
dp=[0 for i in range(n)]
dp[0]=a
for i in range(1,n):
    t=s[:i+1]
    dp[i]=dp[i-1]+a
    q=f(t[::-1])
    maxs=[0 for j in range(i+1)]
    maxs[0]=q[i]
    for j in range(1,i):
        maxs[j]=max(maxs[j-1],q[i-j])
    for j in range(i):
        if maxs[j]>=i-j:
            dp[i]=min(dp[i],dp[j]+b)
print(dp[len(dp)-1])
            
",text_b
3929,"import sys
input = sys.stdin.readline
mod = 10**9+7

N, K = map(int, input().split())
fact = [1]*(N+1)
inv = [1]*(N+1)
for i in range(1, N+1):
    fact[i] = fact[i-1]*i%mod
    inv[i] = pow(fact[i], mod-2, mod)

def comb(n, r):
    if n < r or r < 0:
        return 0
    return fact[n]*inv[r]*inv[n-r]%mod

ans = 0
for i in range(K, N+1):
    ans += comb(N, i)*comb(i-1, K-1)
    ans %= mod
print(ans)
","mod = 1000000007
eps = 10**-9


def main():
    import sys
    input = sys.stdin.readline

    N, K = list(map(int, input().split()))

    if K == 1:
        if N == 1:
            print((1))
        else:
            print((pow(2, N - 2, mod)))
        return

    dp = [[0] * (N+1) for _ in range(K-1)]
    for j in range(2, N+1):
        dp[0][j] = 1
    for i in range(1, K-1):
        cs = [0] * (N+1)
        for j in range(1, N+1):
            cs[j] = (cs[j-1] + dp[i-1][j])%mod
        for j in range(2, N+1):
            if j != N - i + 1:
                dp[i][j] = (dp[i][j] + dp[i-1][j])%mod
            dp[i][j] = (dp[i][j] + cs[-1] - cs[j])%mod
    ans = 0
    for j in range(2, N+1):
        ans = (ans + dp[-1][j])%mod
    if K != N:
        ans = (ans * pow(2, N - K - 1, mod))%mod
    print(ans)


def __starting_point():
    main()

__starting_point()",text_b
3930,"from collections import defaultdict
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    s = [0]*(n+1)
    for i in range(n):
        s[i+1] = s[i] + a[i]
    d = defaultdict(int)
    d[0] = 1
    ans = 0
    for i in range(1, n+1):
        x = 1
        while abs(x) <= 10**14:
            if s[i]-x in d:
                ans += d[s[i]-x]
            if k == 1 or k == -1:
                break
            x *= k
        d[s[i]] += 1
    print(ans)
solve()
","n, k = list(map(int, input().split()))
A = list(map(int, input().split()))
cumsum = [0]

for a in A:
   cumsum.append(cumsum[-1] + a)
#print(cumsum)
pows = set([k**i for i in range(50)])
cum = dict({})
cum[0] = 1

res = 0

for x in cumsum[1:]:
    for pow in pows:
        if (x - pow) in cum:
            res += cum[x - pow]
    if x in cum:
        cum[x] += 1
    else:
        cum[x] = 1

print(res)
",text_b
3931,"from collections import defaultdict
from heapq import *

def solve():
    n, a, b, k, f = map(int, input().split())
    cost = defaultdict(int)
    prev = None
    for _ in range(n):
        u, v = sorted(input().split())
        if (u, v) == prev:
            cost[(u, v)] += b
        else:
            cost[(u, v)] += a
        prev = (u, v)
    costs = list(cost.values())
    costs.sort(reverse=True)
    for i in range(min(k, len(costs))):
        if costs[i] > f:
            costs[i] = f
    print(sum(costs))

solve()
","def main():
  trips, reg, cheap, cards, card_cost = list(map(int, input().split()))

  costs = []
  indexes = {}
  total = 0
  last = """"

  for i in range(trips):
    a, b = input().split()
    pair = (min(a, b), max(a, b))

    if pair in indexes:
      index = indexes[pair]
    else:
      costs.append(0)
      indexes[pair] = len(costs) - 1
      index = len(costs) - 1

    total += (cheap if a == last else reg)
    costs[index] += (cheap if a == last else reg)
    last = b

  costs = sorted(costs, reverse = True)

  for c in costs:
    if c < card_cost or cards <= 0:
      break
    total -= c
    total += card_cost
    cards -= 1

  print(total)

main()
",text_b
3932,"def solve():
    n = int(input())
    c = list(map(int, input().split()))
    c.sort()
    if c[0] != 1 or c[-1] != n:
        print(""NO"")
        return
    c = c[::-1]
    p = [0] * n
    p[0] = 1
    for i in range(1, n):
        p[i] = p[i-1] + c[i-1]
    for i in range(n-2, -1, -1):
        if p[i] < i+1 or p[i] % 2 != (i+1) % 2:
            print(""NO"")
            return
    print(""YES"")

solve()
","def DFS(x):
    for i in range(x):
        if(Seen[i][x]):
            continue
        if(Rem[i]>=C[x]):
            if(Rem[i]==C[x] and len(Children[i])==0):
                continue
            Rem[i]-=C[x]
            Parent[x]=i
            Children[i].append(x)
            return True
    for i in range(x):
        if(Seen[i][x]):
            continue
        Y=[]
        for j in range(len(Children[i])):
            child=Children[i][j]
            Parent[child]=-1
            Rem[i]+=C[child]
            Seen[i][child]=True
            Seen[child][i]=True
            if(DFS(child)):
                Seen[i][child]=False
                Seen[child][i]=False
                continue
            Seen[i][child]=False
            Seen[child][i]=False
            Parent[child]=i
            Rem[i]-=C[child]
            Y.append(child)
        Children[i]=list(Y)
        if(Rem[i]>=C[x]):
            if(Rem[i]==C[x] and len(Children[i])==0):
                continue
            Rem[i]-=C[x]
            Children[i].append(x)
            Parent[x]=i
            return True
    return False
                
        




n=int(input())

C=list(map(int,input().split()))
Rem=[-1]*n
Parent=[-1]*n
Children=[]
Seen=[]
for i in range(n):
    Seen.append([False]*n)
C.sort(reverse=True)

if(C[0]!=n or C.count(2)>0):
    print(""NO"")

else:
    for i in range(n):
        Rem[i]=C[i]-1
        Children.append([])
    Parent[0]=0
    Ans=""YES""
    for i in range(1,n):
        if(DFS(i)==False):
            Ans=""NO""
            break
    for i in range(n):
        if(Rem[i]!=0 and C[i]!=1):
            Ans=""NO""
            break
    print(Ans)
            
",text_b
3933,"n = int(input())
temps = list(map(int, input().split()))
diffs = [temps[i] - temps[i-1] for i in range(1, n)]
if len(set(diffs)) == 1:
    print(temps[-1] + diffs[0])
else:
    print(temps[-1])
","count = int(input())
array = list(map(int, input().split()))

diff = array[0] - array[1]
holds = True

for index in range(1, len(array)-1):
    if array[index] - array[index+1] != diff:
        holds = False

if holds:
    print(array[-1] - (array[-2] - array[-1]))
else:
    print(array[-1])

        
",text_b
3934,"from collections import defaultdict

def solve():
    n = int(input())
    degree = defaultdict(int)
    for _ in range(n-1):
        u, v = map(int, input().split())
        degree[u] += 1
        degree[v] += 1
    for i in range(1, n+1):
        if degree[i] == 2:
            return ""NO""
    return ""YES""

print(solve())
","import getpass
import sys

if getpass.getuser() != 'frohenk':
    filename = 'half'
    # sys.stdin = open('input.txt')
    # sys.stdout = open('output.txt', 'w')
else:
    sys.stdin = open('input.txt')
    # sys.stdin.close()

import math
import string
import re
import random
from decimal import Decimal, getcontext
from collections import deque

mod = 10 ** 9 + 7


def ria():
    return [int(i) for i in input().split()]


n=ria()[0]
ar=[0]*n
for i in range(n-1):
    a,b=ria()
    a-=1
    b-=1
    ar[a]+=1
    ar[b]+=1
print('NO' if ar.count(2) else 'YES')",text_b
3935,"import sys
from collections import deque
n = int(input())
a = list(map(int,input().split()))
a.sort()
b = deque()
for i in range(n):
    if len(b) == 0 or b[-1] < a[i]:
        b.append(a[i])
    else:
        b.appendleft(a[i])
print(n - len(b))
for i in range(n - len(b)):
    print(a[i], end = ' ')
","n = int(input())
b = [int(x) for x in input().strip().split()]

result = {}

for x in b:
    tmp = x
    cnt = 0
    while tmp & 1 == 0:
        cnt += 1
        tmp >>= 1
    if cnt not in result:
        result[cnt] = []
    result[cnt].append(x)

res1 = max([len(result[x]) for x in result])
print(n - res1)
if n == res1:
    return

res2 = None
for x in result:
    if len(result[x]) == res1:
        res2 = x
        break

res3 = []
for x in result:
    if x != res2:
        for y in result[x]:
            res3.append(str(y))

print(' '.join(res3))
",text_b
3936,"MOD = 10**9+7
N = int(input())
S1 = input()
S2 = input()
i = 0
ans = 1
pre = 0
while i < N:
    if S1[i] == S2[i]:
        if pre == 0:
            ans = ans*3%MOD
        elif pre == 1:
            ans = ans*2%MOD
        else:
            ans = ans*1%MOD
        pre = 1
        i += 1
    else:
        if pre == 0:
            ans = ans*6%MOD
        elif pre == 1:
            ans = ans*2%MOD
        else:
            ans = ans*3%MOD
        pre = 2
        i += 2
print(ans)
","N=int(input())
l=""""
mod=10**9+7
Sa=list(input())
Sb=list(input())
for i in range(N):
   if Sa[i]==Sb[i]:
      l+=""X""
   else:
      l+=""Y""
l=l.replace(""YY"",""Y"")
ans=6 if l[0]==""Y"" else 3
for i in range(1,len(l)):
   if l[i]==""Y"" and l[i-1]==""Y"":
      ans*=3
   if l[i]==""X"" and l[i-1]==""X"":
      ans*=2
   if l[i]==""Y"" and l[i-1]==""X"":
      ans*=2
   ans=ans%mod
print(ans)",text_b
3937,"import math

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    l = a[0]
    for i in range(1, k):
        l = lcm(l, a[i])
        if l > n:
            return ""NO""
    g = l
    for i in range(k):
        if g % a[i] != 0 or (i and gcd(a[i - 1], a[i]) != a[i]):
            return ""NO""
    return ""YES"" if g <= m else ""NO""

print(solve())
","'''
Created on Aug 28, 2016

@author: Md. Rezwanul Haque
'''
def gcd(a,b):
    if b == 0:
        return a 
    return gcd(b, a%b) 
def extend_euclid(a,b):
    if b == 0:
        return 1,0 
    else:
        y,x = extend_euclid(b, a%b)
        y = y - (a//b)*x
        return x,y 

n,m,k = map(int,input().split())
a = list(map(int,input().split()))

lcm = 1
for i in a:
    lcm = (lcm*i)//gcd(lcm, i)
    if lcm>n:
        print('NO')
        return
j = 0
m1 = 1
s = True
for i in range(k):
    x,y = extend_euclid(m1, a[i])
    res = m1*x + a[i]*y 
    if (-i-j)%res != 0:
        s = False
        break
    res = (-i-j)//res 
    x,y = x*res , y*res 
    j += m1*x 
    t = m1*a[i]
    if j>t:
        j -= (j//t)*t 
    if j<0:
        j += ((-j+t-1)//t)*t 
    if j == 0:
        j = t 
    m1 = (m1*a[i])//gcd(m1, a[i])
    
if j+k-1 >m or s == False:
    print('NO')
    return
b = [gcd(lcm, j+i) for i in range(k)]
for i in range(k):
    if (a[i] != b[i]):
        print('NO')
        return
print('YES')",text_b
3938,"import sys
from heapq import *
inf = 10**18
n,m = map(int,input().split())
rect = [list(map(int,input().split())) for _ in range(m)]
X = sorted(list(set([x for x1,y1,x2,y2 in rect for x in [x1,x2+1]])))
Y = sorted(list(set([y for x1,y1,x2,y2 in rect for y in [y1,y2+1]])))
rect = [[X.index(x1),Y.index(y1),X.index(x2+1),Y.index(y2+1)] for x1,y1,x2,y2 in rect]
n = len(X)
m = len(Y)
X = [X[0]-1]+X+[X[-1]]
Y = [Y[0]-1]+Y+[Y[-1]]
dx = [X[i+1]-X[i] for i in range(n)]
dy = [Y[i+1]-Y[i] for i in range(m)]
G = [[0]*(m+1) for _ in range(n+1)]
for x1,y1,x2,y2 in rect:
    G[x1][y1] += 1
    G[x2][y1] -= 1
    G[x1][y2] -= 1
    G[x2][y2] += 1
for i in range(n+1):
    for j in range(m):
        G[i][j+1] += G[i][j]
for j in range(m+1):
    for i in range(n):
        G[i+1][j] += G[i][j]
dp = [[inf]*(m+1) for _ in range(n+1)]
dp[0][0] = 0
for i in range(n+1):
    for j in range(m+1):
        if G[i][j] > 0:
            continue
        if i > 0:
            dp[i][j] = min(dp[i][j],dp[i-1][j]+dy[j])
        if j > 0:
            dp[i][j] = min(dp[i][j],dp[i][j-1]+dx[i])
print(dp[-1][-1])
","import sys
from collections import defaultdict

class MaxFlow(object):
    def __init__(self):
        self.edges = defaultdict(lambda: defaultdict(lambda: 0))

    def add_edge(self, u, v, capacity=float('inf')):
        self.edges[u][v] = capacity

    def bfs(self, s, t):
        open_q = [s]

        visited = set()
        parent = dict()
        while open_q:
            close_q = []
            for node in open_q:
                for v, capacity in list(self.edges[node].items()):
                    if v not in visited and capacity > 0:
                        close_q.append(v)
                        parent[v] = node
                        visited.add(v)
                        if v == t:
                            result = []
                            n2 = v
                            n1 = node
                            while n1 != s:
                                result.append((n1, n2))
                                n2 = n1
                                n1 = parent[n1]
                            result.append((n1, n2))
                            return result

            open_q = close_q

        return None

    def solve(self, s, t):
        flow = 0
        route = self.bfs(s, t)
        while route is not None:
            new_flow = float('inf')
            for _, (n1, n2) in enumerate(route):
                new_flow = min(new_flow, self.edges[n1][n2])
            for _, (n1, n2) in enumerate(route):
                self.edges[n1][n2] -= new_flow
                self.edges[n2][n1] += new_flow
            flow += new_flow

            route = self.bfs(s, t)

        return flow

    def __str__(self):
        result = ""{ ""
        for k, v in list(self.edges.items()):
            result += str(k) + "":"" + str(dict(v)) + "", ""
        result += ""}""
        return result


def main():
    (n, m) = tuple([int(x) for x in input().split()])
    r = []
    xs = set()
    ys = set()
    for i in range(m):
        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())
        r.append((x1, y1, x2, y2))
        xs.add(x1)
        xs.add(x2 + 1)
        ys.add(y1)
        ys.add(y2 + 1)

    xx = sorted(xs)
    yy = sorted(ys)
    xsize = len(xs)
    ysize = len(ys)
    grid = []
    for i in range(ysize):
        grid.append([False] * xsize)

    for rect in r:
        x1 = rect[0]
        y1 = rect[1]
        x2 = rect[2]
        y2 = rect[3]
        for i, y in enumerate(yy):
            for j, x in enumerate(xx):
                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:
                    grid[i][j] = True

    f = MaxFlow()
    for i in range(len(yy)):
        for j in range(len(xx)):
            if grid[i][j]:
                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))
    for i in range(len(yy) - 1):
        f.add_edge(0, i + 1, yy[i + 1] - yy[i])
    for i in range(len(xx) - 1):
        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])

    # print(xx)
    # print(yy)
    # print(f)
    print(f.solve(0, len(xx) + len(yy) + 1))


def __starting_point():
    main()

__starting_point()",text_b
3939,"t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    if k not in a:
        print('no')
    else:
        if n == 1:
            print('yes')
        else:
            ans = 'no'
            for i in range(n):
                if a[i] == k and ((i > 0 and a[i - 1] >= k) or (i < n - 1 and a[i + 1] >= k) or (i > 1 and a[i - 2] >= k) or (i < n - 2 and a[i + 2] >= k)):
                    ans = 'yes'
                    break
            print(ans)
","import sys
input = lambda: sys.stdin.readline().rstrip()
T = int(input())
for _ in range(T):
    N, K = list(map(int, input().split()))
    A = [int(a) for a in input().split()]
    if K not in A:
        print(""no"")
        continue
    
    if N == 1 or (A[0] >= K and A[1] >= K):
        print(""yes"")
        continue
    
    for i in range(2, N):
        if A[i] >= K and (A[i-1] >= K or A[i-2] >= K):
            print(""yes"")
            break
    else:
        print(""no"")
        continue
",text_b
3940,"n, m = map(int, input().split())
a = [0]*n
b = [0]*n
c = [0]*n
for i in range(m):
    l, r = map(int, input().split())
    l -= 1
    r -= 1
    b[l] += 1
    b[r+1] -= 1
for i in range(1, n):
    b[i] += b[i-1]
for i in range(n):
    c[i] = b[i]
c.sort()
print(c[0])
for i in range(n):
    a[i] = c[0] - b[i]
for i in range(1, n):
    a[i] = max(a[i], a[i-1])
for i in range(n):
    print(a[i], end=' ')
","f=lambda : list(map(int,input().split()))
n,m=f()
lr=lambda x: x[1]-x[0]+1
sq=min(lr(f()) for _ in range(m))
print(sq)
x=' '.join([str(i%sq) for i in range(n)])
print(x)
",text_b
3941,"from collections import defaultdict
n, m = map(int, input().split())
r = list(map(int, input().split()))
g = defaultdict(list)
for i in range(m):
    a = list(map(int, input().split()))[1:]
    for j in a:
        g[j-1].append(i)
s = [set() for _ in range(m)]
for i in range(n):
    for j in g[i]:
        s[j] |= g[i]
c = [0]*m
for i in range(m):
    for j in s[i]:
        c[j] += 1
d = [0]*m
for i in range(n):
    if r[i] == 0:
        for j in g[i]:
            d[j] = 1
if max(c) > 2 or (max(c) == 2 and max(d) == 1):
    print(""NO"")
else:
    print(""YES"")
","import sys
import collections

n, m = list(map(int, input().split()))

r = tuple(map(int, input().split()))

controls = [tuple(map(int, input().split()))[1:] for i in range(m)]


class DSU:

    def __init__(self):
        self.parent = None
        self.has_zero = False
        self.has_one = False
        self.size = 1
        self.doors = []

    def get_root(self):
        if self.parent is None:
            return self
        self.parent = self.parent.get_root()
        return self.parent

    def unite(self, s):
        r1 = self.get_root()
        r2 = s.get_root()

        if r1 is r2:
            return r1

        if r1.size < r2.size:
            r1, r2 = r2, r1

        r2.parent = r1
        r1.size += r2.size
        r1.has_zero = r1.has_zero or r2.has_zero
        r1.has_one = r1.has_one or r2.has_one

        return r1

door_dsus = [[] for i in range(n)]
for doors in controls:
    n = DSU()
    for door in doors:
        n.doors.append(door - 1)

        door_dsus[door - 1].append(n)
        if r[door - 1]:
            n.has_one = True
        if not r[door - 1]:
            n.has_zero = True

for door, is_open in enumerate(r):
    n1, n2 = door_dsus[door]

    if is_open:
         n1.unite(n2)

G = {}
for door, is_open in enumerate(r):
    if is_open:
        continue

    n1, n2 = door_dsus[door]
    if n1.get_root() is n2.get_root():
        print(""NO"")
        return

    G.setdefault(n1.get_root(), set()).add(n2.get_root())
    G.setdefault(n2.get_root(), set()).add(n1.get_root())

color = {}

for v in list(G.keys()):
    if v in color:
        continue

    color[v] = False
    q = collections.deque([v])
    while q:
        v = q.popleft()
        c = color[v]
        for adj_v in G[v]:
            if adj_v in color:
                if color[adj_v] != (not c):
                    print(""NO"")
                    return
            else:
                color[adj_v] = not c
                q.append(adj_v)

print(""YES"")
",text_b
3942,"s = input()
open_brackets = 0
close_brackets = 0
hashes = 0
for i in s:
    if i == '(':
        open_brackets += 1
    elif i == ')':
        close_brackets += 1
    else:
        hashes += 1
if open_brackets < close_brackets + hashes:
    print(-1)
else:
    for i in range(hashes - 1):
        print(1)
    print(open_brackets - close_brackets - hashes + 1)
","s = input()
last = s.rfind('#')
dif = s.count('(')-s.count(')')-s.count('#')
try:
    assert dif >= 0
    lev = 0
    out = []
    for i in range(len(s)):
        c = s[i]
        if c == '(': lev += 1
        elif c == ')':
            lev -= 1
            assert lev >= 0
        elif c == '#':
            lev -= 1
            if i == last:
                out.append(dif+1)
                lev -= dif
            else:
                out.append(1)
            assert lev >= 0
    assert lev == 0
    for x in out: print(x)
except AssertionError:
    print(-1)
    
",text_b
3943,"def solve(a, b):
    if a == 0:
        return -b * b, 'x' * b
    if b == 0:
        return a * a, 'o' * a
    if a == 1:
        return 1 - b * b, 'x' * (b // 2) + 'o' + 'x' * (b - b // 2)
    ans = -1
    for i in range(1, b + 1):
        t = b // i
        r = b % i
        cur = (i - r) * (t * t) + r * ((t + 1) * (t + 1))
        if i + 1 <= a:
            cur += (a - i - 1) + (i + 1) * (i + 1)
        else:
            cur += (a - 1) * (a - 1) + 1
        if cur > ans:
            ans = cur
            if i + 1 <= a:
                s = 'o' * (a - i - 1) + 'x' * t + 'o' + 'x' * (t + 1 - 1) + 'o' + 'x' * (b - (i - r) * t - r * (t + 1)) + 'o' * (i - r) + 'x' * (t + 1) + 'o' * r
            else:
                s = 'o' * (a - 1) + 'x' * t + 'o' + 'x' * (b - (i - r) * t - r * (t + 1)) + 'o' * (i - r) + 'x' * (t + 1) + 'o' * r
    return ans, s

a, b = map(int, input().split())
v, s = solve(a, b)
print(v)
print(s)
","a,b=[int(i) for i in input().split()]
if(a==0):
    print(-b**2)
    print('x'*b)
elif(b==0):
    print(a**2)
    print('o'*a)
elif(b==1):
    print(a**2-1)
    print('x'+'o'*a)
else:
    ans=-float('inf')
    gr_no=None
    for i in range(2,min(a+2,b+1)):
        v1=(a+2-i)**2 + i-2
        quo=b//i
        rem=b%i
        v2=rem*((quo+1)**2) + (i-rem)*((quo**2))
        if(v1-v2>ans):
            gr_no=i
            ans=v1-v2
    quo=b//gr_no
    rem=b%gr_no
    if(rem>0):
        s='x'*(quo+1)+'o'*(a+2-gr_no)
        rem-=1
    else:
        s='x'*(quo)+'o'*(a+2-gr_no)
    gr_no-=1
    s1='x'*(quo+1)+'o'
    s2='x'*quo + 'o'
    for i in range(rem):
        s+=s1
    for i in range(gr_no-rem-1):
        s+=s2
    s+='x'*(quo)
    print(ans)
    print(s)


",text_b
3944,"MOD = 10**9+7
N, M, K = map(int, input().split())
fact = [1]*(N+M+K+1)
inv = [1]*(N+M+K+1)
for i in range(1, N+M+K+1):
    fact[i] = fact[i-1]*i%MOD
    inv[i] = pow(fact[i], MOD-2, MOD)
def C(n, r):
    if r < 0 or r > n: return 0
    return fact[n]*inv[r]*inv[n-r]%MOD
def solve(n, m, k):
    res = pow(3, n+m+k, MOD)
    for i in range(m+k+1, n+m+k+1):
        res -= C(n+m+k, i)*pow(2, i, MOD)*pow(3, n+m+k-i, MOD)%MOD
        res %= MOD
    return res
print((solve(N, M, K)+solve(M, N, K)+solve(K, N, M))%MOD)
","import sys
input = sys.stdin.readline

import numpy as np

MOD = 10**9 + 7

N,M,K = map(int,input().split())

def cumprod(arr):
    L = len(arr); Lsq = int(L**.5+1)
    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)
    for n in range(1,Lsq):
        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD
    for n in range(1,Lsq):
        arr[n] *= arr[n-1,-1]; arr[n] %= MOD
    return arr.ravel()[:L]

U = 10**6
x = np.full(U,2,dtype=np.int64); x[0] = 1
pow2 = cumprod(x)
x = np.full(U,3,dtype=np.int64); x[0] = 1
pow3 = cumprod(x)
x = np.full(U,pow(2,MOD-2,MOD),dtype=np.int64); x[0] = 1
pow2_inv = cumprod(x)
x = np.full(U,pow(3,MOD-2,MOD),dtype=np.int64); x[0] = 1
pow3_inv = cumprod(x)
x = np.arange(U,dtype=np.int64); x[0] = 1
fact = cumprod(x)
x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)
fact_inv = cumprod(x)[::-1]

L = N+M
A = np.zeros(N+M,dtype=np.int64)
A[1:L] = (-1) * pow2[0:L-1] * pow3_inv[0:L-1] % MOD
A[1:L] *= fact[K+1:K+L] * fact_inv[K] % MOD * fact_inv[1:L] % MOD; A %= MOD
A[1:L] *= pow3_inv[K+1]; A %= MOD
A[0] = 3 * (1 - pow3_inv[K+1]) % MOD * pow2_inv[1] % MOD
np.cumsum(A,out=A); A %= MOD
A *= pow3[:L]; A %= MOD
A *= pow2_inv[:L]; A %= MOD

comb = fact[N-1:N+M] * fact_inv[:M+1] % MOD * fact_inv[N-1] % MOD
answer = (comb * pow3[K+M:K-1:-1] % MOD * A[N-1:N+M] % MOD).sum() % MOD
print(answer)",text_b
3945,"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [[0]*m for _ in range(n)]
c = [[0]*m for _ in range(n)]
for i in range(n):
    temp = [(a[i][j], j) for j in range(m)]
    temp.sort()
    j = 0
    for k in range(m):
        if k and temp[k][0] != temp[k-1][0]:
            j += 1
        b[i][temp[k][1]] = j+1
for j in range(m):
    temp = [(a[i][j], i) for i in range(n)]
    temp.sort()
    i = 0
    for k in range(n):
        if k and temp[k][0] != temp[k-1][0]:
            i += 1
        c[temp[k][1]][j] = i+1
for i in range(n):
    for j in range(m):
        a[i][j] = max(b[i][j], c[i][j]) + max(m-b[i][j], n-c[i][j])
for i in range(n):
    print(*a[i])
","import heapq
import sys
from collections import defaultdict, Counter
from functools import reduce


n, m = list(map(int, input().split()))
arr = []
for _ in range(n):
    arr.append(list(map(int, input().split())))

rows = []
for i in range(n):
    row = set()
    for j in range(m):
        row.add(arr[i][j])
    rows.append({x: i for i, x in enumerate(sorted(row))})

columns = []

for j in range(m):
    column = set()
    for i in range(n):
        column.add(arr[i][j])
    columns.append({x: i for i, x in enumerate(sorted(column))})


def get_answer(i, j):
    el = arr[i][j]
    index1 = rows[i][el]
    index2 = columns[j][el]
    return max(index1, index2) + max(len(rows[i]) - index1,  len(columns[j]) - index2)


for i in range(n):
    answer = []
    for j in range(m):
        answer.append(str(get_answer(i, j)))
    print(' '.join(answer))
",text_b
3946,"MOD = 998244353
n, m = map(int, input().split())
a = list(map(int, input().split()))
w = list(map(int, input().split()))
sum1 = sum(w[i] for i in range(n) if a[i])
sum2 = sum(w[i] for i in range(n) if not a[i])
f = [[0]*(m+1) for _ in range(m+1)]
f[m][0] = sum1 + sum2
for i in range(m, 0, -1):
    for j in range(min(i, sum1), -1, -1):
        k = i - j
        if k > sum2:
            continue
        p1 = (j + 1) % MOD if j < sum1 else 0
        p2 = (k + 1) % MOD if k < sum2 else 0
        f[i-1][j+1] = (f[i][j] * p1) % MOD
        f[i-1][j] = (f[i][j] * p2) % MOD
for i in range(n):
    if a[i]:
        print(w[i] * (f[0][sum1] - sum1 + i) % MOD)
    else:
        print(w[i] * (f[0][sum1] - sum1) % MOD)
","P = 998244353
N, M = list(map(int, input().split()))
A = [int(a) for a in input().split()]
B = [int(a) for a in input().split()]
li = sum([A[i]*B[i] for i in range(N)])
di = sum([(A[i]^1)*B[i] for i in range(N)])
X = [1]
SU = li+di
PO = [0] * (5*M+10)
for i in range(-M-5, 2*M+5):
    PO[i] = pow((SU+i)%P, P-2, P)

def calc(L):
    su = sum(L)
    pl = 0
    pd = 0
    RE = []
    for i in range(len(L)):
        a = li + i
        b = di - (len(L) - 1 - i)
        pd = b * L[i] * PO[a+b-SU]
        RE.append((pl+pd)%P)
        pl = a * L[i] * PO[a+b-SU]
    RE.append(pl%P)
    return RE

for i in range(M):
    X = calc(X)
ne = 0
po = 0
for i in range(M+1):
    po = (po + X[i] * (li + i)) % P
    ne = (ne + X[i] * (di - M + i)) % P
invli = pow(li, P-2, P)
invdi = pow(di, P-2, P)
for i in range(N):
    print(po * B[i] * invli % P if A[i] else ne * B[i] * invdi % P)
",text_b
3947,"import heapq
import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int,input().split()))
if n == 1:
    print(0)
    sys.exit()
if n == 2:
    print(min(a))
    sys.exit()
a = [0] + a + [0]
heap = []
for i in range(1,n+1):
    heapq.heappush(heap,(-a[i],i))
ans = 0
vis = [0]*(n+2)
l = [0]*(n+2)
r = [0]*(n+2)
for i in range(1,n+1):
    l[i] = i-1
    r[i] = i+1
while heap:
    val,idx = heapq.heappop(heap)
    val = -val
    ans += min(a[l[idx]],a[r[idx]])
    if a[l[idx]] < a[r[idx]]:
        r[l[idx]] = r[idx]
        l[r[idx]] = l[idx]
    else:
        l[r[idx]] = l[idx]
        r[l[idx]] = r[idx]
print(ans)
","n = input()

s = []

a = 0

for i in map(int, input().split()):

    while len(s) > 1 and min(s[-2], i)>=s[-1]:

        a += min(i, s[-2])

        del(s[-1])

    s.append(i)

s.sort()

print(a + sum(s[0: -2]))



# Made By Mostafa_Khaled
",text_b
3948,"from collections import deque

n, k = map(int, input().split())
edges = [0] * (n + 1)
adj = [[] for _ in range(n + 1)]
dist = [0] * (n + 1)
for _ in range(n - 1):
    u, v = map(int, input().split())
    edges[u] += 1
    edges[v] += 1
    adj[u].append(v)
    adj[v].append(u)

q = deque()
for i in range(1, n + 1):
    if edges[i] == 1:
        q.append(i)

while q:
    v = q.popleft()
    for u in adj[v]:
        edges[u] -= 1
        if edges[u] == 1:
            q.append(u)
        dist[u] = max(dist[u], dist[v] + 1)

center = dist.index(max(dist))
if dist[center] != k or edges[center] < 3:
    print(""No"")
else:
    for v in adj[center]:
        if dist[v] != k - 1 or edges[v] < 3:
            print(""No"")
            break
    else:
        print(""Yes"")
","from collections import defaultdict

n, k = list(map(int, input().split()))

connections = defaultdict(set)

for _ in range(n-1):
	u, v = list(map(int, input().split()))
	connections[u].add(v)
	connections[v].add(u)

leafs = set()
for node in connections:
	if len(connections[node])==1:
		leafs.add(node)

steps = 0
is_correct = True
while is_correct and steps<=k:
	new_leafs = set()
	for x in leafs:
		if len(connections[x])>1:
			is_correct = False
			#print(""Len of %d more than one""%x)
			break
		root = list(connections[x])[0]
		if len(connections[root])<4 and len(leafs)!=3:
			is_correct = False
			#print(""x: %d Len of root %d less than three""%(x,root))
			#print(connections[root])
			break
	if not is_correct:
		break
	for x in leafs:
		root = list(connections[x])[0]
		new_leafs.add(root)
		connections[root].remove(x)
	leafs = new_leafs
	steps += 1
	if len(leafs)==1 and len(connections[list(leafs)[0]])==0:
		break

#print(""steps is %d""%steps)
if is_correct and steps==k:
	print(""Yes"")
else:
	print('No')
",text_b
3949,"n, m = map(int, input().split())
a = [list(input()) for _ in range(n)]
row = [0]*n
col = [0]*m
r = [0]*n
c = [0]*m
for i in range(n):
    for j in range(m):
        if a[i][j] == '#':
            row[i] += 1
            col[j] += 1
for i in range(n):
    if row[i] > 0:
        l = a[i].index('#')
        r = m - a[i][::-1].index('#') - 1
        if a[i][l:r+1] != ['#']*row[i]:
            print(-1)
            exit(0)
for j in range(m):
    if col[j] > 0:
        l = [a[i][j] for i in range(n)].index('#')
        r = n - [a[i][j] for i in range(n)][::-1].index('#') - 1
        if [a[i][j] for i in range(n)][l:r+1] != ['#']*col[j]:
            print(-1)
            exit(0)
for i in range(n):
    if row[i] > 0:
        r[i] = 1
for j in range(m):
    if col[j] > 0:
        c[j] = 1
if sum(r) != r.count(1) or sum(c) != c.count(1):
    print(-1)
else:
    print(r.count(1))
","import sys
readline = sys.stdin.readline

H, W = map(int, readline().split())
G = [[1 if s == '#' else 0 for s in readline().strip()] for _ in range(H)]

DIREC = [(0, 1), (1, 0), (-1, 0), (0, -1)]
def calc():
    zh = 0      
    for i in range(H):
        cnt = 0
        for j in range(W):
            if G[i][j]:
                if cnt == 0:
                    cnt = 1
                    continue
                if cnt == 1:
                    continue
                if cnt == 2:
                    return -1
            else:
                if cnt == 0:
                    continue
                cnt = 2
        if cnt == 0:
            zh = 1
    zw = 0
    for j in range(W):
        cnt = 0
        for i in range(H):
            if G[i][j]:
                if cnt == 0:
                    cnt = 1
                    continue
                if cnt == 1:
                    continue
                if cnt == 2:
                    return -1
            else:
                if cnt == 0:
                    continue
                cnt = 2
        if cnt == 0:
            zw = 1
    if zw^zh:
        return -1
    ans = 0
    used = set()
    geta = W
    for i in range(H):
        for j in range(W):
            if G[i][j] == 0:
                continue
            if (i*geta + j) in used:
                continue
            ans += 1
            stack = [i*geta + j]
            while stack:
                nh, nw = divmod(stack.pop(), geta)
                for dh, dw in DIREC:
                    fh, fw = nh+dh, nw+dw
                    if not 0 <= fh < H or not 0 <= fw < W:
                        continue
                    if not G[fh][fw]:
                        continue
                    vf = fh*geta + fw
                    if vf in used:
                        continue
                    stack.append(vf)
                    used.add(vf)
    return ans
print(calc())",text_b
3950,"import sys
from collections import deque
n, q = map(int, input().split())
a = list(map(int, input().split()))
a.append(0)
b = [0]*(n+1)
c = deque()
for i in range(n, -1, -1):
    if a[i] > a[i+1]:
        b[i] = a[i]
        c.appendleft(a[i])
    else:
        b[i] = b[i+1]
if len(c) != q or c[0] != 1:
    print(""NO"")
    sys.exit()
c.appendleft(0)
for i in range(n):
    if a[i] == 0:
        a[i] = c[a[i+1]]
print(""YES"")
print(*a[:-1])
","import sys

n, k = map(int, input().split())
a = list(map(int, input().split()))

cur_max = 0
last_max = 1
last = dict()
zeros = []

for i in range(len(a))[::-1]:
    if a[i] == 0:
        zeros.append(i)
    elif a[i] not in last:
        last[a[i]] = i

stack = []

for i in range(len(a)):
    if a[i] == 0:
        a[i] = max(cur_max, 1)
    elif a[i] > cur_max and last[a[i]] != i:
        stack.append(cur_max)
        cur_max = a[i]
    elif cur_max != 0 and i == last[cur_max]:
        cur_max = stack.pop()
    elif a[i] < cur_max:
        print(""NO"")
        return

if k > max(a):
    if zeros:
        print(""YES"")
        a[zeros[0]] = k
        print(*a)
    else:
        print(""NO"")
elif k == max(a):
    print(""YES"")
    print(*a)
elif k < max(a):
    print(""NO"")",text_b
3951,"import sys
from collections import Counter
from math import gcd

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort(reverse=True)
    c = Counter(a)
    ans = []
    for x in a:
        if c[x] > 0:
            for y in ans:
                c[gcd(x, y)] -= 2
            ans.append(x)
            c[x] -= 1
    print(*ans)

solve()
","from fractions import gcd
from random import randint, shuffle
from collections import Counter


def read_numbers():
    return list(map(int, input().split()))


def get_original_array(n, numbers):
    cnt = Counter(numbers)

    array = []
    for new_number in sorted(numbers, reverse=True):
        if cnt[new_number]:
            cnt[new_number] -= 1
            for number in array:
                table_entry = gcd(new_number, number)
                cnt[table_entry] -= 2
            array.append(new_number)
    assert cnt.most_common()[0][1] == 0
    return array


def test(n):
    print(n)
    array = [randint(0, 10**9) for _ in range(n)]
    table = [gcd(a, b) for a in array for b in array]
    shuffle(table)
    print(sorted(array) == sorted(get_original_array(n, table)))

def __starting_point():
#    n = 4
#    numbers = [2, 1, 2, 3, 4, 3, 2, 6, 1, 1, 2, 2, 1, 2, 3, 2]
#    print(get_original_array(n, numbers))
#    test(10)
#    test(100)
#    test(200)
#    test(300)
#    test(400)
#    test(500)
#else:
    n = int(input())
    numbers = read_numbers()
    print(' '.join(map(str, get_original_array(n, numbers))))

__starting_point()",text_b
3952,"import sys
from operator import itemgetter
from collections import defaultdict
from itertools import accumulate

def add(i, x):
    while i <= n:
        bit[i] += x
        i += i & -i

def sum(i):
    s = 0
    while i > 0:
        s += bit[i]
        i -= i & -i
    return s

n = int(sys.stdin.readline())
xy = sorted([list(map(int, sys.stdin.readline().split())) for _ in range(n)], key=itemgetter(1, 0))
xy.append([0, 0])

bit = [0]*(n+1)
cnt = defaultdict(int)
pre = list(accumulate([1]*n))
res = 0

j = 0
for i in range(n):
    if xy[i][1] != xy[i+1][1]:
        for k in range(j, i+1):
            if cnt[xy[k][0]] == 0:
                add(xy[k][0], 1)
            cnt[xy[k][0]] += 1
        for k in range(j, i+1):
            if cnt[xy[k][0]] == 1:
                add(xy[k][0], -1)
            cnt[xy[k][0]] -= 1
        res += sum(xy[i][0])*(sum(xy[i][0])-1)//2 - (pre[i]-sum(xy[i][0]))*(pre[i]-sum(xy[i][0])-1)//2
        j = i+1
res += pre[n-1]*(pre[n-1]-1)//2

print(res)
","import sys
import copy
input = sys.stdin.readline

n=int(input())
P=[list(map(int,input().split())) for i in range(n)]

SET_X=set()
SET_Y=set()

for x,y in P:
    SET_X.add(x)
    SET_Y.add(y)

CX=sorted(SET_X)
CY=sorted(SET_Y)

LEN=len(CX)
MAX=len(CX)-1

DICT_X={x:i for i,x in enumerate(CX)}
DICT_Y={x:i for i,x in enumerate(CY)}

for i in range(n):
    P[i]=[DICT_X[P[i][0]],DICT_Y[P[i][1]]]

check=[0]*len(CX)

# BIT(BIT-indexed tree)

BIT=[0]*(LEN+1)# 1-indexedなtree

def update(v,w):# vにwを加える
    while v<=LEN:
        BIT[v]+=w
        v+=(v&(-v))# 自分を含む大きなノードへ. たとえばv=3→v=4

def getvalue(v):# [1,v]の区間の和を求める
    ANS=0
    while v!=0:
        ANS+=BIT[v]
        v-=(v&(-v))# 自分より小さい2ベキのノードへ. たとえばv=3→v=2へ
    return ANS


LIST_Y=[[] for i in range(len(CY))]
for x,y in P:
    LIST_Y[y].append(x)

for i in range(len(CY)):
    LIST_Y[i].sort()

ANS=0
for y in range(len(CY)-1,-1,-1):
    for x in LIST_Y[y]:
        #print(x,check)
        if check[x]==0:
            check[x]=1
            update(x+1,1)

    ANS+=getvalue(LIST_Y[y][0]+1)*(getvalue(MAX+1)-getvalue(LIST_Y[y][0]+1)+1)

    for i in range(1,len(LIST_Y[y])):
        #print(getvalue(LIST_Y[y][i]+1)-getvalue(LIST_Y[y][i-1]+1)),getvalue(MAX+1)
        ANS+=(getvalue(LIST_Y[y][i]+1)-getvalue(LIST_Y[y][i-1]+1))*(getvalue(MAX+1)-getvalue(LIST_Y[y][i]+1)+1)

    #print(ANS)

print(ANS)

        
        
        
",text_b
3953,"n = int(input())
a = [list(input()) for _ in range(n)]
r = [i for i in range(n) if 'E' not in a[i]]
c = [i for i in range(n) if all(a[j][i] != 'E' for j in range(n))]
if r:
    for i in r:
        print(i + 1, a[i].index('.') + 1)
elif c:
    for i in c:
        print(a[j][i] for j in range(n)).index('.') + 1, i + 1
else:
    print(-1)
","n = int(input())
d = []
for i in range(n):
    d.append(input())

for i in range(n):
    if d[i].count('E') == n:
        break
else:
    for i in range(n):
        print(i+1, d[i].index('.')+1)
    return

for i in range(n):
    res = 0
    for j in range(n):
        if d[j][i] == 'E':
            res += 1
    if res == n:
        break
else:
    for i in range(n):
        for j in range(n):
            if d[j][i] == '.':
                print(j+1, i+1)
                break
    return
print(-1)",text_b
3954,"n, k = map(int, input().split())
a = list(map(int, input().split()))
b = [0] * (n + 1)
for i in range(1, n + 1):
    b[i] = b[i - 1] + a[i - 1]
ans = -1e9
for l in range(n):
    for r in range(l, n):
        out = sorted(a[:l] + a[r + 1:])[-k:]
        in_ = sorted(a[l:r + 1])
        while len(out) > 0 and len(in_) > 0 and out[-1] > in_[0]:
            out.pop()
            in_.pop(0)
        ans = max(ans, b[r + 1] - b[l] - sum(in_))
print(ans)
","def solve(a,l,r,k):
    out = sorted(a[:l]+a[r:],reverse=True)
    inside = sorted(a[l:r])
    cur = sum(a[l:r])
    for i in range(min(k,len(inside),len(out))):
        if out[i] > inside[i]:
            cur += out[i]-inside[i]
        else:
            break
    return cur

n,k = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
assert len(a) == n

best = a[0]
for l in range(n):
    for r in range(l+1,n+1):
        cur = solve(a,l,r,k)
        if cur > best:
            best = cur

print(best)
",text_b
3955,"import sys
from collections import defaultdict

n, k, x = map(int, input().split())
a = list(map(int, input().split()))

dp = [defaultdict(int) for _ in range(k+1)]
dp[0][0] = 1

for i in range(n):
    for j in range(k+1):
        for key in dp[j]:
            dp[j+1][key^a[i]] += dp[j][key]

max_val = 0
for i in range(k+1):
    for key in dp[i]:
        max_val = max(max_val, key)

print(max_val)
","class Ortree():
    def __init__(self, n, As):
        size = 1
        while n > size:
            size *= 2
        self.size = size
        data = [0] * size + As[:] + [0] * (size - n)
        for idx in range(self.size - 1, 0, -1):
            idx2 = idx << 1
            data[idx] = data[idx2] | data[idx2 + 1]
        self.data = data
    
    def update(self, idx, val):
        pos = idx + self.size
        self.data[pos] = val
        pos >>= 1
        while pos:
            pos2 = pos << 1
            self.data[pos] = self.data[pos2] | self.data[pos2 + 1]
            pos >>= 1
        return self.data[1]


def solve(n, k, x, As):
    As.sort(reverse= True)
    xk = x**k
    if n == 1:
        As[0] *= xk
        return As[0]
    if is_simplecase(xk, As):
        As[0] *= xk
        return cumor(As)
    return complexcase(n, xk, As)
    

def cumor(As):
    result = 0
    for a in As:
        result |= a
    return result

def is_simplecase(xk, As):
    len0 = len(bin(As[0] * xk))
    len1 = len(bin(As[1] * xk))
    return len0 > len1

def complexcase(n, xk, As):
    len0 = len(bin(As[0] * xk))
    for i, a in enumerate(As[1:], 1):
        if len(bin(a * xk)) < len0:
            end = i
            rest = cumor(As[end:])
            break
    else:
        end = n
        rest = 0
    ortree = Ortree(end, As[:end])
    record = rest
    for i in range(end):
        score = ortree.update(i, As[i] * xk) | rest
        if record < score:
            record = score
        ortree.update(i, As[i])
    return record

n, k, x = map(int, input().split())
As = list(map(int, input().split()))
print(solve(n, k, x, As))",text_b
3956,"import sys
input = sys.stdin.readline

MOD = 998244353
K, N = map(int, input().split())
fact = [1] * (2 * K + 1)
fact_inv = [1] * (2 * K + 1)
for i in range(1, 2 * K + 1):
    fact[i] = fact[i - 1] * i % MOD
    fact_inv[i] = pow(fact[i], MOD - 2, MOD)

def comb(n, r):
    if n < r or r < 0:
        return 0
    return fact[n] * fact_inv[r] * fact_inv[n - r] % MOD

def solve(i):
    res = 0
    for j in range(i // 2 + 1):
        res += comb(N, j) * comb(N - j + K - 1, N) % MOD
        res %= MOD
    return res

for i in range(2, K + 1):
    print(solve(i) * 2 % MOD)
for i in range(K + 1, 2 * K):
    print((solve(i) * 2 - comb(N, i - K) * comb(N + K - 1, N) % MOD + MOD) % MOD)
","from collections import defaultdict,deque
import sys,heapq,bisect,math,itertools,string,queue,datetime
sys.setrecursionlimit(10**8)
INF = float('inf')
mod = 998244353
eps = 10**-7
def inp(): return int(input())
def inpl(): return list(map(int, input().split()))
def inpls(): return list(input().split())

K,N = inpl()
MAX = K+N+10
fac = [1]*(MAX+1)
for i in range(1,MAX+1):
	fac[i] = (fac[i-1]*i)%mod

gyakugen = [1]*(MAX+1)
gyakugen[MAX] = pow(fac[MAX],mod-2,mod)
for i in range(MAX,0,-1):
	gyakugen[i-1] = (gyakugen[i]*i)%mod

def Comb(n,k):#nCk
	return (fac[n]*gyakugen[k]*gyakugen[n-k])%mod

#K=k,N=n,0pair = 0
def calc(k,n,i):
	#i=2に帰着させる
	pairs = (i-2)//2
	k -= pairs
	n -= pairs

	#色々と例外処理
	if n < 0 or k <= 0:
		return 0
	elif k == 1 and n >= 2:
		return 0

	if n == 0: 	 #球が0個なら1通り
		ans = 1
	else:
		ans = 0
		#i=2の時の数え上げ
		for x in range(2):
			ball = n-x	#球
			box = k-1	#箱
			ans += Comb(box-1+ball,ball)%mod

	ans *= pow(2,pairs,mod)	#0pairの選び方
	return ans % mod

ans = []
for i in range(2,K+2):
	if i%2 == 0:
		pairs = (i-2)//2
		tmp = 0
		for p0 in range(pairs+1): #p0 = 0pairの数
			tmp1 = calc(K-p0*2 , N , i-p0*2) %mod #k-p0*2,i-p0*2で0pairが0組
			tmp2 = Comb(pairs,p0) %mod #0pairの選び方
			tmp += tmp1 * tmp2
			tmp %= mod
	ans.append(tmp)
	print(tmp)

ans = ans[::-1]
for i in range(1,K):
	print((ans[i]))
",text_b
3957,"import sys
from collections import deque
input = sys.stdin.readline
n, k = map(int, input().split())
univ = [0] * (n + 1)
for u in map(int, input().split()):
    univ[u] = 1
g = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    g[u].append(v)
    g[v].append(u)
q = deque([1])
p = [0] * (n + 1)
used = [0] * (n + 1)
used[1] = 1
while q:
    v = q.popleft()
    for to in g[v]:
        if not used[to]:
            used[to] = 1
            p[to] = v
            q.append(to)
for v in range(n, 0, -1):
    univ[p[v]] += univ[v]
print(sum(sorted(univ, reverse=True)[:k]))
","def bfs(source):
    q = [0] * (n + 1);
    fa = [-1] * n
    l, r = [1] * 2
    fa[source] = source
    q[1] = source
    while l <= r:
        x = q[l]
        l += 1
        for y in e[x]:
            if  fa[y] == -1:
                fa[y] = x
                r += 1
                q[r] = y
    i = r;
    while i >= 1:
        x = q[i]
        for y in e[x]:
            if fa[y] == x:
                sum[x] += sum[y]
                dp[x] += dp[y] + min(sum[y], m - sum[y])
        i -= 1

n, m =[int(x) for x in input().split()]
m <<= 1
t = [int(x) for x in input().split()]
e = [list() for i in range(n)]
sum = [0] * n
dp = [0] * n
#print(len(e), e)
for i in range(n - 1):
    x, y = [int(a) for a in input().split()]
    e[x - 1].append(y - 1)
    e[y - 1].append(x - 1)
for x in t:
    sum[x - 1] = 1
bfs(0)
print(dp[0])",text_b
3958,"s = input().strip()
n = len(s)
a, b = [], []
res = [[] for _ in range(n)]
for i in range(n):
    if s[i] == '0':
        if len(b) == 0:
            a.append(i)
        else:
            x = b.pop()
            a.append(x)
        res[a[-1]].append(i+1)
    else:
        if len(a) == 0:
            print(-1)
            exit(0)
        else:
            x = a.pop()
            b.append(x)
        res[b[-1]].append(i+1)
if len(a) < len(b):
    print(-1)
else:
    print(len(a))
    for i in range(len(a)):
        print(len(res[i]), *res[i])
","s = input() 
zero = set() # 前面的一个以0结尾的串的索引
one  = set() # 前面的一个以1结尾的串的索引
ans  = []    # 结果的串
for i in range(0,len(s)):
    if(s[i] == '0'):
        if one:
            k = one.pop()
            zero.add(k)
            ans[k].append(i+1)
        else:
            zero.add(len(ans))
            ans.append([i+1])
    else:
        if not zero:
            print(-1)
            return
        k = zero.pop()
        one.add(k)
        ans[k].append(i+1)
if(one):
    print(-1)
    return
print(len(ans))
print('\n'.join([str(len(x))+' '+' '.join(map(str,x)) for x in ans]))
",text_b
3959,"from collections import defaultdict
from math import factorial
mod = 10**9+7

n, m = map(int,input().split())
pokemons = defaultdict(list)

for _ in range(n):
    gym = list(map(int,input().split()))[1:]
    gym.sort()
    for i in range(len(gym)):
        pokemons[gym[i]].append(i+1)

pokemons = sorted(pokemons.values())

answer = 1
count = 1

for i in range(1,len(pokemons)):
    if pokemons[i] == pokemons[i-1]:
        count += 1
    else:
        answer = answer * factorial(count) % mod
        count = 1

answer = answer * factorial(count) % mod

print(answer)
","import sys
from collections import defaultdict, Counter

P = 10 ** 9 + 7

def factmod(n):
    res = 1
    for i in range(2, n+1):
        res *= i
        res %= P

    return res

def solve():
    n, m = list(map(int, input().split()))
    colour = {i:0 for i in range(1, m+1)}
    colour_map = {}
    for i, line in enumerate(sys.stdin):
        A = [int(x) for x in line.split()]
        count = Counter(A)

        if count[A[0]] == 1:
            count.pop(A[0])
        else:
            count[A[0]] -= 1

        for c in count:
            p = (colour[c], i, count[c])
            if p in colour_map:
                colour[c] = colour_map[p]
            else:
                colour[c] = colour_map[p] = len(colour_map) + 1

    count = Counter(list(colour.values()))

    res = 1
    for c in count:
        res *= factmod(count[c])
        res %= P

    return res

print(solve())
",text_b
3960,"n = int(input().strip())
a = list(map(int,input().strip().split()))
b = [0]*(n-1)
for i in range(n-1):
    b[i] = abs(a[i]-a[i+1])*(-1)**i
c = [0]*(n-1)
d = [0]*(n-1)
c[0] = b[0]
d[0] = -b[0]
for i in range(1,n-1):
    c[i] = max(b[i],c[i-1]+b[i])
    d[i] = max(-b[i],d[i-1]-b[i])
print(max(max(c),max(d)))
","n = int(input())
l = tuple(map(int, input().split()))

a = []
for i in range(n - 1):
    a.append(abs(l[i] - l[i + 1]))

ev = [(a[i] if i % 2 == 0 else -a[i]) for i in range(n - 1)]
od = [-i for i in ev]
od[0] = 0

dp = [ev[0]]
st = [""ev""]

# print(a)
# print(ev)
# print(od)

vmax = dp[0]

evsum = evans = 0
odsum = odans = 0

for i in range(0, n - 1):
    evsum += ev[i]
    odsum += od[i]
    evans = max(evsum, evans)
    odans = max(odsum, odans)
    if evsum < 0 and i % 2 == 1:
        evsum = 0
    if odsum < 0 and i % 2 == 0:
        odsum = 0

# print(evans, odans)

print(max(evans, odans))
",text_b
3961,"n = int(input())
p = list(map(int, input().split()))
p = [0] + p
dp = [0]*(n+2)
s = [0]*(n+2)
mod = 10**9+7
for i in range(1, n+1):
    dp[i] = (2*dp[i-1] - dp[p[i]-1] + 2) % mod
print(dp[n])
","n,a= int(input()),list(map(int,input().split()))
f,m= [0]*(n+1),10**9+7
for i in range(n):
	if a[i]==i+1:
		f[i+1]=f[i]+2
	else:
		f[i+1]=(2+f[i]*2-f[a[i]-1])%m
print(f[n]%m)
",text_b
3962,"n = int(input())
l = []
r = []
for _ in range(n):
    a, b = map(int, input().split())
    l.append(a)
    r.append(b)
l.sort()
r.sort()
print(max(sum(l), sum(r)) + n)
","import sys
input = sys.stdin.readline

n=int(input())
lr=[list(map(int,input().split())) for i in range(n)]

L=[lr[i][0] for i in range(n)]
R=[lr[i][1] for i in range(n)]
L.sort()
R.sort()

ANS=0

for i in range(n):
    ANS+=max(L[i],R[i])

print(ANS+n)
",text_b
3963,"import sys
from collections import defaultdict
from itertools import accumulate
from operator import mul
mod = 10**9+7
n = int(input())
a = list(map(int,input().split()))
b = list(map(int,input().split()))
m = int(input())
a = [1]+a
b = [0]+b
c = [0]*(n+1)
for i in range(1,n+1):
    c[i] = c[i-1]+b[i]
    if a[i]>20 or a[i-1]*a[i]>m:
        a[i] = min(a[i],m//a[i-1]+1)
dp = [0]*(m+1)
dp[0] = 1
for i in range(1,n+1):
    ndp = [0]*(m+1)
    for j in range(m+1):
        l = max(0,j-a[i]*b[i])
        r = min(c[i-1],j)+1
        if l<r:
            ndp[j] = (dp[r-1]-(dp[l-1] if l else 0))%mod
    dp,ndp = ndp,dp
    dp[0] = 1
    for j in range(1,m+1):
        dp[j] = (dp[j-1]+dp[j])%mod
print(dp[m])
","p = 1000000007

n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
m = int(input())

d = [1] * 300001
td = [0] * 300001
L = b[0]
for i in range(1, n):
	if a[i - 1] != 1:
		t = m % a[i - 1]
		if L < t:
			print(0)
			return
		m //= a[i - 1]
		for j in range((L - t) // a[i - 1] + 1):
			d[j] = d[t]
			t += a[i - 1]
		L = j
	k = 0
	for j in range(L + b[i] + 1):
		if j <= L:
			k += d[j]
		k %= p
		td[j] = k
		if j >= b[i]:
			k -= d[j - b[i]]
	L += b[i]
	for j in range(L + 1):
		d[j] = td[j]
print(d[m] if m <= L else 0)",text_b
3964,"def solve():
    n, m, b, mod = map(int, input().split())
    a = list(map(int, input().split()))
    dp = [[0]*(b+1) for _ in range(m+1)]
    dp[0][0] = 1
    for i in range(n):
        for j in range(1, m+1):
            for k in range(a[i], b+1):
                dp[j][k] = (dp[j][k] + dp[j-1][k-a[i]]) % mod
    print(sum(dp[m]) % mod)

solve()
","def main():
    n, m, b, mod = list(map(int, input().split()))
    row_zero = [1] + [0] * b
    b += 1
    dp = [[0] * b for _ in range(m)]
    for a in list(map(int, input().split())):
        cur = row_zero
        for nxt in dp:
            for i, u in zip(list(range(a, b)), cur):
                nxt[i] = (nxt[i] + u) % mod
            cur = nxt
    print(sum(dp[-1]) % mod)


def __starting_point():
    main()

__starting_point()",text_b
3965,"n = int(input())
p = list(map(int, input().split()))
vowels = ['a', 'e', 'i', 'o', 'u', 'y']
for i in range(n):
    line = input()
    syllables = sum([1 for c in line if c in vowels])
    if syllables != p[i]:
        print('NO')
        break
else:
    print('YES')
","#!/usr/bin/env python3


def main():
    n = int(input())
    ps = [int(x) for x in input().split()]
    v = set('aeiouy')
    for p in ps:
        s = input()
        ss = sum(1 for x in s if x in v)
        if ss != p:
            print('NO')
            return
    print('YES')


def __starting_point():
    main()

__starting_point()",text_b
3966,"n = int(input())
a = list(map(int, input().split()))
a.sort()
s = sum(a)
res = s
for i in range(n-1):
    s -= a[i]
    res += s + a[i]
print(res)
","n = int(input())
a = sorted(list(map(int, input().split())))

ans = 0
if n == 1:
    ans = a[0]
else:
    mult = 2
    for i in range(n - 1):
        ans += mult * a[i]
        mult += 1
    ans += (mult - 1) * a[-1]
print(ans)

",text_b
3967,"def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    a.sort()
    s = [0]*(n+1)
    for i in range(n):
        s[i+1] = s[i] + a[i]
    l = 1
    r = 10**9+1
    while r - l > 1:
        m = (l + r) // 2
        t = 0
        for i in range(n):
            t += (a[i] + m - 1) // m
        if t <= k:
            r = m
        else:
            l = m
    print(r)

solve()
","import itertools

unfold = itertools.chain.from_iterable

speedup = 400000

def jumps(a):
    d = speedup
    while d < a - 1:
        c = (a + d - 1) // d
        d = (a + c - 2) // (c - 1)
        yield d


def calc(d):
    return sum(d - 1 - (i - 1) % d for i in a)

def ans():
    for d, pd in zip(D, D[1:]):
        d -= 1
        cd = calc(d)
        if cd <= k:
            return d
        if d == pd:
            continue
        cpd = calc(pd)
        if d - pd >= (cd - k) * (d - pd) / (cd - cpd):
            return d - (cd - k) * (d - pd) / (cd - cpd)
    return 1

n, k = map(int, input().split())
a = list(map(int, input().split()))
speedup = min(speedup, 2 * int(max(a) ** 0.5))

D = sorted(set(range(1, speedup + 1)).union([max(a) + k + 1]).union(set(
    unfold(map(jumps, a)))), reverse=True)
    
print('%d' % ans())",text_b
3968,"import heapq

def solve():
    N, D = map(int, input().split())
    C, *infected = map(int, input().split())
    infected = set(infected)
    people = [list(map(int, input().split())) + [i+1] for i in range(N)]
    people.sort()

    infected_times = [(t, i) for s, t, i in people if i in infected]
    heapq.heapify(infected_times)

    for _ in range(D):
        new_infected = []
        while people and people[0][0] <= (infected_times[0][0] if infected_times else float('inf')):
            s, t, i = people.pop(0)
            if infected_times and infected_times[0][0] <= s:
                _, j = heapq.heappop(infected_times)
                infected.add(j)
            if i not in infected:
                new_infected.append((t, i))
        for t, i in new_infected:
            heapq.heappush(infected_times, (t, i))

    print(*sorted(infected))

solve()
","n=int(input())
a=input().split()
ones=a.count(""1"")
twos=n-ones
if ones==0 or twos==0:
    print("" "".join(a))
else:
    print(""2 1""+"" 2""*(twos-1)+"" 1""*(ones-1))",text_b
3969,"n, m = map(int, input().split())
plants = [0]*n
for i in range(n):
    s, x = map(float, input().split())
    plants[i] = int(s)
dp = [1]*n
for i in range(n):
    for j in range(i):
        if plants[i] >= plants[j]:
            dp[i] = max(dp[i], dp[j]+1)
print(n - max(dp))
","n, m = map(int, input().split())
t = [int(input().split()[0]) for i in range(n)]
p = [0] * (m + 1)
for i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1
print(n + min(p))",text_b
3970,"def k_multiple_free_set():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    a.sort()
    used = [False]*n
    ans = 0
    for i in range(n):
        if not used[i]:
            ans += 1
            if a[i]*k in a:
                used[a.index(a[i]*k)] = True
    print(ans)

k_multiple_free_set()
","n, k = map(int, input().split())
t = list(map(int, input().split()))
if k == 1: print(len(set(t)))
else:
    p = [set() for i in range(30)]
    for i in t:
        j = 0
        while i % k == 0:
            i //= k
            j += 1
        p[j].add(i)
    for j in range(1, 30):
        p[j] -= p[j - 1]
    print(sum(len(i) for i in p))",text_b
3971,"from collections import Counter

n = int(input())
a = list(map(int, input().split()))
c = Counter(a)
dp = [0]*(max(a)+1)
for i in range(min(a), max(a)+1):
    dp[i] = max(dp[i-2] + i*c[i], dp[i-1])
print(dp[-1])
","""""""
Codeforces Contest 260 Div 1 Problem A

Author  : chaotic_iak
Language: Python 3.3.4
""""""

def main():
    n, = read()
    ar = read()
    a = [0] * 100001
    for i in ar: a[i] += 1

    dp = [0] * 100001
    dp[1] = a[1]
    for i in range(2, 100001):
        dp[i] = max(a[i] * i + dp[i-2], dp[i-1])
    print(dp[-1])

################################### NON-SOLUTION STUFF BELOW

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0: return inputs
    if mode == 1: return inputs.split()
    if mode == 2: return map(int, inputs.split())

def write(s=""\n""):
    if isinstance(s, list): s = "" "".join(map(str, s))
    s = str(s)
    print(s, end="""")

main()",text_b
3972,"MOD = 10**9+7
n = int(input())
dp = [0]*(n+1)
dp[1] = 1
s = 1
for i in range(2,n+1):
    dp[i] = (dp[i-1] + s - dp[i-2]) % MOD
    s = (s + dp[i]) % MOD
print((pow(n, n, MOD) - s + dp[n-1]) % MOD)
","# dp[i] := i 項目以降を見たときの場合の数
#       = dp[i+1] + (Σ_{3<=d<=N-1} dp[i+d]) + (n-1)**2

# i 項目と i+1 項目について、
#   (1) i 項目が 1 の場合
#   (2) i 項目が 1 で無く、i+1 項目が 1 の場合
#   (3) i 項目も i+1 項目も 1 で無い場合
# で場合分けしてそれぞれを足している
# これを累積和で高速化する

# 初期化がややこしい

N = int(input())
mod = 10**9+7
dp = [N] * (N+1)
dp[N-1] = N
dp[N-2] = N*N
c = N * (N+1) + N-1
const = (N-1)**2
for i in range(N-3, -1, -1):
    ans = c - dp[i+2] + const
    dp[i] = ans
    c = (c + ans - 1) % mod
print((dp[0]%mod))
",text_b
3973,,"n,m=map(int,input().split())
A=[int(i)-1 for i in input().split()]
ds=[0]*m
de=[[] for i in range(m)]
h,dec=0,0
for i in range(n-1):
  if A[i+1]-A[i]>0:
    h+=A[i+1]-A[i]
  else:
    h+=A[i+1]+1
    dec+=1
  de[A[i+1]].append((i,(A[i+1]-A[i])%m))
for i in range(m):
  for a in de[i]:
    ds[(i-a[1]+1)%m]+=1
ans=float(""inf"")
for i in range(m):
  for a in de[i]:
    h+=a[1]-1
    dec-=1
  h-=dec
  ans=min(h,ans)
  if i<=m-2:
    dec+=ds[i+1]
  
print(ans)",text_b
3974,"def min_people(s):
    people = 0
    max_people = 0
    for i in s:
        if i == '+':
            people += 1
        else:
            if people == 0:
                max_people += 1
            else:
                people -= 1
    return max_people + people

s = input().strip()
print(min_people(s))
","m,p,c=0,0,0
s=(input())
for i in  s:
    if i=='-':
        c-=1
    else:
        c+=1    
    m=min(m,c)
    p=max(p,c)
print(p-m)
",text_b
3975,"import sys
from collections import deque
input = sys.stdin.readline
n = int(input())
g = [0]*n
val = [0]*n
typ = [0]*n
for i in range(n):
    a = list(input().split())
    if a[0] == 'IN':
        typ[i] = 0
        val[i] = int(a[1])
    else:
        if a[0] == 'AND':
            typ[i] = 1
        elif a[0] == 'OR':
            typ[i] = 2
        elif a[0] == 'XOR':
            typ[i] = 3
        else:
            typ[i] = 4
        g[i] = list(map(int, a[1:]))
        g[i] = [x-1 for x in g[i]]
rev = [[] for _ in range(n)]
for i in range(n):
    for j in g[i]:
        rev[j].append(i)
q = deque([0])
used = [0]*n
while q:
    v = q.popleft()
    used[v] = 1
    for to in rev[v]:
        if not used[to]:
            q.append(to)
for v in range(n-1, -1, -1):
    if typ[v] == 0:
        continue
    elif typ[v] == 1:
        val[v] = val[g[v][0]] & val[g[v][1]]
    elif typ[v] == 2:
        val[v] = val[g[v][0]] | val[g[v][1]]
    elif typ[v] == 3:
        val[v] = val[g[v][0]] ^ val[g[v][1]]
    else:
        val[v] = val[g[v][0]] ^ 1
val1 = val[0]
val2 = [0]*n
for v in range(n):
    if typ[v] == 0:
        continue
    elif typ[v] == 1:
        val2[v] = val2[g[v][0]] & val[g[v][1]] | val[g[v][0]] & val2[g[v][1]]
    elif typ[v] == 2:
        val2[v] = val2[g[v][0]] | val[g[v][1]] | val[g[v][0]] | val2[g[v][1]]
    elif typ[v] == 3:
        val2[v] = val2[g[v][0]] ^ val[g[v][1]] ^ val[g[v][0]] ^ val2[g[v][1]]
    else:
        val2[v] = val2[g[v][0]] ^ 1
for i in range(n):
    if typ[i] == 0:
        print((val1 ^ val2[0]) ^ (val[i] ^ 1), end='')
","import sys
n=int(input())
f={
 'AND':(lambda a:a[0]&a[1]),
 'OR':(lambda a:a[0]|a[1]),
 'XOR':(lambda a:a[0]^a[1]),
 'NOT':(lambda a:a[0]^1),
}
g={'0':(lambda a:0), '1':(lambda a:1)}
d=[(g[v[0]],[]) if o=='IN' else (f[o],[int(a)-1 for a in v]) for o,*v in map(str.split,sys.stdin.read().strip().split('\n'))]
t=[0]
for i in t:
 t.extend(d[i][1])
v=[0 for _ in range(n)]
for i in t[::-1]:
 o,a=d[i]
 v[i]=o([v[x] for x in a])
f=[0 for _ in range(n)]
f[0]=1
for i in t:
 if f[i]<1: continue
 o,a=d[i]
 b=[v[x]for x in a]
 assert o(b)==v[i]
 for j,k in enumerate(a):
  b[j]^=1
  f[k]=(o(b)!=v[i])
  b[j]^=1
print(''.join(str(f[i]^v[0]) for i in range(n) if not d[i][1]))",text_b
3976,"from collections import Counter
from sys import stdin, stdout

n, m, p = map(int, stdin.readline().split())
a = list(map(int, stdin.readline().split()))
b = list(map(int, stdin.readline().split()))

b_counter = Counter(b)
res = []
for i in range(p):
    a_counter = Counter(a[i:i + m * p:p])
    for j in range(i, n, p):
        if a_counter == b_counter:
            res.append(j // p - m + 2)
        if j + p < n:
            a_counter[a[j + p]] += 1
        a_counter[a[j]] -= 1
        if a_counter[a[j]] == 0:
            del a_counter[a[j]]
stdout.write(str(len(res)) + '\n' + ' '.join(map(str, sorted(res))) + '\n')
","from collections import defaultdict

n, m, p = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

u = defaultdict(int)
for i in b: u[i] += 1

ans = []
for q in range(p):
    c = a[q: n: p]
    if len(c) < m: break

    v = defaultdict(int)
    for i in c[: m]: v[i] += 1

    d = q + 1
    if u == v: ans.append(d)

    for j, k in zip(c[: len(c) - m], c[m: ]):
        v[j] -= 1
        if v[j] == 0: v.pop(j)
        v[k] += 1

        d += p
        if u == v: ans.append(d)

ans.sort()
print(len(ans))
print(' '.join(map(str, ans)))",text_b
3977,"from collections import defaultdict
n, m, k = map(int, input().split())
gov = list(map(int, input().split()))
edges = defaultdict(list)
for _ in range(m):
    u, v = map(int, input().split())
    edges[u].append(v)
    edges[v].append(u)
visited = [0]*(n+1)
comp = []
for node in gov:
    stack = [node]
    visited[node] = 1
    size = 0
    while stack:
        v = stack.pop()
        size += 1
        for u in edges[v]:
            if not visited[u]:
                visited[u] = 1
                stack.append(u)
    comp.append(size)
comp.sort()
comp[-1] += n - sum(comp)
print(sum(x*(x-1)//2 for x in comp) - m)
","def cin():
    return list(map(int, input().split()))

def dfs(n):
    if not C[n]:
        C[n]=True
        s[0]+=1
    for i in B[n]:
        if not C[i]:dfs(i)

n,m,k=cin()
A=cin()
A=[i-1 for i in A]
B=[list([]) for i in range(n)]
C=[False for i in range(n)]
ans=mx=0
for i in range(m):
    a,b=[i-1 for i in cin()]
    B[a].append(b)
    B[b].append(a)

for i in range(k):
    s=[0]
    dfs(A[i])
    ans+=s[0]*(s[0]-1)//2
    mx=max(mx,s[0])

ans-=mx*(mx-1)//2
for i in range(n):
    if not C[i]:
        s=[0]
        dfs(i)
        mx+=s[0]

print(ans-m+mx*(mx-1)//2)
",text_b
3978,"n = int(input())
a = list(map(int, input().split()))
a.sort()
cnt = [0]*101
for i in range(n):
    if cnt[a[i]] == 0:
        for j in range(a[i], 101, a[i]):
            cnt[j] = 1
print(sum(cnt))
","n = int(input())
A = list(map(int, input().split()))
A.sort()
B = [0] * n
ans = 0
for i in range(n):
    if B[i] == 0:
        ans += 1
        B[i] = 1
        for j in range(n):
            if A[j] % A[i] == 0:
                B[j] = 1
print(ans)",text_b
3979,"import sys
from collections import defaultdict
from heapq import *

n, m = map(int, input().split())
words = [list(map(int, input().split()))[1:] for _ in range(n)]
graph = defaultdict(list)
indegree = [0] * (m + 1)
outdegree = [0] * (m + 1)
capital = [0] * (m + 1)
for i in range(n - 1):
    a = words[i]
    b = words[i + 1]
    j = 0
    while j < len(a) and j < len(b) and a[j] == b[j]:
        j += 1
    if j == len(a) or j == len(b):
        if len(a) > len(b):
            print('No')
            sys.exit(0)
        continue
    if a[j] > b[j]:
        graph[b[j]].append(a[j])
        indegree[a[j]] += 1
    else:
        graph[a[j]].append(b[j])
        outdegree[a[j]] += 1
        capital[a[j]] = 1
queue = [i for i in range(1, m + 1) if indegree[i] == 0]
heapify(queue)
while queue:
    u = heappop(queue)
    for v in graph[u]:
        indegree[v] -= 1
        if indegree[v] == 0:
            heappush(queue, v)
    if capital[u] and outdegree[u]:
        print('No')
        sys.exit(0)
print('Yes')
print(sum(capital))
for i in range(1, m + 1):
    if capital[i]:
        print(i, end=' ')
","from collections import defaultdict, deque

def main():
    n,m = map(int, input().split())
    cap = [None]*(m+1)
    same_cap = defaultdict(list)
    q = deque()

    def apply_cap(a, c):
        if cap[a] is not None:
            return cap[a] == c
        q.append((a,c))
        while q:
            b = q.pop()
            if b[1] == c:
                if cap[b[0]] is None:
                    cap[b[0]] = c
                    q.extend(same_cap[b[0]])
                    same_cap[b[0]] = []
                elif cap[b[0]]!=c:
                    return False

        return True

    def same(a,b):
        same_cap[b].append((a,True))
        same_cap[a].append((b,False))

        if cap[a] == False:
            return apply_cap(b, False)

        if cap[b] == True:
            return apply_cap(a, True)

        return True

    def process(p,c):
        lp = p[0]
        lc = c[0]
        for i in range(1, min(lp,lc)+1):
            if p[i]>c[i]:
                return apply_cap(p[i], True) and apply_cap(c[i], False)
            if p[i]<c[i]:
                return same(p[i], c[i])
        return lp<=lc

    p = list(map(int, input().split()))
    for i in range(n-1):
        c = list(map(int, input().split()))
        if not process(p, c):
            print ('No')
            break
        p = c
    else:
        print ('Yes')
        res = []
        for i,b in enumerate(cap):
            if b:
                res.append(i)
        print(len(res))
        print(' '.join(map(str,res)))

main()",text_b
3980,"def solve(n):
    a = [0]*(n+1)
    b = [0]*(n+1)
    for i in range(n+1):
        a[i] = i
    for i in range(n, -1, -1):
        if b[i] == 0:
            j = i
            while a[j] != i:
                b[j] = a[j]
                j = a[j]
            b[j] = i
    return sum(b), b

n = int(input())
m, b = solve(n)
print(m)
print(*b)
","n = int(input())
p = [i for i in range(n + 1)]

k = 1
while(2 * k <= n):
  k *= 2
m = n + 1
while m > 0:
  while k >= m:
    k //= 2
  for i in range(m - k):
    if k - i - 1 >= 0:
      p[k + i], p[k - i - 1] = p[k - i - 1], p[k + i]
  m = k - i - 1

print(n * (n + 1))
print(' '.join(map(str, p)))",text_b
3981,"from sys import stdin, stdout
from math import atan2, pi
from operator import itemgetter
from itertools import groupby
from collections import Counter

def read():
    return stdin.readline().strip()

def read_ints():
    return list(map(int, read().split()))

def solve():
    n, m = read_ints()
    a = [read_ints() for _ in range(n)]
    b = [read_ints() for _ in range(m)]
    a = sorted([(atan2(y, x) + pi) % (2 * pi) for x, y in a])
    b = sorted([(atan2(y, x) + pi) % (2 * pi) for x, y in b])
    a = a + [x + 2 * pi for x in a]
    b = b + [x + 2 * pi for x in b]
    j = 0
    for i in range(n):
        while a[i] > b[j]:
            j += 1
        if a[i] + pi <= b[j]:
            return False
    return True

def main():
    stdout.write('YES\n' if solve() else 'NO\n')

main()
","import sys


# > 0 anti-clock, < 0 clockwise, == 0 same line
def orientation(p1, p2, p3):
    return (p2[0] - p1[0])*(p3[1] - p1[1]) - (p2[1] - p1[1])*(p3[0] - p1[0])


def dot(p1, p2, p3, p4):
    return (p2[0]-p1[0])*(p4[0]-p3[0]) + (p2[1]-p1[1])*(p4[1]-p3[1])


def theta(p1, p2):
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    if abs(dx) < 0.1 and abs(dy) < 0.1:
        t = 0
    else:
        t = dy/(abs(dx) + abs(dy))
        if abs(t) < 0.1 ** 10:
            t = 0
    if dx < 0:
        t = 2 - t
    elif dy < 0:
        t = 4 + t

    return t*90


def dist_sq(p1, p2):
    return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])


def chull(points):
    # let 0 element to be smallest, reorder elements
    pi = [x for x in range(len(points))]
    min_y = points[0][1]
    min_x = points[0][0]
    min_ind = 0
    for i in range(len(points)):
        if points[i][1] < min_y or points[i][1] == min_y and points[i][0] < min_x:
            min_y = points[i][1]
            min_x = points[i][0]
            min_ind = i
    pi[0] = min_ind
    pi[min_ind] = 0
    th = [theta(points[pi[0]], points[x]) for x in range(len(points))]
    pi.sort(key=lambda x: th[x])
    # process equals
    unique = [pi[0], pi[1]]
    for i in range(2, len(pi)):
        if th[pi[i]] != th[unique[-1]]:
            unique.append(pi[i])
        else:
            if dist_sq(points[pi[0]], points[unique[-1]]) < dist_sq(points[pi[0]], points[pi[i]]):
                unique[-1] = pi[i] # put max
    pi = unique
    stack = []
    for i in range(min(len(pi), 3)):
        stack.append(points[pi[i]])
    if len(stack) < 3:
        return stack
    for i in range(3, len(pi)):
        while len(stack) >= 2:
            o = orientation(stack[-2], stack[-1], points[pi[i]])
            if o > 0:
                stack.append(points[pi[i]])
                break
            elif o < 0:
                stack.pop()
            else:  # ==
                if dist_sq(stack[-2], stack[-1]) < dist_sq(stack[-2], points[pi[i]]):
                    stack.pop()
                else:
                    break  # skip i-th point
    return stack


def z_func(s):
    slen, l, r = len(s), 0, 0
    z = [0]*slen
    z[0] = slen
    for i in range(1, slen):
        if i <= r: z[i] = min(r-i+1, z[i-l])
        while i+z[i] < slen and s[z[i]] == s[i+z[i]]: z[i] += 1
        if i+z[i]-1 > r: l, r = i, i+z[i]-1
    return z

n,m = map(int, sys.stdin.readline().strip().split())
a = []
for _ in range(n):
    x,y = map(int, sys.stdin.readline().strip().split())
    a.append((x, y))
b = []
for _ in range(m):
    x, y = map(int, sys.stdin.readline().strip().split())
    b.append((x, y))

ah = chull(a)
bh = chull(b)
if len(ah) == len(bh):
    if len(ah) == 2:
        if dist_sq(ah[0], ah[1]) == dist_sq(bh[0], bh[1]):
            print('YES')
        else:
            print('NO')
    else:
        da = []
        for i in range(len(ah)):
            dot_a = dot(ah[i-2], ah[i-1], ah[i-1], ah[i])
            da.append((dist_sq(ah[i], ah[i-1]), dot_a))
        db = []
        for i in range(len(bh)):
            dot_b = dot(bh[i - 2], bh[i - 1], bh[i - 1], bh[i])
            db.append((dist_sq(bh[i], bh[i-1]), dot_b))
        l = r = 0
        daab = []
        daab.extend(db)
        daab.append(-1)
        daab.extend(da)
        daab.extend(da)
        zab = z_func(daab)
        found = False
        for i in range(len(db)+1, len(daab)-len(db)+1):
            if zab[i] == len(db):
                found = True
                break
        if found:
            print('YES')
        else:
            print('NO')
else:
    print('NO')",text_b
3982,"MOD = 10**9 + 7
m = int(input())
dp = [0]*3005
dp[0] = 1
for i in range(1, 3005):
    dp[i] = dp[i-1]
    if i >= 2:
        dp[i] += dp[i-2]
    if i >= 3:
        dp[i] += dp[i-3]
    if i >= 4:
        dp[i] += dp[i-4]
    dp[i] %= MOD
s = [0]*3005
s[0] = 1
for i in range(1, 3005):
    s[i] = s[i-1] + dp[i]
    s[i] %= MOD
a = [0]*3005
b = [0]*3005
for _ in range(m):
    c = int(input())
    if c == 0:
        a = [0] + a[:-1]
    else:
        b = [0] + b[:-1]
    a[0] = s[b[0]]
    b[0] = s[a[0]]
    print((s[a[0] + b[0]] - a[1] - b[2] - a[3] - b[4] + 5*MOD) % MOD)
","MOD = 10 ** 9 + 7
BAD = ([0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1])

def zfunc(s):
    z = [0] * len(s)
    l = r = 0
    for i in range(1, len(s)):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    return z

n = int(input())
s = []
sm = 0
for i in range(1, n + 1):
    s.append(int(input()))
    cur = 0
    f = [0] * (i + 1)
    sum4 = f[i] = 1
    for j in range(i - 1, -1, -1):
        if j + 4 < i:
            sum4 -= f[j + 5]
        if j + 4 <= i and s[j : j + 4] in BAD:
            f[j] -= f[j + 4]
        f[j] = (f[j] + sum4) % MOD
        sum4 += f[j]
    z = zfunc(s[::-1])
    new = i - max(z)
    sm = (sm + sum(f[:new])) % MOD
    print(sm)
",text_b
3983,"import sys
from collections import deque
input = sys.stdin.readline
def bfs():
    dist = [-1]*n
    dist[0] = 0
    q = deque([0])
    while q:
        v = q.popleft()
        for nv in g[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                q.append(nv)
    return dist
t = int(input())
for _ in range(t):
    n,m = map(int,input().split())
    g = [[] for _ in range(n)]
    for _ in range(m):
        a,b = map(int,input().split())
        a -= 1
        b -= 1
        g[a].append(b)
        g[b].append(a)
    dist = bfs()
    if dist[n-1]%2 == 0:
        print(""First"")
    else:
        print(""Second"")
","class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

import sys

input = sys.stdin.readline

for _ in range(int(input())):
    N,M = list(map(int,input().split()))
    uf = UnionFindVerSize(N)
    for _ in range(M):
        a,b = list(map(int,input().split()))
        uf.unite(a-1,b-1)

    if N%2==1:
        all = N*(N-1)//2-M
        if all%2==0:
            print(""Second"")
        else:
            print(""First"")
    else:
        all = N*(N-1)//2-M
        s1 = uf.get_size(0)
        sN = uf.get_size(N-1)
        if s1%2==sN%2:
            if s1%2==0:
                if all%2==0:
                    print(""Second"")
                else:
                    print(""First"")
            else:
                if all%2==1:
                    print(""Second"")
                else:
                    print(""First"")
        else:
            print(""First"")

#odd,even->even,even first
#odd,even->odd,odd first
#odd,odd->even,even second
#odd,odd->odd,odd first
#even,even->even,even first
#even,even->odd,odd second
",text_b
3984,"s = input()
min_char = s[0]
print('Mike')
for i in range(1, len(s)):
    if s[i] > min_char:
        print('Ann')
    else:
        print('Mike')
        min_char = min(min_char, s[i])
","s = input()
m = chr(ord('z') + 1)
ans = []
f = 0
for i in s:
    if i > m:
        ans.append('Ann')
    else:
        ans.append('Mike')
    m = min(m, i)
print('\n'.join(ans))",text_b
3985,"import sys
from collections import defaultdict
from math import sqrt

def solve():
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    g = defaultdict(list)
    for _ in range(m):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)
    vis = [0]*n
    ans = 0
    for i in range(n):
        if vis[i] == 0:
            vis[i] = 1
            q = [i]
            p = []
            while len(q) > 0:
                u = q.pop()
                p.append(a[u])
                for v in g[u]:
                    if vis[v] == 0:
                        vis[v] = 1
                        q.append(v)
            p.sort()
            for i in range(2, int(sqrt(p[0]))+1):
                while all(x%i == 0 for x in p):
                    p = [x//i for x in p]
                    ans += 1
            while all(x%2 == 0 for x in p):
                p = [x//2 for x in p]
                ans += 1
    print(ans)

solve()
","def g(i):
    u[i] = 0
    for j in p[i]:
        if v[j] < 0 or u[v[j]] and g(v[j]):
            v[j] = i
            return 1
    return 0

f = lambda: map(int, input().split())
n, m = f()
s = k = 0
d = [[]]
for i in f():
    j = 2
    t = []
    while j * j <= i:
        while i % j == 0:
            t.append((j, k))
            k += 1
            i //= j
        j += 1
    if i > 1:
        t.append((i, k))
        k += 1
    d.append(t)
p = [[] for i in range(k)]
for q in range(m):
    a, b = f()
    if b % 2: a, b = b, a
    for x, i in d[a]:
        for y, j in d[b]:
            if x == y: p[i].append(j)
v = [-1] * k
for i in range(k):
    u = [1] * k
    s += g(i)
print(s)",text_b
3986,"def find_string(n, k):
    if k > n or k == 1 and n > 1:
        return ""-1""
    elif k == 1 and n == 1:
        return ""a""
    else:
        base = ""ab"" * ((n - k + 2) // 2) + ""a"" * ((n - k + 2) % 2)
        extra = """".join(chr(97 + i) for i in range(2, k))
        return base + extra

n, k = map(int, input().split())
print(find_string(n, k))
","import string

rd = lambda: list(map(int, input().split()))

n, k = rd()
if k>26 or k>n or k==1 and n>1:
  print(-1)
elif k==1 and n==1:
  print('a')
else:
  print(('ab'*(n+1>>1))[:n-k+2]+string.ascii_lowercase[2:k])",text_b
3987,"n = int(input())
a = list(map(int, input().split()))
a = [0] + a
f = [[0]*2005 for _ in range(2005)]
g = [[0]*2005 for _ in range(2005)]
c = [0]*2005
d = [0]*2005
for i in range(1, n+1):
    c[i] = c[i-1] + (a[i] == 1)
    d[i] = d[i-1] + (a[i] == 2)
for i in range(1, n+1):
    for j in range(i, n+1):
        f[i][j] = max(f[i][j-1], c[i-1] + d[j] - d[i-1] + c[n] - c[j])
        g[i][j] = max(g[i][j-1], f[i][j] + d[n] - d[j])
print(g[1][n])
","n = int(input())
*A, = list(map(int, input().split()))

seq = []
cur = 1; cnt = 0
for a in A:
    if cur == a:
        cnt += 1
    else:
        seq.append(cnt)
        cur = a; cnt = 1
if cnt > 0:
    seq.append(cnt)
ans = max(seq)

l = len(seq)
dp = [[0]*4 for i in range(l+1)]
for i in range(l):
    one = i % 2 #12
    s = seq[i]
    for j in range(4):
        dp[i+1][j] = max(dp[i+1][j], dp[i][j])
        if not one: # 2
            if j % 2 == 0:
                dp[i+1][j] = max(dp[i+1][j], dp[i][j] + s)
            else:
                if j == 1:
                    dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + s)
        else: # 1
            if j % 2 == 1:
                dp[i+1][j] = max(dp[i+1][j], dp[i][j] + s)
            else:
                dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + s)
#    print(dp[i+1])
print(max(dp[l]))



",text_b
3988,"import sys
from collections import defaultdict

def dfs(v, p):
    used[v] = True
    for u in g[v]:
        if not used[u]:
            dfs(u, v)
            if p != -1 and (v, u) in undirected:
                ans[undirected[(v, u)]] = '+'
    if p != -1 and (p, v) in undirected:
        ans[undirected[(p, v)]] = '-'

def dfs2(v):
    used[v] = True
    for u in g[v]:
        if not used[u]:
            dfs2(u)
            if (v, u) in undirected:
                ans[undirected[(v, u)]] = '-'

n, m, s = map(int, sys.stdin.readline().split())
s -= 1
g = defaultdict(list)
undirected = {}
ans = [''] * m
used = [False] * n

for i in range(m):
    t, u, v = map(int, sys.stdin.readline().split())
    u -= 1
    v -= 1
    if t == 1:
        g[u].append(v)
    else:
        g[u].append(v)
        g[v].append(u)
        undirected[(u, v)] = i
        undirected[(v, u)] = i
        ans[i] = '+'

dfs(s, -1)
print(ans.count('+'))
print(''.join(ans))

used = [False] * n
for i in range(n):
    if i != s and not used[i]:
        dfs2(i)

print(ans.count('+'))
print(''.join(ans))
","def put():
  return list(map(int, input().split()))

def dfs(x,flag=1):
    s,vis,ans   = [x],[0]*n,['+']*m
    vis[x]= 1
    while s:
        i = s.pop()
        for j,k in graph[i]:
            if vis[j]==0:
                if k*flag<0:
                    ans[abs(k)-1]='-'
                elif k*flag>0:
                    ans[abs(k)-1]='+'
                if flag==1 or k==0:
                    s.append(j)
                    vis[j]=1
    return ''.join(ans), sum(vis)

n,m,s = put()
graph = [[] for i in range(n)]
k=1
for _ in range(m):
    z,x,y = put()
    x,y = x-1,y-1
    if z==1:
        graph[x].append((y, 0))
    else:
        graph[x].append((y, k))
        graph[y].append((x,-k))
        k+=1
m = k-1
x,y = dfs(s-1, 1)
print(y)
print(x)
x,y = dfs(s-1,-1)
print(y)
print(x)
",text_b
3989,"def solve():
    a = input().strip()
    a = sorted(a)
    a.remove('1')
    a.remove('6')
    a.remove('8')
    a.remove('9')
    a = ''.join(a)
    for i in range(7, 1000, 7):
        if i % 7 == 0 and str(i).find('0') == -1 and str(i).find('1') == -1 and str(i).find('6') == -1 and str(i).find('8') == -1 and str(i).find('9') == -1:
            b = str(i)
            break
    for i in range(len(a) + 1):
        if int(a[:i] + '1689' + a[i:] + b) % 7 == 0:
            print(a[:i] + '1689' + a[i:] + b)
            return
    print(0)

solve()
","def end(x) :
    if x == 0 :
        return ""1869"";
    if x == 6 :
        return ""1968"";
    if x == 5 :
        return ""1689"";
    if x == 4 :
        return ""6891"";
    if x == 3 :
        return  ""1689"";
    if x == 2 :
        return  ""1986"";
    if x == 1 :
        return  ""1896"";

d = [0] * 10;
for c in input() :
    d[int(c)] += 1;
for i in [1,6,8,9] :
    d[i] -= 1;

s = """";
ost = 0;

for i in range(10) :
    for j in range(d[i]):
        ost = (ost * 10 + i) % 7;

ost = (1869, 1896, 1986, 1698, 6198, 1689, 1968)[ost * 10000 % 7];

for c in (1,2,3,4,5,6,7,8,9) :
    s += str(c) * d[c];

print((s + str(ost) + ""0"" * d[0]));
",text_b
3990,"from collections import deque
def solve():
    n, m = map(int, input().split())
    g = [[0]*n for _ in range(n)]
    for _ in range(m):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        g[u][v] = g[v][u] = 1
    if g[0][n-1] == 1:
        g = [[1-x for x in row] for row in g]
    dist = [float('inf')]*n
    dist[0] = 0
    q = deque([0])
    while q:
        v = q.popleft()
        for u in range(n):
            if g[v][u] == 1 and dist[u] == float('inf'):
                dist[u] = dist[v] + 1
                q.append(u)
    if dist[n-1] == float('inf'):
        print(-1)
    else:
        print(dist[n-1])

solve()
","from collections import deque
n,m=map(int,input().split())
a=[set() for i in range(n+1)]
for i in range(m):
    x,y=map(int,input().split())  
    a[x].add(y)
    a[y].add(x)
if n not in a[1]:
    t=True
else:
    t=False
q=deque()
q.append(1)
z = [-1 for i in range(n+1)]
z[1] = 0
while len(q) > 0:
    v = q.popleft()
    for i in range(1, n+1):
        if t ^ (i in a[v]):
            continue
        if z[i]==-1:
            z[i]=z[v]+1
            q.append(i)
            if i == n:
                print(z[i])
                return
print(-1) ",text_b
3991,"def solve():
    n = int(input())
    x = sorted(map(int, input().split()))
    p = [1]
    for i in range(1, n):
        p.append(p[-1] * 2 % (10**9 + 7))
    ans = 0
    for i in range(n):
        ans = (ans + x[i] * (p[i] - p[n - i - 1])) % (10**9 + 7)
    print(ans)

solve()
","3
# Copyright (C) 2017 Sayutin Dmitry.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 3
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

def main():
    mod = 10 ** 9 + 7
    pws = [None for i in range(4 * (10 ** 5))]
    pws[0] = 1
    for i in range(1, (4 * (10 ** 5))):
        pws[i] = 2 * pws[i - 1] % mod
    
    n = int(input())
    seq = list(map(int, input().split()))

    seq.sort()
    
    ans = 0
    for i in range(n):
        ans += seq[i] * (pws[i] - 1)
        ans -= seq[i] * (pws[n - i - 1] - 1)
        ans = ans % mod
    print(ans)

main()
",text_b
3992,"import sys
from collections import deque
from math import sqrt

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    s = sum(a)
    divisors = []
    for i in range(2, int(sqrt(s))+1):
        if s % i == 0:
            divisors.append(i)
            while s % i == 0:
                s //= i
    if s > 1:
        divisors.append(s)
    ans = float('inf')
    for d in divisors:
        cur = 0
        for i in range(n):
            cur += a[i]
            a[i] %= d
            if a[i] > d // 2:
                a[i] -= d
            cur -= a[i]
        a.append(0)
        q = deque()
        res = 0
        for i in range(n+1):
            while a[i] < 0 and q:
                x, y = q.popleft()
                t = min(y, -a[i])
                res += t * (i - x)
                y -= t
                a[i] += t
                if y:
                    q.appendleft((x, y))
            if a[i] > 0:
                q.append((i, a[i]))
        ans = min(ans, res)
    print(ans if ans != float('inf') else -1)

solve()
","# 素因数分解
def prime_decomposition(n):
    i = 2
    table = []
    while i * i <= n:
        while n % i == 0:
            n //= i
            table.append(i)
        i += 1
    if n > 1:
        table.append(n)
    return table
import sys
input = sys.stdin.readline
N = int(input())
A = list(map(int, input().split()))
# かけらを移動させて共通因数を持つようにする
su = sum(A)
if su == 1:
    print(-1)
    return
primes = sorted(set(prime_decomposition(su)))
ans = 10**18

for p in primes:
    an = 0
    half = p >> 1
    cnt = 0
    for a in A:
        a %= p
        cnt += a
        if cnt <= half:
            an += cnt
        else:
            if cnt < p:
                an += p - cnt
            else:
                cnt -= p
                if cnt <= half:
                    an += cnt
                else:
                    an += p - cnt
        if ans <= an:
            break
    else:
        ans = min(ans, an)
print(ans)
",text_b
3993,"n, m, k = map(int, input().split())
p = list(map(int, input().split()))
p = [i-1 for i in p]
res = 0
cnt = 0
while p:
    page = (p[0]-cnt)//k
    while p and (p[0]-cnt)//k == page:
        p.pop(0)
        cnt += 1
    res += 1
print(res)
","n,m,k = list(map(int,input().split()))

l = list(map(int,input().split()))

out = 0
d = 0

while m > d:
    nex = l[d]
    page = (nex - d - 1)//k
    add = 1
    while d + add < m and (page * k) < l[d + add] - d  <= (page + 1) * k:
        add += 1
    d += add
    out += 1

print(out)
    
",text_b
3994,"n = int(input())
s = list(map(int, list(input())))
a = [0]*10000
for i in range(n):
    x, y = map(int, input().split())
    for j in range(y, 10000, x):
        a[j] += 1
    for j in range(y):
        a[j] += s[i]
print(max(a))
","n = int(input())
s = input()
used = [0] * n
for i in range(n):
  if s[i] == '0':
    used[i] = False
  else:
    used[i] = True
a = [0] * n
b = [0] * n
for i in range(n):
  a[i], b[i] = list(map(int, input().split()))

ans = 0
for time in range(500):
  for i in range(n):
    if time >= b[i] and (time - b[i]) % a[i] == 0:
      used[i] = not used[i]
  cnt = 0
  for i in range(n):
    if used[i]:
      cnt += 1
  ans = max(ans, cnt)
print(ans)
",text_b
3995,"n, k = map(int, input().split())
s = ""10"" * ((n - k) // 2 + 1) + ""1"" * ((n - k) % 2)
print(s[:n])
","n,k=list(map(int,input().split()))

x=(n-(k-1)+1)//2
STR=""0""*(x-1)+""1""

ANS=STR*(n//x+1)
print(ANS[:n])
",text_b
3996,"MOD = 10**9+7
def power(x, y):
    if y == 0:
        return 1
    elif y % 2 == 0:
        return power(x, y // 2)**2 % MOD
    else:
        return x * power(x, y // 2)**2 % MOD

k = int(input())
a = list(map(int, input().split()))
n = 1
for i in range(k):
    n = n * a[i] % (MOD - 1)
print(power(3, n) * power(power(3, MOD - 2), 2) % MOD, '/', power(3, 2) % MOD, sep='')
","3

class Matrix:
    def __init__(self, n, m, arr=None):
        self.n = n
        self.m = m
        self.arr = [[0] * m for i in range(n)]
        if arr is not None:
            for i in range(n):
                for j in range(m):
                    self.arr[i][j] = arr[i][j]

    def __mul__(self, other):
        assert self.m == other.n
        ans = Matrix(self.n, other.m)
        for i in range(self.n):
            for j in range(other.m):
                for k in range(self.m):
                    ans.arr[i][j] = (ans.arr[i][j] + self.arr[i][k] * other.arr[k][j]) % (10 ** 9 + 7)
        return ans

    def __imul__(self, other):
        self = self * other
        return self

    def __pow__(self, n):
        if n == 0:
            ans = Matrix(self.n, self.n)
            for i in range(self.n):
                ans.arr[i][i] = 1
            return ans
        elif n & 1 == 1:
            return self * (self ** (n - 1))
        else:
            t = self ** (n >> 1)
            return t * t

    def __ipow__(self, n):
        self = self ** n
        return self

    def __eq__(self, other):
        if self.n != other.n or self.m != other.m:
            return False
        for i in range(self.n):
            for j in range(self.m):
                if self.arr[i][j] != other.arr[i][j]:
                    return False
        return True


def fpow(a, n):
    if n == 0:
        return 1
    elif n & 1 == 1:
        return (a * fpow(a, n - 1)) % (10 ** 9 + 7)
    else:
        t = fpow(a, n >> 1)
        return (t * t) % (10 ** 9 + 7)


transform = Matrix(2, 2, [[1, 1], [0, 4]])
mtx = transform

k = int(input())
a = list(map(int, input().split()))
""""""
f = False
for j in a:
    if j % 2 == 0:
        f = True
        break
if f:
    print(a)
    tp = 1
    for j in a:
        if f and j % 2 == 0:
            j //= 2
            f = False
        print(j)
        mtx **= j
    ans = Matrix(2, 1, [[0], [1]])
    ans = mtx * ans
    print(ans.arr)
    print(""%d/%d"" % (ans.arr[0][0], ans.arr[1][0]))
""""""

x = 1
for j in a:
    x = (x * j) % (10 ** 9 + 6)

x = (x - 1) % (10 ** 9 + 6)

if x % 2 == 0:
    ans = (transform ** (x // 2)) * Matrix(2, 1, [[0], [1]])
    print(""%d/%d"" % (ans.arr[0][0], fpow(2, x)))
else:
    y = (x - 1) % (10 ** 9 + 6)
    ans = (transform ** (y // 2)) * Matrix(2, 1, [[0], [1]])
    print(""%d/%d"" % ((ans.arr[0][0] * 2 + 1) % (10 ** 9 + 7), (ans.arr[1][0] * 2) % (10 ** 9 + 7)))
    
",text_b
3997,"import sys
from bisect import bisect_right
input = sys.stdin.readline

def add_edge(u, v, w):
    G[u].append((v, w))
    G[v].append((u, w))

def dfs(v, p, d):
    dp[v] = bisect_right(D, d - a[v]) - 1
    D.append(d)
    for to, cost in G[v]:
        if to == p:
            continue
        dfs(to, v, d + cost)
    D.pop()
    if dp[v] != -1:
        dp[v] = dp[D[dp[v]]]
    dp[D[dp[v] + 1]] = v

n = int(input())
a = list(map(int, input().split()))
G = [[] for _ in range(n)]
dp = [-1] * n
D = [-10**18]
for i in range(n - 1):
    p, w = map(int, input().split())
    p -= 1
    add_edge(p, i + 1, w)
dfs(0, -1, 0)
for i in range(n):
    print(i - dp[i])
","import sys
import threading
from bisect import bisect_left

n   = int(input())
a   = list(map(int, input().split()))
e   = {}
g   = [[] for i in range(n)]
d   = [0]*(n+5)
ans = [0]*n
p   = [0]*(n+5)

for i in range(n-1):
        c, w = map(int, input().split())
        c-= 1
        g[c].append(i+1)
        e[i+1] = w

def dfs(i, h):
    nonlocal ans, a, e, g, d, p
    p[h]=0
    for j in g[i]:
        d[h+1] = d[h]+e[j] 
        dfs(j, h+1)
    x = bisect_left(d, d[h]-a[i], 0, h+1)
    #print(x-1, i, h, d[h], d[h], a[i])
    if x>=0:
        p[x-1]-=1
    p[h-1]+=p[h]+1
    ans[i]=p[h]



def solve():  
    nonlocal ans
    dfs(0, 0)
    print(' '.join(map(str, ans)))

max_recur_size = 10**5*2 + 1000
max_stack_size = max_recur_size*500
sys.setrecursionlimit(max_recur_size)
threading.stack_size(max_stack_size)
thread = threading.Thread(target=solve)
thread.start()",text_b
3998,"from heapq import *
n = int(input())
a = list(map(int,input().split()))
b = [(-a[i],i+1) for i in range(n)]
heapify(b)
c = []
while b[0][0] != b[-1][0]:
    d = []
    for i in range(min(5,len(b))):
        x = heappop(b)
        d.append(x[1])
        if x[0] != 0:
            heappush(b,(x[0]+1,x[1]))
    c.append(d)
print(-b[0][0])
print(len(c))
for x in c:
    d = [0]*n
    for y in x:
        d[y-1] = 1
    print(''.join(map(str,d)))
","n = int(input())
L = list(map(int, input().split()))
ans = 0
M = []
while max(L) != min(L):
    ans += 1
    k = max(L)
    if L.count(k) == 3:
        s = ''
        for i in range(len(L)):
            if L[i] == k:
                s += '1'
                L[i] -= 1
            else:
                s += '0'
        M.append(s)    
    else:      
        max_1 = 0
        max_2 = 1
        if L[max_1] < L[max_2]:
            max_1, max_2 = max_2, max_1
        for i in range(2, n):
            if L[i] > L[max_1]:
                max_2, max_1 = max_1, i
            elif L[i] > L[max_2]:
                max_2 = i
        s = ''
        for i in range(n):
            if i == max_1 or i == max_2:
                s += '1'
            else:
                s += '0'
        M.append(s)
        L[max_1] -= 1
        if L[max_1] < 0:
            L[max_1] = 0
        L[max_2] -= 1
        if L[max_2] < 0:
            L[max_2] = 0
print(max(L))
print(ans)
for i in M:
    print(i)",text_b
3999,"import sys
from collections import defaultdict
from math import factorial
from operator import mul
from functools import reduce

def comb(n, r):
    if n < r: return 0
    return factorial(n) // (factorial(n - r) * factorial(r))

def solve():
    N = int(input())
    C = [list(map(int, input().split())) for _ in range(N)]
    for c in C:
        c.sort()
    C.sort()
    color = defaultdict(int)
    for c in C:
        for x in c:
            color[x] += 1
    dp = [0] * (N + 1)
    dp[0] = 1
    used = defaultdict(int)
    for i in range(N):
        while i < N and C[i] == C[i - 1]:
            i += 1
        x = [color[c] for c in C[i - 1]]
        for j in range(i - 1, -1, -1):
            dp[j + 1] += dp[j] * comb(x[0], i - j) * comb(x[1] - x[0], i - j) * comb(x[2] - x[1], i - j) * comb(x[3] - x[2], i - j)
            dp[j + 1] %= mod
            for k in range(4):
                x[k] -= 1
        for c in C[i - 1]:
            color[c] -= i
        used[tuple(C[i - 1])] += 1
    ans = dp[6]
    for v in used.values():
        for i in range(1, v + 1):
            ans = ans * i % mod
    print(ans)

mod = 10**9 + 7
solve()
","from collections import defaultdict
N, = list(map(int, input().split()))

def normal(xs):
    return tuple(min((xs[j:] + xs[:j] for j in range(1, 5))))

dd = defaultdict(int)
cc = dict()
norm = dict()
ss = []
for _ in range(N):
    xs = list(map(int, input().split()))
    cnd = [tuple(xs[j:] + xs[:j]) for j in range(1, 5)]
    x = min(cnd)
    for item in cnd:
        norm[item] = x
    dd[x] += 1
    cc[x] = (4 if x[0] == x[1] else 2)if x[0] == x[2] and x[1] == x[3] else 1
    ss.append(x)

def icr(x):
    dd[x] += 1

def dcr(x):
    dd[x] -= 1

def f(ff, gg):
    a,b,c,d=ff
    e,h,g,f=gg
    tl = [(a,e,f,b), (b,f,g,c), (c,g,h,d), (d,h,e,a)]
    for cp in tl:
        if cp not in norm:
            return 0
    r = 1
    for cp in tl:
        cp = norm[cp]
        r *= dd[cp]*cc[cp]
        dcr(cp)
    for cp in tl:
        cp = norm[cp]
        icr(cp)
    return r

r = 0
for i in range(N):
    ff = ss[i]
    dcr(ff)
    for j in range(i+1, N):
        sl = ss[j]
        dcr(sl)
        x, y, z, w = sl
        sls = [(x,y,z,w), (y,z,w,x), (z,w,x,y), (w,x,y,z)]
        for s in sls:
            r += f(ff, s)
        icr(sl)
    icr(ff)
print((r//3))
",text_b
