{
    "3689": {
        "original_negative_solution": "import sys\n\nn, k = sys.stdin.readline().strip().split()\nn = int(n)\nk = int(k)\nx = sys.stdin.readline().strip()\nX = [0] * n\nfor i in range (0, n):\n    X[i] = int(x[i])\nv = 0\nw = 0\nfor i in range (0, n):\n    if v == 0 and (X[i] > X[i % k]):\n        v = -1\n    elif v == 0 and (X[i] < X[i % k]):\n        v = 1\nans = []\nif v == -1:\n    i = k - 1\n    while X[i] == 9:\n        i = i - 1\n    while i < k:\n        X[i] = (X[i] + 1) % 10\n        i = i + 1\nfor i in range (0, n):\n    ans.append(str(X[i % k]))\nprint(n)\nprint(\"\".join(ans))\n",
        "negative_solution": "import sys\n\nn, k = sys.stdin.readline().strip().split()\nn = int(n)\nk = int(k)\nx = sys.stdin.readline().strip()\nX = [0] * n\nfor i in range (0, n):\n    X[i] = int(x[i])\nv = 0\nw = 0\nfor i in range (0, n):\n    if v == 0 and (X[i] > X[i % k]):\n        v = -1\n    elif v == 0 and (X[i] < X[i % k]):\n        v = 1\nans = []\nif v == -1:\n    i = k - 1\n    while X[i] == 9:\n        i = i + 1\n    while i < k:\n        X[i] = (X[i] + 1) % 10\n        i = i + 1\nfor i in range (0, n):\n    ans.append(str(X[i % k]))\nprint(n)\nprint(\"\".join(ans))\n"
    },
    "3690": {
        "original_negative_solution": "h,m,s,t1,t2 = list(map(int,input().split()))\nh %= 12\narr = []\narr.append(h*30 + m/2 + s/120)\narr.append(6*m + s/10)\narr.append(6*s)\narr.sort()\narr = arr + [(360 + arr[0])]\n\nt1 *= 30\nt2 *= 30\n\nx1 = -1\nx2 = -1\nfor i in range(3):\n\tif((arr[i] <= t1 and t1 <= arr[i+1]) or (arr[i] <= t1+360 and t1+360 <= arr[i+1])):\n\t\tx1 = i\n\tif((arr[i] <= t2 and t2 <= arr[i+1]) or (arr[i] <= t2+360 and t2+360 <= arr[i+1])):\n\t\tx2 = i\n\nprint('YES' if x1==x2 else 'NO')\n",
        "negative_solution": "h,m,s,t1,t2 = list(map(int,input().split()))\nh %= 12\narr = []\narr.append(h*30 + m/2 + s/120)\narr.append(6*m + s/10)\narr.append(6*s)\narr.sort()\narr = arr + [(360 + arr[0])]\n\nt1 *= 30\nt2 *= 60\n\nx1 = -1\nx2 = -1\nfor i in range(3):\n\tif((arr[i] <= t1 and t1 <= arr[i+1]) or (arr[i] <= t1+360 and t1+360 <= arr[i+1])):\n\t\tx1 = i\n\tif((arr[i] <= t2 and t2 <= arr[i+1]) or (arr[i] <= t2+360 and t2+360 <= arr[i+1])):\n\t\tx2 = i\n\nprint('YES' if x1==x2 else 'NO')\n"
    },
    "3691": {
        "original_negative_solution": "import sys\nreadline = sys.stdin.readline\n\ndef mhd(A, B):\n    return abs(A[0]-B[0]) + abs(A[1]-B[1])\n\nx0, y0, ax, ay, bx, by = map(int, readline().split())\nxs, ys, T = map(int, readline().split())\n\nPoints = [(x0, y0)]\n\nfor _ in range(100):\n    xp, yp = Points[-1]\n    Points.append((xp*ax+bx, yp*ay+by))\n\nans = 0\npre = (xs, ys)\nfor st in range(100):            \n    L = mhd(pre, Points[st])\n    if L > T:\n        continue\n    res = 1\n    for j in range(st+1, 100):\n        L += mhd(Points[j-1], Points[j])\n        if L > T:\n            break\n        res += 1\n    ans = max(ans, res)\n    res = 1\n    L = mhd(pre, Points[st])\n    for j in range(st-1, -1, -1):\n        L += mhd(Points[j+1], Points[j])\n        if L > T:\n            break\n        res += 1\n    ans = max(ans, res)\nprint(ans)",
        "negative_solution": "import sys\nreadline = sys.stdin.readline\n\ndef mhd(A, B):\n    return abs(A[0]-B[0]) + abs(A[1]-B[1])\n\nx0, y0, ax, ay, bx, by = map(int, readline().split())\nxs, ys, T = map(int, readline().split())\n\nPoints = [(x0, y0)]\n\nfor _ in range(100):\n    xp, yp = Points[-1]\n    Points.append((xp*ax+bx, yp*ay+by))\n\nans = 0\npre = (xs, ys)\nfor st in range(100):            \n    L = mhd(pre, Points[st])\n    if L <= T:\n        continue\n    res = 1\n    for j in range(st+1, 100):\n        L += mhd(Points[j-1], Points[j])\n        if L <= T:\n            break\n        res += 1\n    ans = max(ans, res)\n    res = 1\n    L = mhd(pre, Points[st])\n    for j in range(st-1, -1, -1):\n        L += mhd(Points[j+1], Points[j])\n        if L <= T:\n            break\n        res += 1\n    ans = max(ans, res)\nprint(ans)"
    },
    "3692": {
        "original_negative_solution": "from math import sqrt\npt = lambda *a, **k: print(*a, **k, flush=True)\nrd = lambda: map(int, input().split())\nn = int(input())\ndef f(x1, y1, r1, x2, y2, r2):\n    a = (r1 + r2) ** 2\n    b = (r1 - r2) ** 2\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > a:\n        return 1\n    elif d == a:\n        return 4\n    elif d < b:\n        return 3\n    elif d == b:\n        return 5\n    else:\n        return 2\ndef g(x1, y1, r1, x2, y2, r2):\n    ds = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    d = sqrt(ds)\n    A = (r1 ** 2 - r2 ** 2 + ds) / (2 * d)\n    h = sqrt(r1 ** 2 - A ** 2)\n    x = x1 + A * (x2 - x1) / d  \n    y = y1 + A * (y2 - y1) / d\n    x3 = x - h * (y2 - y1) / d  \n    y3 = y + h * (x2 - x1) / d\n    x4 = x + h * (y2 - y1) / d  \n    y4 = y - h * (x2 - x1) / d\n    return x3, y3, x4, y4 \nif n is 1:\n    pt(2)\nif n is 2:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    pt(4 if a is 2 else 3)\nif n is 3:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    x3, y3, r3 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    b = f(x1, y1, r1, x3, y3, r3)\n    c = f(x3, y3, r3, x2, y2, r2)\n    t = [a, b, c]\n    t.sort()\n    a, b, c = t\n    if a is 1 and b is 1 and c in [1, 3, 4, 5]:\n        pt(4)\n    if a is 1 and b is 1 and c is 2:\n        pt(5)\n    if a is 1 and b is 2 and c is 2:\n        pt(6)\n    if a is 1 and b is 2 and c in [3, 4, 5]:\n        pt(5)\n    if a is 1 and b in [3, 4, 5]:\n        pt(4)\n    if a is 2 and b is 2 and c is 2:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        r = 8\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        pt(r)\n    if a is 2 and b is 2 and c is 3:\n        pt(6)\n    if a is 2 and b is 2 and c in [4, 5]:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            pt(6)\n        else:\n            pt(7)\n    if a is 2 and b is 3:\n        pt(5)\n    if a is 2 and b in [4, 5]:\n        pt(6)\n    if a is 3 and b in [3, 4, 5]:\n        pt(4)\n    if a is 4 and b is 4 and c is 4:\n        pt(5)\n    if a is 4 and b is 4 and c is 5:\n        pt(4)\n    if a is 4 and b is 5 and c is 5:\n        pt(5)\n    if a is 5 and b is 5 and c is 5:\n        pt(4)\n",
        "negative_solution": "from math import sqrt\npt = lambda *a, **k: print(*a, **k, flush=True)\nrd = lambda: map(int, input().split())\nn = int(input())\ndef f(x1, y1, r1, x2, y2, r2):\n    a = (r1 + r2) ** 2\n    b = (r1 - r2) ** 2\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > a:\n        return 1\n    elif d == a:\n        return 4\n    elif d < b:\n        return 3\n    elif d == b:\n        return 5\n    else:\n        return 2\ndef g(x1, y1, r1, x2, y2, r2):\n    ds = (x1 - x2) + (y1 - y1)\n    d = sqrt(ds)\n    A = (r1 ** 2 - r2 ** 2 + ds) / (2 * d)\n    h = sqrt(r1 ** 2 - A ** 2)\n    x = x1 + A * (x2 - x1) / d  \n    y = y1 + A * (y2 - y1) / d\n    x3 = x - h * (y2 - y1) / d  \n    y3 = y + h * (x2 - x1) / d\n    x4 = x + h * (y2 - y1) / d  \n    y4 = y - h * (x2 - x1) / d\n    return x3, y3, x4, y4 \nif n is 1:\n    pt(2)\nif n is 2:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    pt(4 if a is 2 else 3)\nif n is 3:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    x3, y3, r3 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    b = f(x1, y1, r1, x3, y3, r3)\n    c = f(x3, y3, r3, x2, y2, r2)\n    t = [a, b, c]\n    t.sort()\n    a, b, c = t\n    if a is 1 and b is 1 and c in [1, 3, 4, 5]:\n        pt(4)\n    if a is 1 and b is 1 and c is 2:\n        pt(5)\n    if a is 1 and b is 2 and c is 2:\n        pt(6)\n    if a is 1 and b is 2 and c in [3, 4, 5]:\n        pt(5)\n    if a is 1 and b in [3, 4, 5]:\n        pt(4)\n    if a is 2 and b is 2 and c is 2:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        r = 8\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        pt(r)\n    if a is 2 and b is 2 and c is 3:\n        pt(6)\n    if a is 2 and b is 2 and c in [4, 5]:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            pt(6)\n        else:\n            pt(7)\n    if a is 2 and b is 3:\n        pt(5)\n    if a is 2 and b in [4, 5]:\n        pt(6)\n    if a is 3 and b in [3, 4, 5]:\n        pt(4)\n    if a is 4 and b is 4 and c is 4:\n        pt(5)\n    if a is 4 and b is 4 and c is 5:\n        pt(4)\n    if a is 4 and b is 5 and c is 5:\n        pt(5)\n    if a is 5 and b is 5 and c is 5:\n        pt(4)\n"
    },
    "3693": {
        "original_negative_solution": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nax1=min(a[::2])\nax2=max(a[::2])\nay1=min(a[1::2])\nay2=max(a[1::2])\n\nbx1=min(b[::2])\nbx2=max(b[::2])\nby=0\nfor i in range(4):\n    if b[i*2]==bx1:\n        by=b[i*2+1]\n\nhas=0\nfor i in range(ax1,ax2+1):\n    for j in range(ay1,ay2+1):\n        # check this point\n        if i<bx1 or i>bx2: continue\n        if bx1<=i<=(bx1+bx2)//2 and abs(j-by)<=abs(i-bx1):\n            has=1\n        if (bx1+bx2)//2<=i<=bx2 and abs(j-by)<=abs(i-bx2):\n            has=1\nprint(\"YES\" if has else \"NO\")\n",
        "negative_solution": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nax1=min(a[::2])\nax2=max(a[::2])\nay1=min(a[1::2])\nay2=max(a[1::2])\n\nbx1=min(b[::2])\nbx2=max(b[::2])\nby=0\nfor i in range(4):\n    if b[i*2]==bx1:\n        by=b[i*2+1]\n\nhas=0\nfor i in range(ax1,ax2+1):\n    for j in range(ay1,ay2+1):\n        # check this point\n        if i<bx1 or i>bx2: continue\n        if bx1<=i<=(bx1+bx2)*2 and abs(j-by)<=abs(i-bx1):\n            has=1\n        if (bx1+bx2)//2<=i<=bx2 and abs(j-by)<=abs(i-bx2):\n            has=1\nprint(\"YES\" if has else \"NO\")\n"
    },
    "3694": {
        "original_negative_solution": "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\na.sort()\n\nif n == 1:\n    if a[0] % 2 == 1:\n        v = True\n    else:\n        v = False\nelse:\n    v = True\n    c = 0\n    for i in range (0, n-1):\n        if a[i] == a[i + 1]:\n            c = c + 1\n            j = i\n    if c > 1:\n        v = False\n    elif c == 1:\n        if a[j] == 0:\n            v = False\n        if j > 0:\n            if a[j-1] + 1 == a[j]:\n                v = False\n    if (sum(a) - (n * (n - 1)) // 2) % 2 == 0:\n        v = False\n\nif v == True:\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")\n",
        "negative_solution": "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\na.sort()\n\nif n == 1:\n    if a[0] % 2 == 1:\n        v = True\n    else:\n        v = False\nelse:\n    v = True\n    c = 0\n    for i in range (0, n-1):\n        if a[i] == a[i + 1]:\n            c = c + 1\n            j = i\n    if c > 1:\n        v = False\n    elif c == 1:\n        if a[j] == 0:\n            v = False\n        if j > 0:\n            if a[j-1] + 1 == a[j]:\n                v = False\n    if (sum(a) - (n * n) // 2) % 2 == 0:\n        v = False\n\nif v == True:\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")\n"
    },
    "3695": {
        "original_negative_solution": "from heapq import heappush, heappop\n\nn, m = [int(i) for i in input().split()]\nfood = 0\ntummy = []\ndish = [ -int(i) for i in input().split()]\nfor i in range(1, min(m, n+1)):\n    while tummy and -tummy[0] >= m- i:\n        heappop(tummy)\n    if max(-dish[i-1], i) < m:\n        heappush(tummy, dish[i-1] + i)\n    food = max(len(tummy), food)\nprint(food)\n",
        "negative_solution": "from heapq import heappush, heappop\n\nn, m = [int(i) for i in input().split()]\nfood = 0\ntummy = []\ndish = [ -int(i) for i in input().split()]\nfor i in range(1, min(m, n+1)):\n    while tummy and -tummy[0] >= m- i:\n        heappop(tummy)\n    if max(dish[i-1], i) < m:\n        heappush(tummy, dish[i-1] + i)\n    food = max(len(tummy), food)\nprint(food)\n"
    },
    "3696": {
        "original_negative_solution": "# python3\n# utf-8\n\nn = int(input())\nA = [1]\nB = []\nfor _ in range(n):\n    new_A = [0] + A[:]\n    new_B = A[:]\n    for i, b in enumerate(B):\n        new_A[i] += b\n    A = [a % 2 for a in new_A]\n    B = [b % 2 for b in new_B]\nprint(len(A) - 1)\nprint(*A)\nprint(len(B) - 1)\nprint(*B)\n",
        "negative_solution": "# python3\n# utf-8\n\nn = int(input())\nA = [1]\nB = []\nfor _ in range(n):\n    new_A = [0] + A[:]\n    new_B = A[:]\n    for i, b in enumerate(B):\n        new_A[i] += b\n    A = [a % 2 for a in new_A]\n    B = [b % 2 for b in new_B]\nprint(len(A))\nprint(*A)\nprint(len(B))\nprint(*B)\n"
    },
    "3697": {
        "original_negative_solution": "from copy import deepcopy\nn, k, m, a = [int(i) for i in input().split()]\ncn = [0] * (n + 1)\nlast = [-1] * (n + 1)\nv = [int(i) for i in input().split()]\n\nfor i in range(len(v)):\n    last[v[i]] = i\n    cn[v[i]] += 1\n\ncn1 = deepcopy(cn)\nlast1 = deepcopy(last)\n\n\nfor i in range(1, n + 1):\n    cn = deepcopy(cn1)\n    last = deepcopy(last1)\n    res = [i1 for i1 in range(1, n + 1)]\n    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)\n    #print(res)\n    \n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        j1 = j + 1\n        lft = m - a\n        while j1 < n and lft:\n            pls = min(lft, cn[i] - cn[res[j1]] + 1)\n            cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)\n            last[res[j1]] = m\n            lft -= pls\n            j1 += 1\n\n    \n    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)\n    sans = 0\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 0\n        else:\n            sans = 1\n        break\n\n    if sans == 1:\n        print(1, end= ' ')\n        continue\n    \n    cn = deepcopy(cn1)\n    last = deepcopy(last1)\n\n    if m - a:\n        cn[i] += m - a\n        last[i] = m - 1\n\n    res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 0\n        else:\n            sans = 1\n        break\n    \n    if sans:\n        print(2, end=' ')\n    else:\n        print(3, end=' ')\n",
        "negative_solution": "from copy import deepcopy\nn, k, m, a = [int(i) for i in input().split()]\ncn = [0] * (n + 1)\nlast = [-1] * (n + 1)\nv = [int(i) for i in input().split()]\n\nfor i in range(len(v)):\n    last[v[i]] = i\n    cn[v[i]] += 1\n\ncn1 = deepcopy(cn)\nlast1 = deepcopy(last)\n\n\nfor i in range(1, n + 1):\n    cn = deepcopy(cn1)\n    last = deepcopy(last1)\n    res = [i1 for i1 in range(1, n + 1)]\n    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)\n    #print(res)\n    \n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        j1 = j + 1\n        lft = m - a\n        while j1 < n and lft:\n            pls = min(lft, cn[i] - cn[res[j1]] + 1)\n            cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)\n            last[res[j1]] = m\n            lft -= pls\n            j1 += 1\n\n    \n    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)\n    sans = 0\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 0\n        else:\n            sans = 1\n        break\n\n    if sans == 1:\n        print(1, end= ' ')\n        continue\n    \n    cn = deepcopy(cn1)\n    last = deepcopy(last1)\n\n    if m - a:\n        cn[i] += m - a\n        last[i] = m - 1\n\n    res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 1\n        else:\n            sans = 0\n        break\n    \n    if sans:\n        print(2, end=' ')\n    else:\n        print(3, end=' ')\n"
    },
    "3698": {
        "original_negative_solution": "# int(input())\n# [int(i) for i in input().split()]\n\ndef count_oper(x):\n    if x == 1: return(0)\n\n    res = 0\n    y = x\n    while y > 0:\n        if y % 2 == 1: res += 1\n        y = y//2\n\n    return(count_oper(res) + 1)\n\ndef solve(s,k):\n    \n    a = []\n    ones = []\n    for i in range(len(s)):\n        c= s[i]\n        a.append(int(c == '1'))\n        if c == '1': ones.append(i)\n\n    nones = len(ones)\n    n = len(a)\n\n    \n    if k == 0 :\n        print(1)\n        return\n    \n    if k == 1 and n != 1:\n        print(n-1)\n        return\n    \n    if n == 1:\n        if k > 0: print(0)\n        else: print(1)\n        return\n\n        #print(\"main\")\n    # compute binomial coeff-s:\n    c = []\n    c.append([0]*(n+1))\n    for n1 in range(1,n+1):\n        tmp = [0]*(n+1)\n        for m in range(n1+1):\n            #print(n1,m)\n            if m == 0 or m == n1: tmp[m] = 1\n            else:\n                tmp[m] = (c[n1-1][m-1] + c[n1-1][m]) % modulo\n        c.append(tmp)\n\n    ans = 0    \n    for m in range(1,n+1): # how many 1's should be in a special number?\n        if count_oper(m) == k-1: # m ones!\n            for j in range(min(nones,m)): # loop over 1's and add corrsponding bin coef\n              #  print(j, ones[j])\n                ans += (c[n - ones[j] - 1][m - j  ]) % modulo\n            if nones >= m: ans += 1\n\n    print(ans % modulo)\n\ns = input()\nk = int(input())\n\nmodulo = 10**9 + 7\n\nsolve(s,k)\n\n\n\n",
        "negative_solution": "# int(input())\n# [int(i) for i in input().split()]\n\ndef count_oper(x):\n    if x == 1: return(0)\n\n    res = 0\n    y = x\n    while y > 0:\n        if y % 2 == 1: res += 1\n        y = y//2\n\n    return(count_oper(res) + 1)\n\ndef solve(s,k):\n    \n    a = []\n    ones = []\n    for i in range(len(s)):\n        c= s[i]\n        a.append(int(c == '1'))\n        if c == '1': ones.append(i)\n\n    nones = len(ones)\n    n = len(a)\n\n    \n    if k == 0 :\n        print(1)\n        return\n    \n    if k == 1 and n != 1:\n        print(n-1)\n        return\n    \n    if n == 1:\n        if k > 0: print(0)\n        else: print(1)\n        return\n\n        #print(\"main\")\n    # compute binomial coeff-s:\n    c = []\n    c.append([0]*(n+1))\n    for n1 in range(1,n+1):\n        tmp = [0]*(n+1)\n        for m in range(n1+1):\n            #print(n1,m)\n            if m == 0 or m == n1: tmp[m] = 1\n            else:\n                tmp[m] = (c[n1-1][m-1] + c[n1-1][m]) % modulo\n        c.append(tmp)\n\n    ans = 0    \n    for m in range(1,n+1): # how many 1's should be in a special number?\n        if count_oper(m) == k-1: # m ones!\n            for j in range(min(nones,m)): # loop over 1's and add corrsponding bin coef\n              #  print(j, ones[j])\n                ans += (c[n - ones[j] - 1][m - j  ]) % modulo\n            if nones >= m: ans += 1\n\n    print(ans % modulo)\n\ns = input()\nk = int(input())\n\nmodulo = 10**9 + 9\n\nsolve(s,k)\n\n\n\n"
    },
    "3699": {
        "original_negative_solution": "from math import *\n\nax, ay, bx, by, cx, cy = map(lambda t: int(t), input().split())\nn = int(input())\ndist = 0\nmaxv = [[-inf, -inf], [-inf, -inf]]\nindex = [[0,0], [0,0]]\n\ndef update(d, idx, p):\n    nonlocal maxv, index\n    if d > maxv[p][0]:\n        maxv[p][1] = maxv[p][0]\n        index[p][1] = index[p][0]\n        maxv[p][0] = d\n        index[p][0] = idx\n    elif d > maxv[p][1]:\n        maxv[p][1] = d\n        index[p][1] = idx\n\nfor i in range(n):\n    x, y = map(lambda t: int(t), input().split())\n    bottle_recycle = sqrt((cx - x) ** 2 + (cy - y) ** 2)\n    dist += bottle_recycle * 2\n    dista = bottle_recycle - sqrt((ax - x) ** 2 + (ay - y) ** 2)\n    distb = bottle_recycle - sqrt((bx - x) ** 2 + (by - y) ** 2)\n    update(dista, i, 0)\n    update(distb, i, 1)\n\nans = dist - maxv[0][0]\nans = min(ans, dist - maxv[1][0])\nif(index[0][0] != index[1][0]):\n    ans = min(ans, dist - maxv[0][0] - maxv[1][0])\nelif(n > 1):\n    ans = min(ans, dist - maxv[0][1] - maxv[1][0], dist - maxv[0][0] - maxv[1][1])\nprint(ans)",
        "negative_solution": "from math import *\n\nax, ay, bx, by, cx, cy = map(lambda t: int(t), input().split())\nn = int(input())\ndist = 0\nmaxv = [[-inf, -inf], [-inf, -inf]]\nindex = [[0,0], [0,0]]\n\ndef update(d, idx, p):\n    nonlocal maxv, index\n    if d > maxv[p][0]:\n        maxv[p][1] = maxv[p][0]\n        index[p][1] = index[p][0]\n        maxv[p][0] = d\n        index[p][0] = idx\n    elif d > maxv[p][1]:\n        maxv[p][1] = d\n        index[p][1] = idx\n\nfor i in range(n):\n    x, y = map(lambda t: int(t), input().split())\n    bottle_recycle = sqrt((cx - x) ** 2 + (cy - y) ** 2)\n    dist += bottle_recycle * 2\n    dista = bottle_recycle - sqrt((ax - x) ** 2 + (ay - y) ** 2)\n    distb = bottle_recycle - sqrt((bx - x) ** 2 + (by - y) ** 2)\n    update(dista, i, 0)\n    update(distb, i, 1)\n\nans = dist - maxv[0][0]\nans = min(ans, dist - maxv[1][0])\nif(index[0][0] != index[1][0]):\n    ans = min(ans, dist - maxv[0][0] - maxv[1][0])\nelif(n > 1):\n    ans = min(ans, dist - maxv[0][1] - maxv[1][0], dist - maxv[0][0] - maxv[1][0])\nprint(ans)"
    },
    "3700": {
        "original_negative_solution": "n, k = list(map(int, input().split()))\nm = k // 2 + 1\nl = m - 1\nif k % 2 == 0:\n    l -= 1\nprint(max(0, min(l, n - m + 1)))\n",
        "negative_solution": "n, k = list(map(int, input().split()))\nm = k // 2 + 1\nl = m - 1\nif k % 2 == 0:\n    l -= 1\nprint(min(0, max(l, n - m + 1)))\n"
    },
    "3701": {
        "original_negative_solution": "n, x, y = map(int, input().split());\ns = input()\nne = 0;\ncount = 0;\nfor i in range(1, n + 1):\n    if (s[i - 1]  == '0'):\n        count += 1;\n    if (s[i - 1] == '1' or (s[i - 1] == '0' and i > 1 and s[i - 2] == '0')):\n        p = ne;\n    elif count == 1:\n        ne += y;\n        \n    else:\n        ne += min(x, y);\nprint(ne)",
        "negative_solution": "n, x, y = map(int, input().split());\ns = input()\nne = 0;\ncount = 0;\nfor i in range(1, n):\n    if (s[i - 1]  == '0'):\n        count += 1;\n    if (s[i - 1] == '1' or (s[i - 1] == '0' and i > 1 and s[i - 2] == '0')):\n        p = ne;\n    elif count == 1:\n        ne += y;\n        \n    else:\n        ne += min(x, y);\nprint(ne)"
    },
    "3703": {
        "original_negative_solution": "MOD = 1000000007\ndef phi(n):\n    res = n\n    for i in range(2,int(n**(0.5)+1)):\n        if n % i == 0:\n            while n % i == 0:\n                n = n//i\n            res -= res//i\n    if n > 1:\n        res -= res//n\n    return res\n\nn,k = list(map(int,input().split()))\nk = (k+1)//2\nans = n\nfor _ in range(k):\n    if ans > 1:\n        ans = phi(ans)\n    else:\n        break\nprint(ans % MOD)\n",
        "negative_solution": "MOD = 1000000007\ndef phi(n):\n    res = n\n    for i in range(2,int(n**(0.5)+1)):\n        if n % i == 0:\n            while n % i == 0:\n                n = n//i\n            res -= res//i\n    if n > 1:\n        res -= res//n\n    return res\n\nn,k = list(map(int,input().split()))\nk = (k+1)//2\nans = n\nfor _ in range(k):\n    if ans > 1:\n        ans = phi(ans)\n    else:\n        break\nprint(ans % MOD)\n"
    },
    "3705": {
        "original_negative_solution": "def main():\n    n = int(input())\n    s = input()\n    cnt = 0\n    for i in s:\n        if i == '8':\n            cnt += 1\n    print(min(cnt, n // 11))\n\nmain()",
        "negative_solution": "def main():\n    n = int(input())\n    s = input()\n    cnt = 0\n    for i in s:\n        if i == '8':\n            cnt += 1\n    print(min(cnt, n // 12))\n\nmain()"
    },
    "3706": {
        "original_negative_solution": "n,m = input().strip().split()\nn,m = int(n),int(m)\ng = [[int(j) for j in input().strip().split()] for i in range(n)]\n\nanswer =[]\n\ndef b():\n  for i in range(n):\n    minRow = min(g[i])\n    if minRow !=0:\n      for k in range(minRow):\n        answer.append(\"row \" + str(i+1))\n      for j in range(m):\n        g[i][j] -= minRow\ndef a():\n  for j in range(m):\n    minCol = g[0][j]\n    for i in range(n):\n      if  g[i][j] < minCol:\n        minCol = g[i][j]\n    if minCol !=0:\n      for k in range(minCol):\n        answer.append(\"col \" + str(j+1))\n      for i in range(n):\n        g[i][j] -= minCol\n\n\nif( n<m):\n  b()\n  a()\nelse:\n  a()\n  b()\nmaxNumber = max(max(g))\nif maxNumber ==0:\n  print(len(answer))\n  for  el in answer:\n    print(el)\nelse:\n  print(\"-1\")",
        "negative_solution": "n,m = input().strip().split()\nn,m = int(n),int(m)\ng = [[int(j) for j in input().strip().split()] for i in range(n)]\n\nanswer =[]\n\ndef b():\n  for i in range(n):\n    minRow = min(g[i])\n    if minRow !=0:\n      for k in range(minRow):\n        answer.append(\"row \" + str(i+1))\n      for j in range(m):\n        g[i][j] -= minRow\ndef a():\n  for j in range(m):\n    minCol = g[0][j]\n    for i in range(n):\n      if  g[i][j] < minCol:\n        minCol = g[i][j]\n    if minCol !=1:\n      for k in range(minCol):\n        answer.append(\"col \" + str(j+1))\n      for i in range(n):\n        g[i][j] -= minCol\n\n\nif( n<m):\n  b()\n  a()\nelse:\n  a()\n  b()\nmaxNumber = max(max(g))\nif maxNumber ==0:\n  print(len(answer))\n  for  el in answer:\n    print(el)\nelse:\n  print(\"-1\")"
    },
    "3707": {
        "original_negative_solution": "n, t, k, d = [int(i) for i in input().split()]\n\nn = (n+k-1)//k\n\nt0 = t * n\n\ndt = t0 - d\nans = \"YES\" if dt > t else \"NO\"\n\nprint(ans)",
        "negative_solution": "n, t, k, d = [int(i) for i in input().split()]\n\nn = (n+k-1)//k\n\nt0 = t * n * k\n\ndt = t0 - d\nans = \"YES\" if dt > t else \"NO\"\n\nprint(ans)"
    },
    "3708": {
        "original_negative_solution": "from collections import defaultdict\n\ndef f(u, v):\n    s, l = [], len(v)\n    i = j = 0\n    for i in range(len(u)):\n        while v[j][1] <= u[i][0]:\n            j += 1\n            if j == l: return s\n        if u[i][1] <= v[j][0]: continue\n        if u[i][0] >= v[j][0]: s.append(u[i])\n        else: s.append((v[j][0], u[i][1]))\n    return s\n\nn, m = map(int, input().split())\np = defaultdict(list)\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    p[x].append(y)\n\nfor x in p:\n    if len(p[x]) > 1: p[x].sort()\n    t, i = [], 1\n    for j in p[x]:\n        if i != j: t.append((i, j))\n        i = j + 1\n    if i != n + 1: t.append((i, n + 1))\n    p[x] = t\n\nk, s = 1, [(1, 2)]\nfor x in sorted(p.keys()):\n    if x == k: s = f(p[x], s)\n    else: s = f(p[x], [(s[0][0], n + 1)])\n    if not s: break\n    k = x + 1\n\nif s and k == n + 1 and s[-1][1] != k: s = []\nprint(2 * (n - 1) if s else -1)",
        "negative_solution": "from collections import defaultdict\n\ndef f(u, v):\n    s, l = [], len(v)\n    i = j = 0\n    for i in range(len(u)):\n        while v[j][1] <= u[i][0]:\n            j += 1\n            if j == l: return s\n        if u[i][1] <= v[j][0]: continue\n        if u[i][0] >= v[j][0]: s.append(u[i])\n        else: s.append((v[j][0], u[i][1]))\n    return s\n\nn, m = map(int, input().split())\np = defaultdict(list)\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    p[x].append(y)\n\nfor x in p:\n    if len(p[x]) > 1: p[x].sort()\n    t, i = [], 1\n    for j in p[x]:\n        if i != j: t.append((i, j))\n        i = j + 1\n    if i != n + 1: t.append((i, n + 1))\n    p[x] = t\n\nk, s = 1, [(1, 2, 3)]\nfor x in sorted(p.keys()):\n    if x == k: s = f(p[x], s)\n    else: s = f(p[x], [(s[0][0], n + 1)])\n    if not s: break\n    k = x + 1\n\nif s and k == n + 1 and s[-1][1] != k: s = []\nprint(2 * (n - 1) if s else -1)"
    },
    "3709": {
        "original_negative_solution": "n,k=list(map(int,input().split()))\na=[int(input().replace(\" \",\"\"),2) for i in range(n)]\n\n# https://stackoverflow.com/questions/374626/how-can-i-find-all-the-subsets-of-a-set-with-exactly-n-elements\nfrom itertools import chain, combinations\n\ndef powerset(iterable):\n    xs = list(iterable)\n    return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1))\n\nfor s in powerset([x for x in range(1<<k) if x in a]):\n    if len(s) == 0: continue\n    good = True\n    for i in range(k):\n        c = [(p >> i) & 1 for p in s]\n        if c.count(1) > c.count(0):\n            good = False\n    if good:\n        print(\"YES\")\n        return\n\nprint(\"NO\")\n",
        "negative_solution": "n,k=list(map(int,input().split()))\na=[int(input().replace(\" \",\"\"),2) for i in range(n)]\n\n# https://stackoverflow.com/questions/374626/how-can-i-find-all-the-subsets-of-a-set-with-exactly-n-elements\nfrom itertools import chain, combinations\n\ndef powerset(iterable):\n    xs = list(iterable)\n    return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1))\n\nfor s in powerset([x for x in range(1<<k) if x in a]):\n    if len(s) == 0: continue\n    good = True\n    for i in range(k):\n        c = [(p >> i + 1) & 1 for p in s]\n        if c.count(1) > c.count(0):\n            good = False\n    if good:\n        print(\"YES\")\n        return\n\nprint(\"NO\")\n"
    },
    "3710": {
        "original_negative_solution": "import math\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\ng = 1\nfor i in a:\n    g = math.gcd(k, i * g//math.gcd(i, g))\nif g == k:\n    print('Yes')\nelse:\n    print('No')\n",
        "negative_solution": "import math\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\ng = 1\nfor i in a:\n    g = math.gcd(k, (i + 1) * g//math.gcd(i, g))\nif g == k:\n    print('Yes')\nelse:\n    print('No')\n"
    },
    "3711": {
        "original_negative_solution": "n, m, k = map(int, input().split())\nif m > n:\n\tn, m = m, n\nans = -1\nif k < n:\n\tans = m * (n // (k + 1))\n\tif k < m:\n\t\tans = max(ans, n * (m // (k + 1)))\nelif k <= (n - 1) + (m - 1):\n\tans = m // ((k + 1 - n) + 1)\nprint(ans)",
        "negative_solution": "n, m, k = map(int, input().split())\nif m > n:\n\tn, m = m, n\nans = -1\nif k < n:\n\tans = m * (n // (k + 1))\n\tif k < m:\n\t\tans = max(ans, n * (m // (k + 1)))\nelif k <= (n - 1) + (m - 1) + 1:\n\tans = m // ((k + 1 - n) + 1)\nprint(ans)"
    },
    "3712": {
        "original_negative_solution": "#! /usr/bin/env python\n\nn = int(input())\ncounts = [0] * 5\ns = 0\nfor x in [int(x) for x in input().split()]:\n    counts[x] += 1\n    s += x\n\nif s > 2 and s != 5:\n    ans = 0\n    if counts[1] >= counts[2]:\n        ans += counts[2]\n        counts[3] += counts[2]\n        counts[1] -= counts[2]\n        ans += 2 * (counts[1] // 3)\n        counts[3] += counts[1] // 3\n        counts[1] %= 3\n        if counts[3] > 0:\n            ans += counts[1]\n        elif counts[1] != 0:\n            ans += 2\n    else:\n        ans += counts[1]\n        counts[2] -= counts[1]\n        ans += 2 * (counts[2] // 3)\n        counts[2] %= 3\n        if counts[4] > 0:\n            ans += counts[2]\n        elif counts[2] != 0:\n            ans += 2\n    print(ans)\nelse:\n    print(-1)\n",
        "negative_solution": "#! /usr/bin/env python\n\nn = int(input())\ncounts = [0] * 5\ns = 0\nfor x in [int(x) for x in input().split()]:\n    counts[x] += 1\n    s += x\n\nif s > 2 and s != 5:\n    ans = 0\n    if counts[1] >= counts[2]:\n        ans += counts[2]\n        counts[3] += counts[2]\n        counts[1] -= counts[2]\n        ans += 2 * (counts[1] // 3)\n        counts[3] += counts[1] // 3\n        counts[1] %= 3\n        if counts[3] > 0:\n            ans += counts[1]\n        elif counts[1] != 0:\n            ans += 2\n    else:\n        ans += counts[1]\n        counts[2] -= counts[1]\n        ans += counts[2] // 3\n        counts[2] %= 3\n        if counts[4] > 0:\n            ans += counts[2]\n        elif counts[2] != 0:\n            ans += 2\n    print(ans)\nelse:\n    print(-1)\n"
    },
    "3713": {
        "original_negative_solution": "n = int(input())\nA = list(map(int, ' '.join(input()).split()))\nres = 1\n\nfor i in range(1, len(A)):\n    if A[i] != A[i - 1]:\n        res += 1\nprint(min(res + 2, n))\n",
        "negative_solution": "n = int(input())\nA = list(map(int, ' '.join(input()).split()))\nres = 1\n\nfor i in range(1, len(A)):\n    if A[i] != A[i - 1]:\n        res += 1\nprint(min(res, n))\n"
    },
    "3714": {
        "original_negative_solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn = int(input())\na = list(map(int, input().split()))\nif sorted(a) != [i + 1 for i in range(n)]:\n    print(-1)\nelse:\n    ans = 1\n    used = [0 for i in range(n)]\n    for i in range(n):\n        if used[i] == 0:\n            j = i\n            am = 0\n            while used[j] == 0:\n                am += 1\n                used[j] = 1\n                j = a[j] - 1\n            if am % 2:\n                ans = lcm(ans, am)\n            else:\n                ans = lcm(ans, am // 2)\n    print(ans)",
        "negative_solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn = int(input())\na = list(map(int, input().split()))\nif sorted(a) != [i for i in range(n)]:\n    print(-1)\nelse:\n    ans = 1\n    used = [0 for i in range(n)]\n    for i in range(n):\n        if used[i] == 0:\n            j = i\n            am = 0\n            while used[j] == 0:\n                am += 1\n                used[j] = 1\n                j = a[j] - 1\n            if am % 2:\n                ans = lcm(ans, am)\n            else:\n                ans = lcm(ans, am // 2)\n    print(ans)"
    },
    "3715": {
        "original_negative_solution": "3\n\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [[-1791791791] * 4 for i in range(n)]\n\ndp[0][0] = 0\nif a[0] & 1:\n    dp[0][1] = 1\nif a[0] & 2:\n    dp[0][2] = 1\n\nfor i in range(1, n):\n    dp[i][0] = max(dp[i - 1])\n    for j in range(1, 3):\n        if a[i] & j:\n            dp[i][j] = max(dp[i - 1][:j] + dp[i - 1][j + 1:]) + 1\n\nans = max(dp[-1])\nprint(n - ans)\n",
        "negative_solution": "3\n\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [[-1791791791] * 4 for i in range(n)]\n\ndp[0][0] = 0\nif a[0] & 1:\n    dp[0][1] = 1\nif a[0] & 2:\n    dp[0][2] = 1\n\nfor i in range(1, n):\n    dp[i][0] = max(dp[i - 1])\n    for j in range(1, 3):\n        if a[i] & j:\n            dp[i][j] = max(dp[i - 1][:j + 1] + dp[i - 1][j + 1:]) + 1\n\nans = max(dp[-1])\nprint(n - ans)\n"
    },
    "3716": {
        "original_negative_solution": "n = int(input())\nres = n * (n - 1)\ngcd = lambda a, b: b if a % b == 0 else gcd(b, a % b)\n\nfor i in range(n - 2 if n % 2 != 0 else n - 3, 0, -2):\n    if gcd(n, i) == 1 and gcd(n - 1, i) == 1:\n        res = res * i if n % 2 != 0 else max(res * i, int(res / 2) * (n - 2),\n                (n - 1) * (n - 2) * (n - 3))\n        break\n\nif n < 3:\n    res = n\n\nprint(res)\n",
        "negative_solution": "n = int(input())\nres = n * (n - 1)\ngcd = lambda a, b: b if a % b == 0 else gcd(b, a % b)\n\nfor i in range(n - 2 if n % 2 != 0 else n - 3, 0, -2):\n    if gcd(n, i) == 1 and gcd(n - 1, i) == 1:\n        res = res * i if n % 2 != 0 else max(res * i, int(res / 2) * n,\n                (n - 1) * (n - 2) * (n - 3))\n        break\n\nif n < 3:\n    res = n\n\nprint(res)\n"
    },
    "3717": {
        "original_negative_solution": "n = int(input())\na = [list(map(int, input().split())) for i in range(n)]\nl1, l2 = max(a[0][0], a[1][0]), min(a[0][0], a[1][0])\nd1, d2 = max(a[0][1], a[1][1]), min(a[0][1], a[1][1])\nr1, r2 = min(a[0][2], a[1][2]), max(a[0][2], a[1][2])\nu1, u2 = min(a[0][3], a[1][3]), max(a[0][3], a[1][3])\nfor i in range(2, n):\n    if a[i][0] > l1:\n        l1, l2 = a[i][0], l1\n    elif a[i][0] > l2:\n        l2 = a[i][0]\n    if a[i][1] > d1:\n        d1, d2 = a[i][1], d1\n    elif a[i][1] > d2:\n        d2 = a[i][1]\n    if a[i][2] < r1:\n        r1, r2 = a[i][2], r1\n    elif a[i][2] < r2:\n        r2 = a[i][2]\n    if a[i][3] < u1:\n        u1, u2 = a[i][3], u1\n    elif a[i][3] < u2:\n        u2 = a[i][3]\nfor i in range(n):\n    if a[i][0] == l1:\n        a[i][0] = l2\n    else:\n        a[i][0] = l1\n    if a[i][1] == d1:\n        a[i][1] = d2\n    else:\n        a[i][1] = d1\n    if a[i][2] == r1:\n        a[i][2] = r2\n    else:\n        a[i][2] = r1\n    if a[i][3] == u1:\n        a[i][3] = u2\n    else:\n        a[i][3] = u1\n    if a[i][0] <= a[i][2] and a[i][1] <= a[i][3]:\n        print(a[i][0], a[i][1])\n        return",
        "negative_solution": "n = int(input())\na = [list(map(int, input().split())) for i in range(n)]\nl1, l2 = max(a[0][0], a[1][0]), min(a[0][0], a[1][0])\nd1, d2 = max(a[0][1], a[1][1]), min(a[0][1], a[1][1])\nr1, r2 = min(a[0][2], a[1][2]), max(a[0][2], a[1][2])\nu1, u2 = min(a[0][3], a[1][3]), max(a[0][3], a[1][3])\nfor i in range(2, n):\n    if a[i][0] > l1:\n        l1, l2 = a[i][0], l1\n    elif a[i][0] > l2:\n        l2 = a[i][0]\n    if a[i][1] > d1:\n        d1, d2 = a[i][1], d1\n    elif a[i][1] > d2:\n        d2 = a[i][1]\n    if a[i][2] < r1:\n        r1, r2 = a[i][2], r1\n    elif a[i][2] < r2:\n        r2 = a[i][2]\n    if a[i][3] < u1:\n        u1, u2 = a[i][3], u1\n    elif a[i][3] < u2:\n        u2 = a[i][3]\nfor i in range(n):\n    if a[i][0] == l1:\n        a[i][0] = l2\n    else:\n        a[i][0] = l1\n    if a[i][1] == d1:\n        a[i][1] = d2\n    else:\n        a[i][1] = d1\n    if a[i][2] == r1:\n        a[i][2] = r2\n    else:\n        a[i][2] = r1\n    if a[i][3] == u1:\n        a[i][3] = u2\n    else:\n        a[i][3] = u1\n    if a[i][0] <= a[i][3] and a[i][1] <= a[i][3]:\n        print(a[i][0], a[i][1])\n        return"
    },
    "3718": {
        "original_negative_solution": "a=int(input())\nl=sorted(set(map(int,input().split())))\nfor i in range(len(l)-2):\n    if l[i]+2==l[i+2]: print('YES'); break\nelse: print(\"NO\")\n",
        "negative_solution": "a=int(input())\nl=sorted(set(map(int,input().split())))\nfor i in range(len(l)-2):\n    if l[i]+1==l[i+1]: print('YES'); break\nelse: print(\"NO\")\n"
    },
    "3721": {
        "original_negative_solution": "from sys import stdin, stdout\n\nclass DSU:\n\tdef __init__(self, n):\n\t\tself.root = [ -1 for x in range(0, n) ]\n\n\tdef find(self, i):\n\t\tif self.root[i] == -1:\n\t\t\treturn i\n\t\telse:\n\t\t\tself.root[i] = self.find(self.root[i])\n\t\t\treturn self.root[i]\n\n\tdef link(self, i, j):\n\t\tif self.find(i) == self.find(j):\n\t\t\treturn False\n\t\tself.root[self.find(i)] = self.find(j)\n\t\treturn True\n\nn, m, q = map(int, stdin.readline().split())\n\ndsu = DSU(n+m+1)\ngroups = n+m\n\nfor line in stdin:\n\tr, c = map(int, line.split())\n\tgroups -= dsu.link(r, n+c)\n\nstdout.write(str(groups-1) + '\\n')",
        "negative_solution": "from sys import stdin, stdout\n\nclass DSU:\n\tdef __init__(self, n):\n\t\tself.root = [ -1 for x in range(0, n) ]\n\n\tdef find(self, i):\n\t\tif self.root[i] == -1:\n\t\t\treturn i\n\t\telse:\n\t\t\tself.root[i] = self.find(self.root[i])\n\t\t\treturn self.root[i]\n\n\tdef link(self, i, j):\n\t\tif self.find(i) == self.find(j):\n\t\t\treturn False\n\t\tself.root[self.find(i)] = self.find(j)\n\t\treturn True\n\nn, m, q = map(int, stdin.readline().split())\n\ndsu = DSU(n+m+1)\ngroups = n+m\n\nfor line in stdin:\n\tr, c = map(int, line.split())\n\tgroups -= dsu.link(r, n+c)\n\nstdout.write(str(groups-1) + '\\n')"
    },
    "3722": {
        "original_negative_solution": "N = int(input())\nc1 = str(input())\nc2 = str(input())\nc3 = str(input())\nc4 = str(input())\n\nc=c1+c2+c3+c4\n\nif c in [\"AAAA\",\"AAAB\",\"AABA\",\"AABB\",\"ABAB\",\"BBAB\",\"ABBB\",\"BBBB\"]:\n\tprint((1))\n\nif c in [\"ABAA\",\"BABA\",\"BABB\",\"BBAA\"]:\n\tif N==2 or N==3:\n\t\tprint((1))\n\telse:\n\t\tans=1\n\t\tfor dummy in range(N-3):\n\t\t\tans*=2\n\t\t\tans=ans%(10**9+7)\n\t\t\n\t\tprint(ans)\n\nif c in [\"BAAA\",\"BAAB\",\"ABBA\",\"BBBA\"]:\n\tans=[1,1]\n\tif N==2 or N==3:\n\t\tprint((1))\n\telse:\n\t\tfor dummy in range(N-3):\n\t\t\tans+=[(ans[-1]+ans[-2])%(10**9+7)]\n\t\t\n\t\tprint((ans[-1]))\n\n\n\n\n# 2darray\n## [[0] * 4 for i in range(3)]\n\n# import itertools\n# import sys\n## return\n\n# l_2d = [[20, 3, 100], [1, 200, 30], [300, 10, 2]]\n# sorted(l_2d, key=lambda x: x[0])\n## [[1, 200, 30], [20, 3, 100], [300, 10, 2]]\n\n# import numpy as np\n# l_2d_t = np.array(l_2d).T.tolist()\n# l_2d_ts = sorted(l_2d_t, key=lambda x: x[0])\n# np.array(l_2d_ts).T.tolist()\n## [[3, 20, 100], [200, 1, 30], [10, 300, 2]]\n\n",
        "negative_solution": "N = int(input())\nc1 = str(input())\nc2 = str(input())\nc3 = str(input())\nc4 = str(input())\n\nc=c1+c2+c3+c4+1\n\nif c in [\"AAAA\",\"AAAB\",\"AABA\",\"AABB\",\"ABAB\",\"BBAB\",\"ABBB\",\"BBBB\"]:\n\tprint((1))\n\nif c in [\"ABAA\",\"BABA\",\"BABB\",\"BBAA\"]:\n\tif N==2 or N==3:\n\t\tprint((1))\n\telse:\n\t\tans=1\n\t\tfor dummy in range(N-3):\n\t\t\tans*=2\n\t\t\tans=ans%(10**9+7)\n\t\t\n\t\tprint(ans)\n\nif c in [\"BAAA\",\"BAAB\",\"ABBA\",\"BBBA\"]:\n\tans=[1,1]\n\tif N==2 or N==3:\n\t\tprint((1))\n\telse:\n\t\tfor dummy in range(N-3):\n\t\t\tans+=[(ans[-1]+ans[-2])%(10**9+7)]\n\t\t\n\t\tprint((ans[-1]))\n\n\n\n\n# 2darray\n## [[0] * 4 for i in range(3)]\n\n# import itertools\n# import sys\n## return\n\n# l_2d = [[20, 3, 100], [1, 200, 30], [300, 10, 2]]\n# sorted(l_2d, key=lambda x: x[0])\n## [[1, 200, 30], [20, 3, 100], [300, 10, 2]]\n\n# import numpy as np\n# l_2d_t = np.array(l_2d).T.tolist()\n# l_2d_ts = sorted(l_2d_t, key=lambda x: x[0])\n# np.array(l_2d_ts).T.tolist()\n## [[3, 20, 100], [200, 1, 30], [10, 300, 2]]\n\n"
    },
    "3723": {
        "original_negative_solution": "n = int(input().strip())\na = [int(i) for i in input().strip().split()]\nf = [0 for i in range(max(a)+1)]\nl = len(f)\n\nfor i in a:\n  f[i]+=1\n\nif f[1]:\n  f[1]=1\n\nfor i in range(2,l):\n  for j in range(2*i,l,i):\n    f[i]+=f[j]\n\nprint(max(f))\n",
        "negative_solution": "n = int(input().strip())\na = [int(i) for i in input().strip().split()]\nf = [0 for i in range(max(a)+1)]\nl = len(f)\n\nfor i in a:\n  f[i]+=1\n\nif f[1]:\n  f[1]=1\n\nfor i in range(2,l):\n  for j in range(2*i,l,i):\n    f[i]+=f[j] + 1\n\nprint(max(f))\n"
    },
    "3724": {
        "original_negative_solution": "n = int(input())\ns = input()\ns = list(map('_ABC'.index, s))\n\nMOD = 10 ** 9 + 7\n\ndp = [0, 0, 0, 0]\ndp[s[0]] = 1\n\nxor = s[0]\np = 1\nwhile p < n and s[p] == s[0]:\n    xor ^= s[p]\n    p += 1\n\nfor i, c in enumerate(s[p:], start=p):\n\n    d, e = c % 3 + 1, (c + 1) % 3 + 1\n\n    dp[c] = sum(dp) % MOD\n    dp[d], dp[e] = dp[e], dp[d]\n\n    if i == p:\n        dp[c] += p // 2\n        dp[s[i - 1] ^ c] += (p - 1) // 2\n    elif xor == 0:\n        dp[c] += 1\n\n    xor ^= c\n\nprint((sum(dp) % MOD))\n",
        "negative_solution": "n = int(input())\ns = input()\ns = list(map('_ABC'.index, s))\n\nMOD = 10 ** 9 + 7\n\ndp = [0, 0, 0, 0]\ndp[s[0]] = 1\n\nxor = s[0]\np = 1\nwhile p < n and s[p] == s[n]:\n    xor ^= s[p]\n    p += 1\n\nfor i, c in enumerate(s[p:], start=p):\n\n    d, e = c % 3 + 1, (c + 1) % 3 + 1\n\n    dp[c] = sum(dp) % MOD\n    dp[d], dp[e] = dp[e], dp[d]\n\n    if i == p:\n        dp[c] += p // 2\n        dp[s[i - 1] ^ c] += (p - 1) // 2\n    elif xor == 0:\n        dp[c] += 1\n\n    xor ^= c\n\nprint((sum(dp) % MOD))\n"
    },
    "3725": {
        "original_negative_solution": "mod = int(input())\nh1, a1 = map(int, input().split())\nx1, y1 = map(int, input().split())\nh2, a2 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nq1 = 0\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    q1 += 1\n    if q1 > 2 * mod:\n        print(-1)\n        return\n\nq2 = 0\nt2 = h2\nwhile t2 != a2:\n    t2 = (t2 * x2 + y2) % mod\n    q2 += 1\n    if q2 > 2 * mod:\n        print(-1)\n        return\n\nif q1 == q2:\n    print(q1)\n    return\n\n\nc1 = 1\nh1 = (a1 * x1 + y1) % mod\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    c1 += 1\n    if c1 > 2 * mod:\n        print(-1)\n        return\n\nc2 = 0\nnx2 = 1\nny2 = 0\n\nfor i in range(c1):\n    nx2 = (nx2 * x2) % mod\n    ny2 = (ny2 * x2 + y2) % mod\n\nfor i in range(q1):\n    h2 = (h2 * x2 + y2) % mod\n\nwhile h2 != a2:\n    h2 = (h2 * nx2 + ny2) % mod\n    c2 += 1\n    if c2 > 2 * mod:\n        print(-1)\n        return\n\nprint(q1 + c1 * c2)",
        "negative_solution": "mod = int(input())\nh1, a1 = map(int, input().split())\nx1, y1 = map(int, input().split())\nh2, a2 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nq1 = 0\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    q1 += 1\n    if q1 > 2 * mod:\n        print(-1)\n        return\n\nq2 = 0\nt2 = h2\nwhile t2 != a2:\n    t2 = (t2 * x2 + y2) % mod\n    q2 += 1\n    if q2 > 2 * mod:\n        print(-1)\n        return\n\nif q1 == q2:\n    print(q1)\n    return\n\n\nc1 = 1\nh1 = (a1 * x1 + y1) % mod\nwhile h1 != a1:\n    h1 = (h1 * x1 + y1) % mod\n    c1 += 1\n    if c1 > 2 * mod:\n        print(-1)\n        return\n\nc2 = 0\nnx2 = 1\nny2 = 0\n\nfor i in range(c1):\n    nx2 = (nx2 * x2 + i) % mod\n    ny2 = (ny2 * x2 + y2) % mod\n\nfor i in range(q1):\n    h2 = (h2 * x2 + y2) % mod\n\nwhile h2 != a2:\n    h2 = (h2 * nx2 + ny2) % mod\n    c2 += 1\n    if c2 > 2 * mod:\n        print(-1)\n        return\n\nprint(q1 + c1 * c2)"
    },
    "3726": {
        "original_negative_solution": "import sys\ninput = sys.stdin.readline\n\nimport itertools\nfrom collections import defaultdict\nimport numpy as np\n\nN = int(input())\nX = set(int(x) for x in input().split())\n\n# 2\u306f\u7d20\u6570\u3067\u306a\u3044\u3068\u3057\u3066\u6271\u3063\u3066\nU = 10**7 + 100\nis_prime = np.zeros(U,dtype=np.bool)\nis_prime[3::2] = 1\nfor p in range(3,U,2):\n    if p*p > U:\n        break\n    if is_prime[p]:\n        is_prime[p*p::p+p] = 0\n\n# imos\u3067\u5024\u3092\u5165\u308c\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u5834\u6240\nX ^= set(x+1 for x in X)\n\nEV = set(x for x in X if x%2 == 0)\nOD = set(x for x in X if x%2 == 1)\n\n# 1\u624b\u3067\u3068\u308c\u308b\u30da\u30a2\u3092\u898b\u3064\u3051\u308b\uff1a\u6700\u5927\u30de\u30c3\u30c1\u30f3\u30b0\n# \u5947\u70b9\u304b\u3089\u5076\u70b9\u306b\u8fba\u3092\u8cbc\u308b\nsource = -1\nsink = -2\ngraph = defaultdict(dict)\nfor x in EV:\n    graph[x][sink] = 1\n    graph[sink][x] = 0\nfor x in OD:\n    graph[source][x] = 1\n    graph[x][source] = 0\nfor x,y in itertools.product(OD,EV):\n    if is_prime[abs(x-y)]:\n        graph[x][y] = 1\n        graph[y][x] = 0\n\ndef bfs():\n    level = defaultdict(int)\n    q = [source]\n    level[source] = 1\n    d = 1\n    while q:\n        d += 1\n        if level[sink] != 0:\n            break\n        qq = []\n        for x in q:\n            for y,cap in graph[x].items():\n                if cap==0 or level[y]!=0:\n                    continue\n                level[y] = d\n                qq.append(y)\n        q = qq\n    return level\n\ndef dfs(v,f,level,itr):\n    if v == sink:\n        return f\n    for w,cap in itr[v]:\n        if cap==0 or level[w]!=level[v]+1:\n            continue\n        d = dfs(w,min(f,cap),level,itr)\n        if d:\n            graph[v][w] -= d\n            graph[w][v] += d\n            return d\n    return 0\n\ndef max_flow():\n    flow = 0\n    while True:\n        level = bfs()\n        if level[sink] == 0:\n            return flow\n        itr = {v:iter(graph[v].items()) for v in graph}\n        while True:\n            f = dfs(source,10**9,level,itr)\n            if f == 0:\n                break\n            flow += f\n\nf = max_flow()\n\nod = len(OD); ev = len(EV)\nanswer = f\nod -= f; ev -= f\nanswer += 2*(od//2); od %= 2\nanswer += 2*(ev//2); ev %= 2\nif od:\n    answer += 3\nprint(answer)",
        "negative_solution": "import sys\ninput = sys.stdin.readline\n\nimport itertools\nfrom collections import defaultdict\nimport numpy as np\n\nN = int(input())\nX = set(int(x) for x in input().split())\n\n# 2\u306f\u7d20\u6570\u3067\u306a\u3044\u3068\u3057\u3066\u6271\u3063\u3066\nU = 10**7 + 100\nis_prime = np.zeros(U,dtype=np.bool)\nis_prime[3::2] = 1\nfor p in range(3,U,2):\n    if p*p > U:\n        break\n    if is_prime[p]:\n        is_prime[p*p::p+p] = 0\n\n# imos\u3067\u5024\u3092\u5165\u308c\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u5834\u6240\nX ^= set(x+1 for x in X)\n\nEV = set(x for x in X if x%2 == 0)\nOD = set(x for x in X if x%2 == 1)\n\n# 1\u624b\u3067\u3068\u308c\u308b\u30da\u30a2\u3092\u898b\u3064\u3051\u308b\uff1a\u6700\u5927\u30de\u30c3\u30c1\u30f3\u30b0\n# \u5947\u70b9\u304b\u3089\u5076\u70b9\u306b\u8fba\u3092\u8cbc\u308b\nsource = -1\nsink = -2\ngraph = defaultdict(dict)\nfor x in EV:\n    graph[x][sink] = 1\n    graph[sink][x] = 0\nfor x in OD:\n    graph[source][x] = 1\n    graph[x][source] = 0\nfor x,y in itertools.product(OD,EV):\n    if is_prime[abs(x-y)]:\n        graph[x][y] = 1\n        graph[y][x] = 0\n\ndef bfs():\n    level = defaultdict(int)\n    q = [source]\n    level[source] = 1\n    d = 1\n    while q:\n        d += 1\n        if level[sink] != 0:\n            break\n        qq = []\n        for x in q:\n            for y,cap in graph[x].items():\n                if cap==0 or level[y]!=0:\n                    continue\n                level[y] = d\n                qq.append(y)\n        q = qq\n    return level\n\ndef dfs(v,f,level,itr):\n    if v == sink:\n        return f\n    for w,cap in itr[v]:\n        if cap==0 or level[w]!=level[v]+1:\n            continue\n        d = dfs(w,min(f,cap),level,itr)\n        if d:\n            graph[v][w] -= d\n            graph[w][v] -= d\n            return d\n    return 0\n\ndef max_flow():\n    flow = 0\n    while True:\n        level = bfs()\n        if level[sink] == 0:\n            return flow\n        itr = {v:iter(graph[v].items()) for v in graph}\n        while True:\n            f = dfs(source,10**9,level,itr)\n            if f == 0:\n                break\n            flow += f\n\nf = max_flow()\n\nod = len(OD); ev = len(EV)\nanswer = f\nod -= f; ev -= f\nanswer += 2*(od//2); od %= 2\nanswer += 2*(ev//2); ev %= 2\nif od:\n    answer += 3\nprint(answer)"
    },
    "3727": {
        "original_negative_solution": "a, b, c, d = list(map(int, input().split()))\ntry:\n    assert abs(a - b + c - d) < 2\n    ans = []\n    if not d:\n        ans = [1, 0] * a + [1, 2] * c\n        if a + c < b:\n            ans.append(1)\n        if a + c > b:\n            ans.pop(0)\n    elif not a:\n        ans = [2, 3] * d + [2, 1] * b\n        if d + b < c:\n            ans.append(2)\n        if d + b > c:\n            ans.pop(0)\n    elif a + c > b + d:\n        while a:\n            ans.append(0)\n            ans.append(1)\n            a -= 1\n            b -= 1\n        assert b >= 0\n        while b:\n            ans.append(2)\n            ans.append(1)\n            b -= 1\n            c -= 1\n        assert c >= 0\n        while c:\n            ans.append(2)\n            ans.append(3)\n            c -= 1\n            d -= 1\n        ans.pop()\n    else:\n        while d:\n            ans.append(3)\n            ans.append(2)\n            c -= 1\n            d -= 1\n        assert c >= 0\n        while c:\n            ans.append(1)\n            ans.append(2)\n            b -= 1\n            c -= 1\n        assert b >= 0\n        while b:\n            ans.append(1)\n            ans.append(0)\n            a -= 1\n            b -= 1\n        if a:\n            ans.pop()\n    print(\"YES\")\n    print(*ans)\nexcept AssertionError:\n    print(\"NO\")\n",
        "negative_solution": "a, b, c, d = list(map(int, input().split()))\ntry:\n    assert abs(a - b + c - d) < 2\n    ans = []\n    if not d:\n        ans = [1, 0] * a + [1, 2] * c\n        if a + c < b:\n            ans.append(1)\n        if a + c > b:\n            ans.pop(0)\n    elif not a:\n        ans = [2, 3] * d + [2, 1] * b\n        if d + b < c:\n            ans.append(1)\n        if d + b > c:\n            ans.pop(0)\n    elif a + c > b + d:\n        while a:\n            ans.append(0)\n            ans.append(1)\n            a -= 1\n            b -= 1\n        assert b >= 0\n        while b:\n            ans.append(2)\n            ans.append(1)\n            b -= 1\n            c -= 1\n        assert c >= 0\n        while c:\n            ans.append(2)\n            ans.append(3)\n            c -= 1\n            d -= 1\n        ans.pop()\n    else:\n        while d:\n            ans.append(3)\n            ans.append(2)\n            c -= 1\n            d -= 1\n        assert c >= 0\n        while c:\n            ans.append(1)\n            ans.append(2)\n            b -= 1\n            c -= 1\n        assert b >= 0\n        while b:\n            ans.append(1)\n            ans.append(0)\n            a -= 1\n            b -= 1\n        if a:\n            ans.pop()\n    print(\"YES\")\n    print(*ans)\nexcept AssertionError:\n    print(\"NO\")\n"
    },
    "3728": {
        "original_negative_solution": "import sys\n\ndef swapC(c1, c2):\n    for r in range(n):\n        swap(r, c1, c2)\n\ndef swap(r, c1, c2):\n    nums[r][c1], nums[r][c2] = nums[r][c2], nums[r][c1]\n\ndef checkRow(r):\n    bad = []\n    for i in range(m):\n        if nums[r][i] != i:\n            bad.append(i)\n    if len(bad) == 0:\n        return True\n    if len(bad) != 2:\n        return False\n    x0, x1 = nums[r][bad[0]], nums[r][bad[1]]\n    return bad[0] == x1 and bad[1] == x0\n\ndef checkAll():\n    for r in range(n):\n        if not checkRow(r):\n            return False\n    return True\n\nn, m = map(int, input().split())\nnums = [list(map(lambda x: int(x) - 1, input().split())) for i in range(n)]\n\n\nflag = False\nfor c1 in range(m):\n    for c2 in range(c1, m):\n        swapC(c1, c2)\n        if checkAll():\n            print(\"YES\")\n            flag = True\n            break\n        swapC(c1, c2)\n    if flag:\n        break\nelse:\n    print(\"NO\")",
        "negative_solution": "import sys\n\ndef swapC(c1, c2):\n    for r in range(n):\n        swap(r, c1, c2)\n\ndef swap(r, c1, c2):\n    nums[r][c1], nums[r][c2] = nums[r][c2], nums[r][c1]\n\ndef checkRow(r):\n    bad = []\n    for i in range(m):\n        if nums[r][i] != i:\n            bad.append(i)\n    if len(bad) == 0:\n        return True\n    if len(bad) != 2:\n        return False\n    x0, x1 = nums[r][bad[0]], nums[r][bad[1]]\n    return bad[0] == x1 and bad[1] == x0\n\ndef checkAll():\n    for r in range(n):\n        if not checkRow(r):\n            return False\n    return True\n\nn, m = map(int, input().split())\nnums = [list(map(lambda x: int(x), input().split())) for i in range(n)]\n\n\nflag = False\nfor c1 in range(m):\n    for c2 in range(c1, m):\n        swapC(c1, c2)\n        if checkAll():\n            print(\"YES\")\n            flag = True\n            break\n        swapC(c1, c2)\n    if flag:\n        break\nelse:\n    print(\"NO\")"
    },
    "3729": {
        "original_negative_solution": "import sys\ndef factorial():\n    nonlocal mod\n    fac = [1] * int(3e5 + 1)\n    for i in range(1, int(3e5)):\n        fac[i] = i*fac[i-1] % mod\n    return fac\ndef inverse(x):\n    nonlocal mod\n    return pow(x, mod-2, mod)\ndef C(n, r):\n    nonlocal fac\n    if n < 0 or n < r:\n        return 0\n    return fac[n]*inverse(fac[r])*inverse(fac[n-r]) % mod\ndef calc(f, w, h):\n    nonlocal mod\n    if w == 0:\n        return 1\n    ans = 0\n    for k in range(1, min(w//(h+1),f+1)+1):\n        ans += C(f+1, k) * C(w-k*h-1, k-1) % mod\n        ans %= mod\n    return ans\nf, w, h = list(map(int,sys.stdin.readline().split(' ')))\nmod = int(1e9 + 7)\nfac = factorial()\ncnt = calc(f, w, h)\nsys.stdout.write(str(cnt*inverse(C(f+w, w)) % mod))\n\n",
        "negative_solution": "import sys\ndef factorial():\n    nonlocal mod\n    fac = [1] * int(3e5 + 1)\n    for i in range(1, int(3e5)):\n        fac[i] = i*fac[i-1] % mod\n    return fac\ndef inverse(x):\n    nonlocal mod\n    return pow(x, mod-2, mod)\ndef C(n, r):\n    nonlocal fac\n    if n < 0 or n < r:\n        return 0\n    return fac[n]*inverse(fac[r])*inverse(fac[n-r]) % mod\ndef calc(f, w, h):\n    nonlocal mod\n    if w == 0:\n        return 1\n    ans = 0\n    for k in range(1, min(w//(h+1),f+1)+1):\n        ans += C(f+1, k) * C((w-k-1)*(h-1), k-1) % mod\n        ans %= mod\n    return ans\nf, w, h = list(map(int,sys.stdin.readline().split(' ')))\nmod = int(1e9 + 7)\nfac = factorial()\ncnt = calc(f, w, h)\nsys.stdout.write(str(cnt*inverse(C(f+w, w)) % mod))\n\n"
    },
    "3730": {
        "original_negative_solution": "\nn=int(input())\na=input().split(' ')\na=[int (a) for a in a]\nb=[-1 for b in range(0,n)]\n\nnow=0\n\nwhile now<n:\n    start=now\n    while (now<n-1)and(a[now]<a[now+1]):\n        now+=1\n    while start<=now:\n        b[start]=now\n        start+=1\n\n    now+=1\n    start=now\n\nans=0\n\nfor i in range(0,n):\n    if b[i]==n-1:\n        ans=max(ans,b[i]-i+1)\n    elif b[i]==n-2:\n        ans=max(ans,b[i]-i+2)\n    elif a[b[i]+2]-a[b[i]]>1:\n        ans=max(ans,b[b[i]+2]-i+1)\n    else:\n        ans=max(ans,b[i]-i+2)\n        if b[i]==0 or a[b[i]+1]-a[b[i]-1]>1:\n            ans=max(ans,b[b[i]+1]-i+1)\n    if i!=0 and n!=1 :\n        ans=max(ans,b[i]-i+2)\nprint (ans)\n\n\n\n",
        "negative_solution": "\nn=int(input())\na=input().split(' ')\na=[int (a) for a in a]\nb=[-1 for b in range(0,n)]\n\nnow=0\n\nwhile now<n:\n    start=now\n    while (now<n-1)and(a[now]<a[now+1]):\n        now+=1\n    while start<=now:\n        b[start]=now\n        start+=1\n\n    now+=1\n    start=now\n\nans=0\n\nfor i in range(0,n):\n    if b[i]==n-1:\n        ans=max(ans,b[i]-i+1)\n    elif b[i]==n-2:\n        ans=max(ans,b[i]-i+2)\n    elif a[b[i]+2]-a[b[i]]>1:\n        ans=max(ans,b[b[i]+2]-i+1)\n    else:\n        ans=max(ans,b[i]-i+2)\n        if b[i]==0 or a[b[i+1]]-a[b[i-1]]>1:\n            ans=max(ans,b[b[i]+1]-i+1)\n    if i!=0 and n!=1 :\n        ans=max(ans,b[i]-i+2)\nprint (ans)\n\n\n\n"
    },
    "3731": {
        "original_negative_solution": "def main(a, b, l, r):\n\n    \n\n    qL = (l - 1) // (2 * a + 2 * b)\n\n    rL = (l - 1) % (2 * a + 2 * b) + 1\n\n    \n\n    qR = (r - 1) // (2 * a + 2 * b)\n\n    rR = (r - 1) % (2 * a + 2 * b) + 1\n\n    #print(qL, qR, rL, rR)\n\n    if qL == qR:\n\n        #In b segment\n\n        if a < rL <= a + b and a < rR <= a + b:\n\n            return 1\n\n        if 2 * a + b < rL and 2 * a + b < rR:\n\n            return 1\n\n        #In a segment\n\n        if 1 <= rL <= a and 1 <= rR <= a:\n\n            return rR - rL + 1\n\n        if a + b < rL <= 2 * a + b and a + b < rR <= 2 * a + b:\n\n            return rR - rL + 1\n\n        #In a + b segment\n\n        if 1 <= rL <= a + b and 1 <= rR <= a + b:\n\n            return a - rL + 1\n\n        if a + b < rL and a + b < rR:\n\n            return (2 * a + b) - rL + 1\n\n        if a < rL <= a + b and a + b < rR <= 2 * a + b:\n\n            return 1 + rR - (a + b)\n\n        if a < rL <= a + b and 2 * a + b < rR:\n\n            return 1 + a\n\n        if 1 <= rL <= a and a + b < rR <= 2 * a + b:\n\n            ans = a - rL + 1 + max(rR - (a + b + b), 0) + min(b, rR) - max(min(rR, b) - rL + 1, 0)\n\n            return ans\n\n        if 1 <= rL <= a and 2 * a + b < rR:\n\n            return a - rL + 1 + a - max(b - rL + 1, 0)\n\n    elif qL == qR - 1:\n\n        #abababab\n\n        newL = qL * (2 * a + 2 * b) + 1\n\n        newR = (qR + 1) * (2 * a + 2 * b)\n\n        \n\n        if 1 <= rL <= a + b and a + b + 1 <= rR:\n\n            return a + max(a - b, 0) + int(a <= b) \n\n            \n\n        if a + b + 1 <= rL <= 2 * (a + b) and (2 * a + 2 * b) + 1 <= rR <= a + b:\n\n            return main(a, b, l - (a + b), r - (a + b))\n\n        \n\n        if 1 <= rL <= a and 1 <= rR <= a:\n\n            return a + max(a - b, 0) + int(a <= b) + rR - max(rR - rL + 1, 0)\n\n        if 1 <= rL <= a and a + 1 <= rR <= a + b:\n\n            return a + max(a - b, 0) + int(a <= b)\n\n        \n\n        if a + 1 <= rL <= a + b and 1 <= rR <= a:\n\n            return 1 + a\n\n        if a + 1 <= rL <= a + b and a + 1 <= rR <= a + b:\n\n            return 1 + a + max(a - b, 0)\n\n        \n\n        return main(a, b, l - (a + b), r - (a + b))\n\n        \n\n    else:\n\n        return a + min(a - b, 0) + int(a <= b) # + main(a, b, l, (qL + 1) * (2 * a + 2 * b)) + main(a, b, qR * (2 * a + 2 * b) + 1, r)\n\n\n\na, b, l, r = [int(item) for item in input().split()]\n\n\n\nprint(main(a, b, l, r))\n\n\n\n# Made By Mostafa_Khaled\n",
        "negative_solution": "def main(a, b, l, r):\n\n    \n\n    qL = (l - 1) // (2 * a + 2 * b)\n\n    rL = (l - 1) % (2 * a + 2 * b) + 1\n\n    \n\n    qR = (r - 1) // (2 * a + 2 * b)\n\n    rR = (r - 1) % (2 * a + 2 * b) + 1\n\n    #print(qL, qR, rL, rR)\n\n    if qL == qR:\n\n        #In b segment\n\n        if a < rL <= a + b and a < rR <= a + b:\n\n            return 1\n\n        if 2 * a + b < rL and 2 * a + b < rR:\n\n            return 1\n\n        #In a segment\n\n        if 1 <= rL <= a and 1 <= rR <= a:\n\n            return rR - rL + 1\n\n        if a + b < rL <= 2 * a + b and a + b < rR <= 2 * a + b:\n\n            return rR - rL + 1\n\n        #In a + b segment\n\n        if 1 <= rL <= a + b and 1 <= rR <= a + b:\n\n            return a - rL + 1\n\n        if a + b < rL and a + b < rR:\n\n            return (2 * a + b) - rL + 1\n\n        if a < rL <= a + b and a + b < rR <= 2 * a + b:\n\n            return 1 + rR - (a + b)\n\n        if a < rL <= a + b and 2 * a + b < rR:\n\n            return 1 + a\n\n        if 1 <= rL <= a and a + b < rR <= 2 * a + b:\n\n            ans = a - rL + 1 + max(rR - (a + b + b), 0) + min(b, rR) - max(min(rR, b) - rL + 1, 0)\n\n            return ans\n\n        if 1 <= rL <= a and 2 * a + b < rR:\n\n            return a - rL + 1 + a - max(b - rL + 1, 0)\n\n    elif qL == qR - 1:\n\n        #abababab\n\n        newL = qL * (2 * a + 2 * b) + 1\n\n        newR = (qR + 1) * (2 * a + 2 * b)\n\n        \n\n        if 1 <= rL <= a + b and a + b + 1 <= rR:\n\n            return a + max(a - b, 0) + int(a <= b) \n\n            \n\n        if a + b + 1 <= rL <= 2 * (a + b) and (2 * a + 2 * b) + 1 <= rR <= a + b:\n\n            return main(a, b, l - (a + b), r - (a + b))\n\n        \n\n        if 1 <= rL <= a and 1 <= rR <= a:\n\n            return a + max(a - b, 0) + int(a <= b) + rR - max(rR - rL + 1, 0)\n\n        if 1 <= rL <= a and a + 1 <= rR <= a + b:\n\n            return a + max(a - b, 0) + int(a <= b)\n\n        \n\n        if a + 1 <= rL <= a + b and 1 <= rR <= a:\n\n            return 1 + a\n\n        if a + 1 <= rL <= a + b and a + 1 <= rR <= a + b:\n\n            return 1 + a + max(a - b, 0)\n\n        \n\n        return main(a, b, l - (a + b), r - (a + b))\n\n        \n\n    else:\n\n        return a + max(a - b, 0) + int(a <= b) # + main(a, b, l, (qL + 1) * (2 * a + 2 * b)) + main(a, b, qR * (2 * a + 2 * b) + 1, r)\n\n\n\na, b, l, r = [int(item) for item in input().split()]\n\n\n\nprint(main(a, b, l, r))\n\n\n\n# Made By Mostafa_Khaled\n"
    },
    "3732": {
        "original_negative_solution": "def doit():\n    x, y, m = [int(k) for k in input().strip().split()]\n    if x < y:\n        x, y = y, x\n    if x >= m:\n        print(0)\n        return\n\n    if x<=0 and y<=0:\n        print(-1)\n        return\n\n    k = 0\n    if y < 0:\n        k = (-y+x-1)//x\n        y += k*x\n        assert(y >= 0)\n    if x < y:\n        x, y = y, x\n        \n    while x < m:\n        k += 1\n        x, y = x+y, x\n        if x < y:\n            x, y = y, x\n    print(k)\n\ndoit()\n",
        "negative_solution": "def doit():\n    x, y, m = [int(k) for k in input().strip().split()]\n    if x < y:\n        x, y = y, x\n    if x >= m:\n        print(0)\n        return\n\n    if x<=0 and y<=0:\n        print(-1)\n        return\n\n    k = 0\n    if y < 0:\n        k = (-y+x-1)//x\n        y += k*x\n        assert(y >= 0)\n    if x < y:\n        x, y = y, x\n        \n    while x < m:\n        k += 1\n        x, y = x+y, x\n        if x >= y:\n            x, y = y, x\n    print(k)\n\ndoit()\n"
    },
    "3733": {
        "original_negative_solution": "from itertools import groupby as gb\n\nN, I = map(int,input().split())\nA = list(map(int,input().split()))\nA = sorted(A)\nl = []\nG = gb(A)\nfor k, v in G:\n    l.append(len(list(v)))\n\nk = 100\nwhile True:\n    if N * k > 8 * I:\n        k -= 1\n    else:\n        break\nK = 2 ** k\n\nNN = len(l)\nif NN <= K:\n    print(0)\n    return\n\nsm = sum(l[:K])\nmx = sm\n\nfor i in range(K, NN):\n    sm += l[i] - l[i - K]\n    mx = max(mx, sm)\n\nprint(sum(l) - mx)",
        "negative_solution": "from itertools import groupby as gb\n\nN, I = map(int,input().split())\nA = list(map(int,input().split()))\nA = sorted(A)\nl = []\nG = gb(A)\nfor k, v in G:\n    l.append(len(list(v)))\n\nk = 100\nwhile True:\n    if N * k > 8 * I:\n        k -= 1\n    else:\n        break\nK = 2 ** k\n\nNN = len(l)\nif NN <= K:\n    print(0)\n    return\n\nsm = sum(l[:K])\nmx = sm\n\nfor i in range(K, NN):\n    sm += l[i + K] - l[i - K]\n    mx = max(mx, sm)\n\nprint(sum(l) - mx)"
    },
    "3734": {
        "original_negative_solution": "__author__ = 'Think'\nday1=input()\nday2=input()\ndays={\"monday\":1, \"tuesday\":2, \"wednesday\":3, \"thursday\":4, \"friday\":5, \"saturday\":6, \"sunday\":7}\nnum1=days[day1]\nnum2=days[day2]\ndiff=(num2-num1)%7\nif diff in [0, 2, 3]:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")",
        "negative_solution": "__author__ = 'Think'\nday1=input()\nday2=input()\ndays={\"monday\":1, \"tuesday\":2, \"wednesday\":3, \"thursday\":4, \"friday\":5, \"saturday\":6, \"sunday\":7}\nnum1=days[day1]\nnum2=days[day2]\ndiff=(num1-num2)%7\nif diff in [0, 2, 3]:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")"
    },
    "3735": {
        "original_negative_solution": "n = int(input())\na = [0]\n\nfor i in range(13):\n\tfor j in range(1, 10):\n\t\ta += [int(str(j) + i * '9')]\n\nmx = 0\n\nfor i in a:\n\tif i <= n:\n\t\tmx = max(mx, sum(map(int, str(i))) + sum(map(int, str(n-i))))\n\nprint(mx)",
        "negative_solution": "n = int(input())\na = [0]\n\nfor i in range(13):\n\tfor j in range(1, 10):\n\t\ta += [int(str(j) + i * '9')]\n\nmx = 0\n\nfor i in a:\n\tif i <= n:\n\t\tmx = max(mx, sum(map(int, str(i))) + max(map(int, str(n-i))))\n\nprint(mx)"
    },
    "3736": {
        "original_negative_solution": "a = input()\nfor i in range(len(a)):\n\tif a[i] != a[len(a) - i - 1] or a[i] not in ('A','H','I','M','O','T','U','V','W','X','Y'):\n\t\tprint(\"NO\")\n\t\treturn\nprint(\"YES\")",
        "negative_solution": "a = input()\nfor i in range(len(a)):\n\tif a[i] != a[len(a) - i] or a[i] not in ('A','H','I','M','O','T','U','V','W','X','Y'):\n\t\tprint(\"NO\")\n\t\treturn\nprint(\"YES\")"
    },
    "3737": {
        "original_negative_solution": "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    worst = a[0]\n    best = a[-1]\n    ans = 0\n    for x in a:\n        if worst < x and x < best:\n            ans += 1\n\n    print(ans)\n\nmain()\n",
        "negative_solution": "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    worst = a[0]\n    best = a[-1]\n    ans = 0\n    for x in a:\n        if x < worst and x < best:\n            ans += 1\n\n    print(ans)\n\nmain()\n"
    },
    "3738": {
        "original_negative_solution": "a,b=input().split()\n\na=int(a)\nb=int(b)\n\ns=input()\nn=len(s)\nL=[]\n\nx=0\ny=0\nhor=s.count('R')-s.count('L')\nver=s.count('U')-s.count('D')\nL=[[0,0]]\nfor i in range(n):\n    if(s[i]=='U'):\n        y+=1\n    elif(s[i]=='D'):\n        y-=1\n    elif(s[i]=='R'):\n        x+=1\n    else:\n        x-=1\n    L.append([x,y])\nk=True\nfor i in range(n+1):\n    x=L[i][0]\n    y=L[i][1]\n    if(hor==0 and ver==0 and x==a and b==y):\n        print('Yes')\n        k=False\n        break\n    elif(hor==0 and ver!=0 and x==a and (b-y)%ver==0 and (b-y)*ver>=0):\n        print('Yes')\n        k=False\n        break\n    elif(ver==0 and hor!=0 and y==b and (a-x)%hor==0 and (a-x)*hor>=0):\n        print('Yes')\n        k=False\n        break\n    elif(ver!=0 and hor!=0 and(b-y)%ver==0 and ver*(b-y)>=0 and (a-x)%hor==0 and hor*(a-x)>=0 and(b-y)//ver==(a-x)//hor):\n        print('Yes')\n        k=False\n        break\n\nif(k):\n    print('No')\n\n        \n",
        "negative_solution": "a,b=input().split()\n\na=int(a)\nb=int(b)\n\ns=input()\nn=len(s)\nL=[]\n\nx=0\ny=0\nhor=s.count('R')-s.count('L')\nver=s.count('U')-s.count('D')\nL=[[0,0]]\nfor i in range(n):\n    if(s[i]=='U'):\n        y+=1\n    elif(s[i]=='D'):\n        y-=1\n    elif(s[i]=='R'):\n        x+=1\n    else:\n        x-=1\n    L.append([x,y])\nk=True\nfor i in range(n+1):\n    x=L[i][0]\n    y=L[i][1]\n    if(hor==0 and ver==0 and x==a and b==y):\n        print('Yes')\n        k=False\n        break\n    elif(hor==0 and ver!=0 and x==a and (b-y)%ver==0 and (b-y)*ver>=0):\n        print('Yes')\n        k=False\n        break\n    elif(ver==0 and hor!=0 and y==b and (a-x)%hor==0 and (a-x)*hor>=0):\n        print('Yes')\n        k=False\n        break\n    elif(ver==hor and(b-y)%ver==0 and ver*(b-y)>=0 and (a-x)%hor==0 and hor*(a-x)>=0 and(b-y)//ver==(a-x)//hor):\n        print('Yes')\n        k=False\n        break\n\nif(k):\n    print('No')\n\n        \n"
    },
    "3740": {
        "original_negative_solution": "#!/usr/bin/env python3\nimport math\nimport random\n\nclass Prime:\n    seed_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n    def is_prime(self, n):\n        is_prime_common = self.is_prime_common(n)\n        if is_prime_common is not None:\n            return is_prime_common\n\n        if n < 2000000:\n            return self.is_prime_bf(n)\n        else:\n            return self.is_prime_mr(n)\n\n    def is_prime_common(self, n):\n        if n == 1: return False\n        if n in Prime.seed_primes: return True\n        if any([n % x == 0 for x in self.seed_primes]): return False\n\n    def is_prime_bf(self, n):\n        for k in range(2, int(math.sqrt(n)) + 1):\n            if n % k == 0:\n                return False\n        return True\n\n    def is_prime_mr(self, n):\n        d = n - 1\n        while d % 2 == 0:\n            d //= 2\n\n        witnesses = self.get_witnesses(n)\n        #witnesses = [random.randint(1, n - 1) for _ in range(100)]\n\n        for w in witnesses:\n            t = d\n            y = pow(w, t, n)\n\n            while t != n - 1 and y != 1 and y != n - 1:\n                y = (y ** 2) % n\n                t *= 2\n\n            if y != n - 1 and t % 2 == 0:\n                return False\n\n        return True\n\n    def get_witnesses(self, num):\n        def _get_range(num):\n            if num < 2047:\n                return 1\n            if num < 1373653:\n                return 2\n            if num < 25326001:\n                return 3\n            if num < 3215031751:\n                return 4\n            if num < 2152302898747:\n                return 5\n            if num < 3474749660383:\n                return 6\n            if num < 341550071728321:\n                return 7\n            if num < 38255123056546413051:\n                return 9\n            return 12\n\n        return self.seed_primes[:_get_range(num)]\n\n    def gcd(self, a, b):\n        if a < b:\n            a, b = b, a\n        if b == 0:\n            return a\n        while b:\n            a, b = b, a % b\n        return a\n\n    @staticmethod\n    def f(x, n, seed):\n        p = Prime.seed_primes[seed % len(Prime.seed_primes)]\n        return (p * x + seed) % n\n\n    def find_factor(self, n, seed=1):\n        if self.is_prime(n):\n            return n\n\n        x, y, d = 2, 2, 1\n        count = 0\n        while d == 1:\n            count += 1\n            x = self.f(x, n, seed)\n            y = self.f(self.f(y, n, seed), n, seed)\n            d = self.gcd(abs(x - y), n)\n\n        if d == n:\n            return self.find_factor(n, seed+1)\n        return self.find_factor(d)\n\n    def find_factors(self, n):\n        primes = {}\n        if self.is_prime(n):\n            primes[n] = 1\n            return primes\n\n        while n > 1:\n            factor = self.find_factor(n)\n\n            primes.setdefault(factor, 0)\n            primes[factor] += 1\n\n            n //= factor\n\n        return primes\n\n\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while 0 < b:\n        a, b = b, a % b\n    return a\n\n\ndef powmod(a, x, m):\n    y = 1\n    while 0 < x:\n        if x % 2 == 1:\n            y *= a\n            y %= m\n        x //= 2\n        a = a ** 2\n        a %= M\n\n    return y\n\nM = 10 ** 9 + 7\nprime = Prime()\n\n\ndef solve(s):\n\n    if s == 1:\n        return 9\n\n    ans = 0\n\n    n = 1\n    c = 9\n    while n * c < s:\n        n += 1\n        c *= 10\n\n    ans += s // n\n\n    for log_r in range(n - 1, n + 1):\n        c_r = 9 * 10 ** (log_r - 1)\n        sum_r = log_r * c_r\n        for log_l in range(1, log_r):\n            mid_f = 0\n            for i in range(log_l + 1, log_r):\n                mid_f += i * 9 * 10 ** (i - 1)\n            if s <= mid_f:\n                continue\n            res = s - mid_f\n            c_l = 9 * 10 ** (log_l - 1)\n            if log_l * c_l + sum_r < res:\n                continue\n            g = gcd(log_r, log_l)\n            if res % g != 0:\n                continue\n            c_l_max = min(c_l, (res - 1) // log_l)\n            while 0 < c_l_max:\n                if (res - log_l * c_l_max) % log_r == 0: break\n                c_l_max -= 1\n            if c_l_max == 0:\n                continue\n            c_l_min = 1\n            if sum_r < res:\n                c_l_min = (res - sum_r + log_l - 1) // log_l\n            div = log_r // g\n            ans += (c_l_max - c_l_min + div) // div\n\n\n    factors = prime.find_factors(s)\n    num_prime_factors = len(factors)\n    prime_factors = []\n    count_limit = []\n    count = [0] * num_prime_factors\n    for k in list(factors.keys()):\n        prime_factors.append(k)\n        count_limit.append(factors[k])\n\n    loop = True\n    while loop:\n        p = 1\n        for i, f in enumerate(prime_factors):\n            p *= f ** count[i]\n        if n <= p:\n            ans += 9 * powmod(10, p - 1, M)\n            ans += M - s // p\n            ans %= M\n\n        count[0] += 1\n        for i, limit in enumerate(count_limit):\n            if limit < count[i]:\n                if i == num_prime_factors - 1:\n                    loop = False\n                    break\n                count[i + 1] += 1\n                count[i] = 0\n\n    return ans\n\ndef main():\n\n    s = int(input())\n\n    print((solve(s)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()",
        "negative_solution": "#!/usr/bin/env python3\nimport math\nimport random\n\nclass Prime:\n    seed_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n    def is_prime(self, n):\n        is_prime_common = self.is_prime_common(n)\n        if is_prime_common is not None:\n            return is_prime_common\n\n        if n < 2000000:\n            return self.is_prime_bf(n)\n        else:\n            return self.is_prime_mr(n)\n\n    def is_prime_common(self, n):\n        if n == 1: return False\n        if n in Prime.seed_primes: return True\n        if any([n % x == 0 for x in self.seed_primes]): return False\n\n    def is_prime_bf(self, n):\n        for k in range(2, int(math.sqrt(n)) + 1):\n            if n % k == 0:\n                return False\n        return True\n\n    def is_prime_mr(self, n):\n        d = n - 1\n        while d % 2 == 0:\n            d //= 2\n\n        witnesses = self.get_witnesses(n)\n        #witnesses = [random.randint(1, n - 1) for _ in range(100)]\n\n        for w in witnesses:\n            t = d\n            y = pow(w, t, n)\n\n            while t != n - 1 and y != 1 and y != n - 1:\n                y = (y ** 2) % n\n                t *= 2\n\n            if y != n - 1 and t % 2 == 0:\n                return False\n\n        return True\n\n    def get_witnesses(self, num):\n        def _get_range(num):\n            if num < 2047:\n                return 1\n            if num < 1373653:\n                return 2\n            if num < 25326001:\n                return 3\n            if num < 3215031751:\n                return 4\n            if num < 2152302898747:\n                return 5\n            if num < 3474749660383:\n                return 6\n            if num < 341550071728321:\n                return 7\n            if num < 38255123056546413051:\n                return 9\n            return 12\n\n        return self.seed_primes[:_get_range(num)]\n\n    def gcd(self, a, b):\n        if a < b:\n            a, b = b, a\n        if b == 0:\n            return a\n        while b:\n            a, b = b, a % b\n        return a\n\n    @staticmethod\n    def f(x, n, seed):\n        p = Prime.seed_primes[seed % len(Prime.seed_primes)]\n        return (p * x + seed) % n\n\n    def find_factor(self, n, seed=1):\n        if self.is_prime(n):\n            return n\n\n        x, y, d = 2, 2, 1\n        count = 0\n        while d == 1:\n            count += 1\n            x = self.f(x, n, seed)\n            y = self.f(self.f(y, n, seed), n, seed)\n            d = self.gcd(abs(x - y), n)\n\n        if d == n:\n            return self.find_factor(n, seed+1)\n        return self.find_factor(d)\n\n    def find_factors(self, n):\n        primes = {}\n        if self.is_prime(n):\n            primes[n] = 1\n            return primes\n\n        while n > 1:\n            factor = self.find_factor(n)\n\n            primes.setdefault(factor, 0)\n            primes[factor] += 1\n\n            n //= factor\n\n        return primes\n\n\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while 0 < b:\n        a, b = b, a % b\n    return a\n\n\ndef powmod(a, x, m):\n    y = 1\n    while 0 < x:\n        if x % 2 == 1:\n            y *= a\n            y %= m\n        x //= 2\n        a = a ** 2\n        a %= M\n\n    return y\n\nM = 10 ** 9 + 7\nprime = Prime()\n\n\ndef solve(s):\n\n    if s == 1:\n        return 9\n\n    ans = 0\n\n    n = 1\n    c = 9\n    while n * c < s:\n        n += 1\n        c *= 10\n\n    ans += s // n\n\n    for log_r in range(n - 1, n + 1):\n        c_r = 9 * 10 ** (log_r - 1)\n        sum_r = log_r * c_r\n        for log_l in range(1, log_r):\n            mid_f = 0\n            for i in range(log_l + 1, log_r):\n                mid_f += i * 9 * 10 ** (i - 1)\n            if s <= mid_f:\n                continue\n            res = s - mid_f\n            c_l = 9 * 10 ** (log_l - 1)\n            if log_l * c_l + sum_r < res:\n                continue\n            g = gcd(log_r, log_l)\n            if res % g != 0:\n                continue\n            c_l_max = min(c_l, (res - 1) // log_l)\n            while 0 < c_l_max:\n                if (res - log_l * c_l_max) % log_r == 0: break\n                c_l_max -= 1\n            if c_l_max == 0:\n                continue\n            c_l_min = 1\n            if sum_r < res:\n                c_l_min = (res - sum_r + log_l - 1) // log_l\n            div = log_r // g\n            ans += (c_l_max - c_l_min + div) // div\n\n\n    factors = prime.find_factors(s)\n    num_prime_factors = len(factors)\n    prime_factors = []\n    count_limit = []\n    count = [0] * num_prime_factors\n    for k in list(factors.keys()):\n        prime_factors.append(k)\n        count_limit.append(factors[k])\n\n    loop = True\n    while loop:\n        p = 1\n        for i, f in enumerate(prime_factors):\n            p *= f ** count[i]\n        if n <= p:\n            ans += 6 * powmod(10, p - 1, M)\n            ans += M - s // p\n            ans %= M\n\n        count[0] += 1\n        for i, limit in enumerate(count_limit):\n            if limit < count[i]:\n                if i == num_prime_factors - 1:\n                    loop = False\n                    break\n                count[i + 1] += 1\n                count[i] = 0\n\n    return ans\n\ndef main():\n\n    s = int(input())\n\n    print((solve(s)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()"
    },
    "3741": {
        "original_negative_solution": "from collections import Counter, deque\n\nn = int(input())\narr = list([x for x in map(int, input().strip().split()) if x != 0])\n\n'''\nfor i, a in enumerate(arr):\n    for j, b in enumerate(arr):\n        if a & b != 0 and i != j:\n            print(i,j,a,b)\nreturn\n'''\n\nc = Counter()\n\nfor each in arr:\n    for b in range(0, 64):\n        if (1 << b) & each != 0:\n            c[b] += 1\n            if c[b] >= 3:\n                print(3)\n                return\n\nans = 1234567\n\nfor idx, st in enumerate(arr):\n    dists = {}\n    q = deque()\n    q.append((idx, -1))\n    dists[idx] = 0\n\n    while q:\n        node, par = q[0]\n        dist = dists[node]\n        q.popleft()\n        for idx2, v in enumerate(arr):\n            if idx2 == par:\n                continue\n            if idx2 == node or (v & arr[node]) == 0:\n                continue\n            if idx2 in dists:\n                candidate = dists[idx2] + dist + 1\n                if candidate != 2:\n                    ans = min(ans, candidate)\n                continue\n            dists[idx2] = dist + 1\n            q.append((idx2, node))\n\n\nif ans == 1234567:\n    print(-1)\nelse:\n    print(ans)\n",
        "negative_solution": "from collections import Counter, deque\n\nn = int(input())\narr = list([x for x in map(int, input().strip().split()) if x != 0])\n\n'''\nfor i, a in enumerate(arr):\n    for j, b in enumerate(arr):\n        if a & b != 0 and i != j:\n            print(i,j,a,b)\nreturn\n'''\n\nc = Counter()\n\nfor each in arr:\n    for b in range(0, 64):\n        if (1 << b) & each != 0:\n            c[b] += 1\n            if c[b] >= 3:\n                print(3)\n                return\n\nans = 1234567\n\nfor idx, st in enumerate(arr):\n    dists = {}\n    q = deque()\n    q.append((idx, -1))\n    dists[idx] = 0\n\n    while q:\n        node, par = q[0]\n        dist = dists[node]\n        q.popleft()\n        for idx2, v in enumerate(arr):\n            if idx2 == par:\n                continue\n            if idx2 == node or (v & arr[node]) == 0:\n                continue\n            if idx2 in dists:\n                candidate = dists[idx2] + dist\n                if candidate != 2:\n                    ans = min(ans, candidate)\n                continue\n            dists[idx2] = dist + 1\n            q.append((idx2, node))\n\n\nif ans == 1234567:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    "3742": {
        "original_negative_solution": "n = int(input())\na = list(map(int, input().split()))\nINF = 10**5\n\ndp = [[[INF]*(n+1) for i in range(n+1)] for i in range(2)]\ndp[0][0][0] = 0\ndp[1][0][0] = 0\n\nfor i in range(n):\n    if a[i] != 0:\n        parity = a[i] % 2\n        if parity % 2 == 0:\n            for j in range(n+1):\n                dp[0][i+1][j] = min(dp[0][i][j], dp[0][i+1][j])\n                dp[0][i+1][j] = min(dp[1][i][j] + 1, dp[0][i+1][j])\n        if parity % 2 == 1:\n            for j in range(n):\n                dp[1][i+1][j+1] = min(dp[1][i][j], dp[1][i+1][j+1])\n                dp[1][i+1][j+1] = min(dp[0][i][j] + 1, dp[1][i+1][j+1])\n    else:\n        for j in range(n+1):\n            dp[0][i+1][j] = min(dp[0][i][j], dp[0][i+1][j])\n            dp[0][i+1][j] = min(dp[1][i][j] + 1, dp[0][i+1][j])\n        for j in range(n):\n            dp[1][i+1][j+1] = min(dp[1][i][j], dp[1][i+1][j+1])\n            dp[1][i+1][j+1] = min(dp[0][i][j] + 1, dp[1][i+1][j+1])\n\nodd_cnt = (n+1) // 2\neven_cnt = n // 2\n\nprint(min(dp[1][n][odd_cnt], dp[0][n][odd_cnt]))\n",
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\nINF = 10**5\n\ndp = [[[INF]*(n+1) for i in range(n+1)] for i in range(2)]\ndp[0][0][0] = 0\ndp[1][0][0] = 0\n\nfor i in range(n):\n    if a[i] != 0:\n        parity = a[i] % 2\n        if parity % 2 == 0:\n            for j in range(n+1):\n                dp[0][i+1][j] = min(dp[0][i][j], dp[0][i+1][j])\n                dp[0][i+1][j] = min(dp[1][i][j] + 1, dp[0][i+1][j])\n        if parity % 2 == 1:\n            for j in range(n):\n                dp[1][i+1][j+1] = min(dp[1][i][j], dp[1][i+1][j+1])\n                dp[1][i+1][j+1] = min(dp[1][i][j] + 1, dp[1][i+1][j+1])\n    else:\n        for j in range(n+1):\n            dp[0][i+1][j] = min(dp[0][i][j], dp[0][i+1][j])\n            dp[0][i+1][j] = min(dp[1][i][j] + 1, dp[0][i+1][j])\n        for j in range(n):\n            dp[1][i+1][j+1] = min(dp[1][i][j], dp[1][i+1][j+1])\n            dp[1][i+1][j+1] = min(dp[0][i][j] + 1, dp[1][i+1][j+1])\n\nodd_cnt = (n+1) // 2\neven_cnt = n // 2\n\nprint(min(dp[1][n][odd_cnt], dp[0][n][odd_cnt]))\n"
    },
    "3743": {
        "original_negative_solution": "import sys\ninput = sys.stdin.readline\n\nx=int(input())\n\nif x==1:\n    print(1)\n    return\n\nimport math \nL=int(math.sqrt(x))\n\nFACT=dict()\n\nfor i in range(2,L+2):\n    while x%i==0:\n        FACT[i]=FACT.get(i,0)+1\n        x=x//i\n\nif x!=1:\n    FACT[x]=FACT.get(x,0)+1\n\nif len(FACT)>1:\n    print(1)\nelse:\n    print(list(FACT.keys())[0])\n",
        "negative_solution": "import sys\ninput = sys.stdin.readline\n\nx=int(input())\n\nif x==1:\n    print(1)\n    return\n\nimport math \nL=int(math.sqrt(x))\n\nFACT=dict()\n\nfor i in range(2,L+2):\n    while x%i!=0:\n        FACT[i]=FACT.get(i,0)+1\n        x=x//i\n\nif x!=1:\n    FACT[x]=FACT.get(x,0)+1\n\nif len(FACT)>1:\n    print(1)\nelse:\n    print(list(FACT.keys())[0])\n"
    },
    "3745": {
        "original_negative_solution": "n,m = list(map(int,input().split()))\nconnectionList = []\nfor _ in range(n):\n    connectionList.append([0] * n)\nfor _ in range(m):\n    p,q = list(map(int,input().split()))\n    connectionList[p-1][q-1] = 1\n    connectionList[q-1][p-1] = 1\nisDone = False\nrefList = []\nans = [\"N\"] * n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            continue\n        if connectionList[i][j] == 0:\n            isDone = True\n            refList = (i,j)\n            ans[i] = \"a\"\n            ans[j] = \"c\"\n            break\n    if isDone:\n        break\nif not isDone:\n    print(\"Yes\")\n    print(\"a\" * n)\nelse:\n    isPossible = True\n    for i in range(n):\n        if i in refList:\n            continue\n        else:\n            if connectionList[i][refList[0]] == 1 and connectionList[i][refList[1]] == 1:\n                ans[i] = \"b\"\n            elif connectionList[i][refList[0]] == 0 and connectionList[i][refList[1]] == 1:\n                ans[i] = \"c\"\n            elif connectionList[i][refList[0]] == 1 and connectionList[i][refList[1]] == 0:\n                ans[i] = \"a\"\n            else:\n                isPossible = False\n                break\n    if not isPossible:\n        print(\"No\")\n    else:\n        isValid = True\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if connectionList[i][j] == 0 and ((ans[i] == \"a\" and ans[j] == \"c\") or (ans[j] == \"a\" and ans[i] == \"c\")):\n                    pass\n                elif (not connectionList[i][j] == 0) and (not ((ans[i] == \"a\" and ans[j] == \"c\") or (ans[j] == \"a\" and ans[i] == \"c\"))):\n                    pass\n                else:\n                    isValid = False\n        if isValid:\n            print(\"Yes\")\n            print(''.join(ans))\n        else:\n            print(\"No\")\n\n\n",
        "negative_solution": "n,m = list(map(int,input().split()))\nconnectionList = []\nfor _ in range(n):\n    connectionList.append([0] * n)\nfor _ in range(m):\n    p,q = list(map(int,input().split()))\n    connectionList[p-1][q-1] = 1\n    connectionList[q-1][p-1] = 1\nisDone = False\nrefList = []\nans = [\"N\"] * n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            continue\n        if connectionList[i][j] == 0:\n            isDone = True\n            refList = (i,j)\n            ans[i] = \"a\"\n            ans[j] = \"c\"\n            break\n    if isDone:\n        break\nif not isDone:\n    print(\"Yes\")\n    print(\"a\" * n)\nelse:\n    isPossible = True\n    for i in range(n):\n        if i in refList:\n            continue\n        else:\n            if connectionList[i][refList[0]] == 1 and connectionList[i][refList[1]] == 1:\n                ans[i] = \"b\"\n            elif connectionList[i][refList[0]] == 0 and connectionList[i][refList[1]] == 1:\n                ans[i] = \"c\"\n            elif connectionList[i][refList[0]] == 1 and connectionList[i][refList[1]] == 0:\n                ans[i] = \"a\"\n            else:\n                isPossible = False\n                break\n    if not isPossible:\n        print(\"No\")\n    else:\n        isValid = True\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if connectionList[i][j] == 0 and ((ans[i] == \"a\" and ans[j] == \"c\") or (ans[i] == \"a\" and ans[j] == \"c\")):\n                    pass\n                elif (not connectionList[i][j] == 0) and (not ((ans[i] == \"a\" and ans[j] == \"c\") or (ans[j] == \"a\" and ans[i] == \"c\"))):\n                    pass\n                else:\n                    isValid = False\n        if isValid:\n            print(\"Yes\")\n            print(''.join(ans))\n        else:\n            print(\"No\")\n\n\n"
    }
}