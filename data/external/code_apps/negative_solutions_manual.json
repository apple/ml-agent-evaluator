{
    "3689": {
        "negative_solution": "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn,k = list(map(int, input().split()))\na = list(map(int, input()))\nb = a[:k]\nc = [b[i%k] for i in range(n)]\nif tuple(a)>tuple(c):\n    d = int(\"\".join(map(str, b)))\n    d -= 1\n    b = list(map(int, str(d)))\n    c = [b[i%k] for i in range(n)]\nprint(len(c))\nprint(\"\".join(map(str, c)))\n\n"
    },
    "3690": {
        "negative_solution": "used = [0] * 121\nh, m, s, t1, t2 = map(int, input().split())\nh %= 24\nt1 %= 12\nt2 %= 12\nt1 *= 5\nt2 *= 5\nused[h * 5] = 1\nused[h * 5 + 60] = 1\nused[m] = 1\nused[m + 60] = 1\nused[s] = 1\nused[s + 60] = 1\nif t1 > t2:\n    t1, t2 = t2, t1\nt3 = t1 + 60\nif sum(used[t1:t2]) == 0 or sum(used[t2:t3]) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
    },
    "3691": {
        "negative_solution": "x0, y0, A, C, B, D = list(map(int, input().split()))\n\npts = [[x0, y0]]\nfor i in range(100):\n\tnx, ny = [pts[-1][0] * A + B, pts[-1][1] * C + D]\n\tpts.append([nx, ny])\n\tif max(nx, ny) > 10000000000000000 * 10000000000000000: break\n\n\nx, y, t = list(map(int, input().split()))\n# print (pts[0])\n# print (pts[1])\n# print (pts[2])\n# print (pts[3])\n_max = 0\nfor i in range(len(pts)):\n\tfor j in range(len(pts)):\n\t\tif abs(pts[i][0] - pts[j][0]) + abs(pts[i][1] - pts[j][1]) + abs(x - pts[i][0]) + abs(y - pts[i][1]) > t:\n\t\t\t_max = max(_max, abs(i - j) + 1)\nprint(_max)\n"
    },
    "3693": {
        "negative_solution": "a = list(map(int, input().split()))\nb = list(map(int, input().split()))\nx1 = min(a[0], a[2], a[4], a[6])\nx2 = max(a[0], a[2], a[4], a[6])\ny1 = min(a[1], a[3], a[5], a[7])\ny2 = max(a[1], a[3], a[5], a[7])\nd1 = min(b[0] - b[1], b[2] - b[3], b[4] - b[5], b[6] - b[7])\nd2 = max(b[0] - b[1], b[2] - b[3], b[4] - b[5], b[6] - b[7])\ns1 = min(b[0] + b[1], b[2] + b[3], b[4] + b[5], b[6] + b[7])\ns2 = max(b[0] + b[1], b[2] + b[3], b[4] + b[5], b[6] + b[7])\nfor x in range(-100, 101):\n    for y in range(-100, 101):\n        d = x - y\n        s = x + y\n        if x1 <= x <= x2 and y1 <= y <= y2 and s1 <= s <= s2 and d1 > d:\n            print(\"YES\")\n            return\nprint(\"NO\")"
    },
    "3694": {
        "negative_solution": "n = int(input())\na = list(map(int,input().split()))\n\ndupes = 0\ndupeVal = -1\nd = set()\nfor el in a:\n    if el in d:\n        dupes += 1\n        dupeVal = el\n    else:\n        d.add(el)\n\ninPlay = True\nif dupes > 1:\n    print('cslnb')\n    inPlay = False\nelif dupes == 1:\n    if dupeVal == 0 or (dupeVal - 1) in d:\n        print('cslnb')\n        inPlay = False\n\nif inPlay:\n    finalSum = (n*n)//2\n    Sum = sum(a)\n    if (Sum - finalSum) % 2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n    \n"
    },
    "3695": {
        "negative_solution": "n, t = map(int,input().split())\nwait = list(map(int,input().split()))\nseg = []\nfor i in range(n):\n    # to get the food in wait[i], wait __ seconds before running\n    m = max(0, wait[i]-i-1)\n    M = t-i-2\n    if m > M: continue\n    seg.append((m, -1))\n    seg.append((M, 1))\nseg.sort()\n\nans = 0\ncur = 0\nfor t, q in seg:\n    cur+= q\n    ans = max(ans, cur)\nprint(ans)"
    },
    "3696": {
        "negative_solution": "n = int(input())\n\na, b = [1], [0]\n\nfor i in range(n):\n\tnew_b = a[:]\n\ta1 = a[:]\n\ta2 = a[:]\n\ta1.append(0)\n\ta2.append(0)\n\tfor i in range(-1, -len(b) - 1, -1):\n\t\ta1[i] += b[i]\n\tfor i in range(-1, -len(b) - 1, -1):\n\t\ta2[i] -= b[i]\n\tif max([abs(kek) for kek in a1]) < 2:\n\t\ta = a1\n\telif max([abs(kek) for kek in a2]) < 2:\n\t\ta = a2\n\telse:\n\t\tprint(\"oops\")\n\t\treturn\n\tb = new_b\nprint(len(a))\nprint(*(a[::-1]))\nprint(len(b))\nprint(*(b[::-1]))"
    },
    "3697": {
        "negative_solution": "class State:\n  __slots__ = ['candidate', 'votes', 'last_vote']\n\n  def __init__(self, cand, votes, last):\n    self.candidate = cand\n    self.votes = votes\n    self.last_vote = last\n\n  def beats(self, other, extra):\n    return self.votes + extra > other.votes\n\ndef main():\n  candidates, seats, people, voted = map(int, input().split())\n  votes = [0 for i in range(candidates)]\n  last_vote = [0 for i in range(candidates)]\n\n  if candidates == 1:\n    print(1)\n    return\n\n  v = list(map(int, input().split()))\n  for t in range(voted):\n    cand = v[t] - 1\n    votes[cand] += 1\n    last_vote[cand] = t\n\n  states = [State(i, votes[i], last_vote[i]) for i in range(candidates)]\n  states = sorted(states, key = lambda x : (x.votes, -x.last_vote))\n  res = [0 for i in range(candidates)]\n\n  for i in range(candidates):\n    if i < candidates - seats:\n      low = candidates - seats\n      if states[i].beats(states[low], people - voted):\n        res[states[i].candidate] = 3\n      else:\n        res[states[i].candidate] = 4\n    else:\n      extra = people - voted\n      other = i - 1\n      place = i\n\n      if extra == 0 and states[i].votes == 0:\n        res[states[i].candidate] = 3\n        continue\n\n      while other >= 0 and extra > 0:\n        needed = states[i].votes - states[other].votes + 1\n        if needed <= extra:\n          extra -= needed;\n          place -= 1\n          other -= 1\n        else:\n          break\n\n      res[states[i].candidate] = (1 if place + seats >= candidates and states[i].votes > 0 else 2)\n\n  for i in res:\n    print(i, end = ' ')\n\nmain()\n"
    },
    "3698": {
        "negative_solution": "mas = [[] for i in range(1001)]\nmas[0].append(1)\nmas[0].append(1)\nfor i in range(1, 1000):\n    mas[i].append(1)\n    for j in range(1, i):\n        mas[i].append((mas[i - 1][j] + mas[i - 1][j - 1]) % (10 ** 9 + 7))\n    mas[i].append(1)\n\n\ndef c(k, n):\n    if k > n:\n        return 0\n    if k < 0:\n        return 0\n    nonlocal mas\n    return mas[n][k]\n\n\nm = [0] * 1000\nfor i in range(1, 1000):\n    nw = i\n    t = 0\n    while nw != 1:\n        nw = sum([int(j) for j in str(bin(nw)[2:])])\n        t += 1\n    m[i] = t\nm[1] = 0\nn = input()\nk = int(input())\nif k >= 6:\n    print(0)\n    return\nif k == 0:\n    print(1)\n    return\nif k == 1:\n    print(len(n) - 1)\n    return\nans = 0\nfor kkk in range(1, 100):\n    if m[kkk] == k - 1:\n        nw = kkk\n        t = 0\n        for i in range(len(n)):\n            if n[i] == '1':\n                ans += c(nw - t, len(n) - 1 - i)\n                ans %= 10 ** 9 + 7\n                t += 1\n        if sum([int(j) for j in n]) == kkk:\n            ans += 1\n            ans %= 10 ** 9 + 7\n\n\nprint(ans)\n"
    },
    "3699": {
        "negative_solution": "from math import *\n\nax, ay, bx, by, cx, cy = [int(t) for t in input().split()]\nn = int(input())\ndist = 0\nmaxv = [[-inf, -inf], [-inf, -inf]]\nindex = [[0,0], [0,0]]\n\ndef update(d, idx, p):\n    nonlocal maxv, index\n    if d > maxv[p][0]:\n        maxv[p][1] = maxv[p][0]\n        index[p][1] = index[p][0]\n        maxv[p][0] = d\n        index[p][0] = idx\n    elif d > maxv[p][1]:\n        maxv[p][1] = d\n        index[p][1] = idx\n\nfor i in range(n):\n    x, y = [int(t) for t in input().split()]\n    bottle_recycle = sqrt((cx - x) ** 2 + (cy - y) ** 2)\n    dist += bottle_recycle * 2\n    dista = bottle_recycle - sqrt((ax - x) ** 2 + (ay - y) ** 2)\n    distb = bottle_recycle - sqrt((bx - x) ** 2 + (by - y) ** 2)\n    update(dista, i, 0)\n    update(distb, i, 1)\n\nans = dist - maxv[0][0]\nans = min(ans, dist - maxv[1][0])\nif(index[0][0] == index[1][0]):\n    ans = min(ans, dist - maxv[0][0] - maxv[1][0])\nelif(n > 1):\n    ans = min(ans, dist - maxv[0][1] - maxv[1][0], dist - maxv[0][0] - maxv[1][1])\nprint(ans)"
    },
    "3700": {
        "negative_solution": "#!/usr/bin/env python3\nn, k = list(map(int, input().split()))\nans = max(0, min(n, k - 2) - k // 2)\nprint(ans)\n"
    },
    "3701": {
        "negative_solution": "n, x, y = map(int, input().split())\na = input()\ncnt = 0\nprev = '1'\nfor ai in a:\n  if prev == '1' and ai == '0': cnt += 1\n  prev = ai\nif cnt == 0:\n  print(0)\nelse:\n  print(min(x,y)*(cnt-1)+y*2)"
    },
    "3702": {
        "negative_solution": "n,a,d=map(int,input().split())\nprint(368131125*a%10**9*13*10**9+1,368131125*d%10**9*13*10**9)"
    },
    "3703": {
        "negative_solution": "from math import sqrt, ceil\n\nMAX_N = 10 ** 6 * 2 \n\n\nprime = []\nisPrime = [True for i in range(MAX_N)]\n\nfor i in range(2, MAX_N):\n    if isPrime[i]:\n        prime.append(i)\n        for j in range(i * i, MAX_N, i):\n            isPrime[j] = False\n\n\ndef factor(a):\n    divs = []\n    for i in prime:\n        cnt = 0\n        while a % i == 0:\n            a //= i\n            cnt += 1\n\n        if cnt:\n            divs.append((i, cnt,))\n\n    if a > 1:\n        divs.append((a, 1,))\n\n    return divs\n\n\ndef f(n):\n    ans = 1\n    for div in factor(n):\n        ans *= div[0] ** (div[1] - 1) * (div[0] - 1)\n\n    return ans\n\ndef g(n):\n    return n\n\ndef F(n, k):\n    cur = n\n    for i in range(1, k + 1):\n        #print(i)\n        #print(factor(cur))\n        if i == 1:\n            cur = f(g(cur))\n        elif i % 2 - 1 == 0:\n            cur = g(cur)\n        else:\n            cur = f(cur)\n\n        #print(i, cur)\n\n        if cur == 1:\n            break\n\n    return cur % (10 ** 9 + 7)\n\nn, k = [int(i) for i in input().split(' ')]\n#print(factor(n - 1))\nprint(F(n, k))\n"
    },
    "3704": {
        "negative_solution": "#!/usr/bin/env python3\n# Copied solution\n\nimport collections\nimport sys\nimport traceback\n\nclass Input(object):\n    def __init__(self):\n        self.fh = sys.stdin\n\n    def next_line(self):\n        while True:\n            line = sys.stdin.readline()\n            if line == '\\n':\n                continue\n            return line\n\n\n    def next_line_ints(self):\n        line = self.next_line()\n        return [int(x) for x in line.split()]\n\n    def next_line_strs(self):\n        line = self.next_line()\n        return line.split()\n\nclass Node(object):\n    def __init__(self, color, subtree_color):\n        self.left = self.right = None\n        self.color = color\n        self.subtree_color = subtree_color\n\ndef list_to_number(list):\n    \"\"\"Return (color, bits, number).\"\"\"\n    color = 1 if list[0] == '-' else 2\n    values = list[1:].split('/')\n    bits = 32\n    if len(values) == 2:\n        bits = int(values[1])\n    nums = values[0].split('.')\n    number = 0\n    for num in nums:\n        number = number * 256 + int(num)\n    return (color, bits, number)\n\ndef add_list_to_tree(tree, list):\n    color, bits, number = list_to_number(list)\n    shift = 31\n    for _ in range(bits):\n        tree.subtree_color |= color\n        value = (number >> shift) & 1\n        if value == 0:\n            if not tree.left:\n                tree.left = Node(0, 0)\n            tree = tree.left\n        else:\n            if not tree.right:\n                tree.right = Node(0, 0)\n            tree = tree.right\n        shift -= 1\n    tree.subtree_color |= color\n    tree.color |= color\n\ndef check_tree(tree):\n    if not tree:\n        return True\n    if tree.color == 3 or (tree.color and (tree.subtree_color & ~tree.color)):\n        return False\n    return check_tree(tree.left) and check_tree(tree.right)\n\ndef number_to_list(number, bits):\n    number <<= (16 - bits)\n    values = []\n    for _ in range(4):\n        #print('number = {}'.format(number))\n        values.append(str(number % 256))\n        number //= 256\n    values = values[::-1]\n    return '.'.join(values) + '/' + str(bits)\n\ndef get_optimized(tree, optimized, number, bits):\n    if not tree or (tree.subtree_color & 1) == 0:\n        return\n    if tree.subtree_color == 1:\n        list = number_to_list(number, bits)\n        #print('number_to_list({}, {}) = {}'.format(number, bits, list))\n        optimized.append(list)\n        return\n    get_optimized(tree.left, optimized, number * 2, bits + 1)\n    get_optimized(tree.right, optimized, number * 2 + 1, bits + 1)\n\n\ndef get_optimized_lists(lists):\n    tree = Node(0, 0)\n    for list in lists:\n        add_list_to_tree(tree, list)\n    if not check_tree(tree):\n        return None\n    optimized = []\n    get_optimized(tree, optimized, 0, 0)\n    return optimized\n\n\ndef main():\n    input = Input()\n    while True:\n        try:\n            nums = input.next_line_ints()\n            if not nums:\n                break\n            n, = nums\n            if n == -1:\n                break\n            lists = []\n            for _ in range(n):\n                lists.append(input.next_line_strs()[0])\n        except:\n            print('read input failed')\n        try:\n            optimized = get_optimized_lists(lists)\n            if optimized is None:\n                print(\"-1\")\n            else:\n                print(\"{}\".format(len(optimized)))\n                for l in optimized:\n                    print(\"{}\".format(l))\n        except:\n            traceback.print_exc(file=sys.stdout)\n            print('get_min_dist failed')\n\nmain()"
    },
    "3705": {
        "negative_solution": "n=int(input())\ns=list(input())\nprint(min(s.count('8'),n//10))"
    },
    "3706": {
        "negative_solution": "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nrealg=[list(map(int,input().split())) for _ in range(n)]\ng=[[0]*m for _ in range(n)]\n\nans=[]\n\n# get differences\nf1=min([realg[0][i] for i in range(m)])\nfor i in range(m):\n    for _ in range(realg[0][i]-f1):\n        ans.append(\"col %d\"%(i+1))\n    for j in range(n):\n        g[j][i]+=realg[0][i]-f1\n\nf2=min([realg[i][0] for i in range(n)])\nfor i in range(n):\n    for _ in range(realg[i][0]+f2):\n        ans.append(\"row %d\"%(i+1))\n    for j in range(m):\n        g[i][j]+=realg[i][0]-f2\n\n# check\nbad=0\nfloor=realg[0][0]-g[0][0]\nfor i in range(n):\n    for j in range(m):\n        if realg[i][j]-g[i][j]!=floor:\n            bad=1\n\nif bad: print(\"-1\")\nelse:\n    # get floor done\n    if n<m:\n        for i in range(n):\n            for j in range(floor): ans.append(\"row %d\"%(i+1))\n    else:\n        for i in range(m):\n            for j in range(floor): ans.append(\"col %d\"%(i+1))\n    print(len(ans))\n    print(\"\\n\".join(ans))\n"
    },
    "3707": {
        "negative_solution": "import collections as col\nimport itertools as its\nimport sys\nimport operator\nfrom bisect import bisect_left, bisect_right\nfrom copy import copy, deepcopy\nfrom math import factorial as fact\n\n\nclass Solver:\n    def __init__(self):\n        pass\n\n    def solve(self):\n        n, t, k, d = list(map(int, input().split()))\n        n = (n + k) // k\n        if d < (n-1) * t:\n            print('YES')\n        else:\n            print('NO')\n\n\ndef __starting_point():\n    s = Solver()\n    s.solve()\n\n__starting_point()"
    },
    "3708": {
        "negative_solution": "__author__ = 'Pavel Mavrin'\n\nn, m = [int(x) for x in input().split()]\na = []\nfor i in range(m):\n    a.append([int(x) - 1 for x in input().split()])\n\na.sort(key=lambda x: x[0] * n + x[1])\na.append([n - 1, n])\n\nd = [[0, 1]]\nr = 0\ni = 0\nwhile i < len(a):\n    if a[i][0] == r:\n        dd = []\n        j = 0\n        while i < len(a) and a[i][0] == r and j < len(d):\n            if a[i][1] > d[j][0]:\n                i += 1\n            elif a[i][1] == d[j][0]:\n                d[j][0] += 1\n                if d[j][0] >= d[j][1]:\n                    j += 1\n                i += 1\n            else:\n                dd.append([d[j][0], a[i][1]])\n                d[j][0] = a[i][1] + 1\n                while j < len(d) and d[j][1] <= a[i][1] + 1:\n                    j += 1\n                if j < len(d):\n                    d[j][0] = max(d[j][0], a[i][1] + 1)\n        if j < len(d):\n            dd.append([d[j][0], n])\n        while i < len(a) and (a[i][0] == r):\n            i += 1\n        d = dd\n        r += 1\n        if len(d) == 0:\n            break\n    else:\n        r = a[i][0]\n        d = [[d[0][0], n]]\n    #print(r, i, d)\n\nif len(d) == 0 or d[len(d) - 1][1] < n:\n    print(-1)\nelse:\n    print(2 * (n - 1))\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    "3709": {
        "negative_solution": "def bel(mask, bit):\n    return (mask & (1 << bit)) != 0\nread = lambda: map(int, input().split())\nn, k = read()\nf = [0] * 100\nfor i in range(n):\n    cur = int(''.join(input().split()), 2)\n    cur ^= (1 << k) - 1\n    f[cur] = 1\nans = 'NO'\nif k == 1:\n    if f[0]:\n        ans = 'YES'\nif k == 2:\n    f1 = f2 = 0\n    for i in range(4):\n        if f[i]:\n            if bel(i, 0): f1 = 1\n            if bel(i, 1): f2 = 1\n    if f1 and f2:\n        ans = 'YES'\nif k == 3:\n    p = [0] * 3\n    for i in range(8):\n        if f[i]:\n            for j in range(3):\n                if bel(i, j): p[j] = 1\n    for i in range(8):\n        if f[i]:\n            if bel(i, 0) and bel(i, 1) and p[2]: ans = 'YES'\n            if bel(i, 0) and p[1] and bel(i, 2): ans = 'YES'\n            if p[0] and bel(i, 1) and bel(i, 2): ans = 'YES'\nif k == 4:\n    for i in range(16):\n        if f[i]:\n            for j in range(16):\n                if f[j]:\n                    if (i | j) == 15:\n                        ans = 'YES'\nprint(ans)"
    },
    "3710": {
        "negative_solution": "from math import *\nfrom sys import *\nn, k = map(int, stdin.readline().split(\" \"))\na = 1;\nfor c in map(int, stdin.readline().split(\" \")):\n  a = a * (gcd(k, c)//gcd(a, k))\nif a%k == 0:\n  print(\"Yes\")\nelse:\n  print(\"No\")"
    },
    "3711": {
        "negative_solution": "n,m,k = [int(x) for x in input().split()]\n\nif k+2>n+m:\n    print(-1)\nelse:\n    if k < n:\n        alpha = m // (k-n+2)\n    else:\n        alpha = m * (n // (k+1))\n    if k >= m:\n        beta = n // (k-m+2)\n    else:\n        beta = n * (m // (k + 1))\n    print(max(alpha, beta))\n"
    },
    "3712": {
        "negative_solution": "#! /usr/bin/env python\n\nn = int(input())\ncounts = [0] * 5\nnums = [int(x) for x in input().split()]\nfor x in nums:\n    counts[x] += 1\n\ns = sum(nums)\nif s > 3 and s != 5:\n    ans = 0\n    if counts[1] >= counts[2]:\n        ans += counts[2]\n        counts[3] += counts[2]\n        counts[1] -= counts[2]\n        ans += 2 * (counts[1] // 3)\n        counts[3] += counts[1] // 3\n        counts[1] %= 3\n        if counts[3] > 0:\n            ans += counts[1]\n        elif counts[1] != 0:\n            ans += 2\n    else:\n        ans += counts[1]\n        counts[2] -= counts[1]\n        ans += 2 * (counts[2] // 3)\n        counts[2] %= 3\n        if counts[4] > 0:\n            ans += counts[2]\n        elif counts[2] != 0:\n            ans += 2\n    print(ans)\nelse:\n    print(-1)\n"
    },
    "3713": {
        "negative_solution": "x = int(input())\ny = input()\nif x <= 3:\n    print(x)\n    quit()\n\nnum1 = 0\nnum0 = 0\nfor i in y:\n    if i == '1':\n        num1 = max(num1, num0+1)\n    else:\n        num0 = max(num0, num1+1)\n\nmaxx = max(num1, num0)\nif '11' not in y and '00' not in y:\n    print(maxx)\n    quit()\n\nprint(min(maxx+1, x))"
    },
    "3714": {
        "negative_solution": "n = int(input())\nw = list(map(int, input().split()))\nw = [x for x in w]\n\nws = sorted(w)\nfor i in range(n):\n\tif i != ws[i]:\n\t\tprint(-1)\n\t\treturn\n\na = []\nvis = [False] * n\nfor i in range(n):\n\tif not vis[i]:\n\t\ta.append(0)\n\t\tj = i\n\t\twhile not vis[j]:\n\t\t\ta[-1] += 1\n\t\t\tvis[j] = True\n\t\t\tj = w[j]\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\nans = 1\nfor i in a:\n\tif i % 2 == 0:\n\t\ti //= 2\n\tans = ans // gcd(ans, i) * i\nprint(ans)\n"
    },
    "3715": {
        "negative_solution": "import sys\n\ninp = sys.stdin\n#inp = open('input.txt', 'r')\n\nn = int(inp.readline())\na = list(map(int, inp.readline().split()))\n\n\nbest = [0, 0, 0]\nfor i in range(n):\n    nx_best = [0, 0, 0]\n    if a[i] in (1, 2):\n        nx_best[1] = max(best[0], best[2]) + 1\n    if a[i] in (3, 4):\n        nx_best[2] = max(best[0], best[1]) + 1\n    nx_best[0] = max(best)\n\n    best = nx_best[:]\n\nprint(n - max(best))\n"
    },
    "3716": {
        "negative_solution": "def gcd(a, b):\n    c = a % b\n    return gcd(b, c) if c else b\n\ns, a = 0, int(input())\nif a < 3: print(a)\nelse:\n    while a ** 3 > s:\n        b = a - 1\n        while a * a * b * b > s:\n            if gcd(a, b) == 1:\n                d = a * b\n                c = b - 1\n                while d * c > s:\n                    if gcd(c, d) == 1: s = d * c\n                    c -= 1\n            b -= 1\n        a -= 1\n    print(s)"
    },
    "3717": {
        "negative_solution": "def excl_max_list(a):\n    first_max = max(a)\n    imax = a.index(first_max)\n    second_max = max(a[:imax] + a[imax + 1:])\n    return [second_max if elem == first_max else first_max for elem in a]\n\ndef excl_min_list(a):\n    first_min = min(a)\n    imin = a.index(first_min)\n    second_min = min(a[:imin] + a[imin + 1:])\n    return [second_min if elem != first_min else first_min for elem in a]\n\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for i in range(n)]\nlefts = [l for l, d, r, u in rectangles]\nrights = [r for l, d, r, u in rectangles]\ndowns = [d for l, d, r, u in rectangles]\nups = [u for l, d, r, u in rectangles]\n\nmax_lefts = excl_max_list(lefts)\nmax_downs = excl_max_list(downs)\nmin_rights = excl_min_list(rights)\nmin_ups = excl_min_list(ups)\n\nfor i in range(n):\n    if max_lefts[i] <= min_rights[i] and max_downs[i] <= min_ups[i]:\n        print(max_lefts[i], max_downs[i])\n        break\n"
    },
    "3718": {
        "negative_solution": "n = int(input())\na = sorted(list(set(map(int, input().split()))))\n\nfor i in range(2, len(a)):\n    if a[i] - a[i - 2] <= 3:\n        print('YES')\n        break\nelse:\n    print('NO')\n"
    }
}