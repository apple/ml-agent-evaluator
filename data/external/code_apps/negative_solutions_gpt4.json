{
    "3689": {
        "negative_solution": "n, k = map(int, input().split())\nx = list(map(int, list(input().strip())))\ny = x[:k] * (n // k) + x[:n % k]\nif y < x:\n    i = k - 1\n    while y[i] == 9:\n        y[i] = 0\n        i -= 1\n    y[i] += 1\n    y = y[:k] * (n // k) + y[:n % k]\nprint(n)\nprint(''.join(map(str, y)))\n"
    },
    "3690": {
        "negative_solution": "h, m, s, t1, t2 = map(int, input().split())\nh %= 12\nt1 %= 12\nt2 %= 12\nh = h * 3600 + m * 60 + s\nt1 *= 3600\nt2 *= 3600\nm = m * 720 + s * 12\ns *= 720\nt = [0] * 43200\nt[h] = t[m] = t[s] = 1\nif t1 > t2:\n    t1, t2 = t2, t1\nf1 = sum(t[t1:t2]) > 0\nf2 = sum(t[t1:43200]) + sum(t[0:t2]) > 0\nif f1 ^ f2:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n"
    },
    "3691": {
        "negative_solution": "def dist(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef solve():\n    x0, y0, ax, ay, bx, by = map(int, input().split())\n    xs, ys, t = map(int, input().split())\n    p = [(x0, y0)]\n    while True:\n        x, y = p[-1]\n        nx, ny = ax*x + bx, ay*y + by\n        if dist((nx, ny), (xs, ys)) > t:\n            break\n        p.append((nx, ny))\n    ans = 0\n    for l in range(len(p)):\n        for r in range(l, len(p)):\n            d = dist(p[l], p[r]) + min(dist((xs, ys), p[l]), dist((xs, ys), p[r]))\n            if d <= t:\n                ans = max(ans, r - l + 1)\n    print(ans)\n\nsolve()\n"
    },
    "3692": {
        "negative_solution": "import math\n\ndef dist(a, b):\n    return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\ndef intersect(a, b):\n    return dist(a, b) <= a[2] + b[2]\n\nn = int(input().strip())\ncircles = [list(map(int, input().strip().split())) for _ in range(n)]\nedges = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if intersect(circles[i], circles[j]):\n            edges += 1\nprint(edges + n + 1)\n"
    },
    "3693": {
        "negative_solution": "from shapely.geometry import Polygon\n\ndef do_squares_intersect(square1, square2):\n    # Create Polygon objects from the squares' coordinates\n    square1 = Polygon([(square1[i], square1[i+1]) for i in range(0, len(square1), 2)])\n    square2 = Polygon([(square2[i], square2[i+1]) for i in range(0, len(square2), 2)])\n\n    # Check if the squares intersect\n    if square1.intersects(square2):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test the function\nprint(do_squares_intersect([0, 0, 6, 0, 6, 6, 0, 6], [1, 3, 3, 5, 5, 3, 3, 1]))  # Output: YES\nprint(do_squares_intersect([0, 0, 6, 0, 6, 6, 0, 6], [7, 3, 9, 5, 11, 3, 9, 1]))  # Output: NO\nprint(do_squares_intersect([6, 0, 6, 6, 0, 6, 0, 0], [7, 4, 4, 7, 7, 10, 10, 7]))  # Output: YES\n"
    },
    "3694": {
        "negative_solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[1] == 0:\n        print(\"cslnb\")\n        return\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            if i > 1 and a[i - 2] + 1 == a[i] or i < n - 1 and a[i + 1] == a[i]:\n                print(\"cslnb\")\n                return\n            a[i] -= 1\n            break\n    a.sort()\n    s = sum(a)\n    s -= n * (n - 1) // 2\n    if s % 2 == 0:\n        print(\"cslnb\")\n    else:\n        print(\"sjfnb\")\n\nsolve()\n"
    },
    "3695": {
        "negative_solution": "import heapq\n\ndef dog_show(n, T, t):\n    t = [t[i] - i - 1 for i in range(n)]\n    heap = []\n    ans = 0\n    for i in range(n):\n        if t[i] < T:\n            heapq.heappush(heap, -t[i])\n            if len(heap) > T:\n                heapq.heappop(heap)\n            ans = max(ans, len(heap))\n    return ans\n\nn, T = map(int, input().split())\nt = list(map(int, input().split()))\nprint(dog_show(n, T, t))\n"
    },
    "3696": {
        "negative_solution": "n = int(input())\na = [[0], [1]]\nfor i in range(2, n + 2):\n    a.append(a[-1] + [0] + a[-2])\nprint(n)\nprint(*a[-2])\nprint(n - 1)\nprint(*a[-3])\n"
    },
    "3697": {
        "negative_solution": "n, k, m, a = map(int, input().split())\ng = list(map(int, input().split()))\nvotes = [0]*n\nfor i in range(a):\n    votes[g[i]-1] += 1\nvotes.sort(reverse=True)\nif votes[k-1] > m - a:\n    for i in range(n):\n        if votes[i] > m - a:\n            print(1, end=' ')\n        else:\n            print(3, end=' ')\nelse:\n    for i in range(n):\n        if votes[i] >= votes[k-1]:\n            print(2, end=' ')\n        else:\n            print(3, end=' ')\n"
    },
    "3698": {
        "negative_solution": "MOD = 10**9 + 7\nC = [[0]*1005 for _ in range(1005)]\ndp = [[0]*1005 for _ in range(1005)]\ndp2 = [[0]*1005 for _ in range(1005)]\ndp2[0][0] = 1\nfor i in range(1001):\n    C[i][0] = 1\n    for j in range(1, i+1):\n        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD\nfor i in range(1, 1001):\n    dp[i][0] = 1\n    for j in range(1, i+1):\n        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + 2*dp[i-1][j-1]) % MOD\nfor i in range(1, 1001):\n    for j in range(i+1):\n        dp2[i][j] = (dp2[i-1][j] + dp2[i-1][j-1] + dp[i][j]) % MOD\ndef solve(s, k):\n    if k < 0:\n        return 0\n    if k == 0:\n        return 1\n    n = len(s)\n    ret = 0\n    cnt = 0\n    for i in range(n):\n        if s[i] == '1':\n            for j in range(n-i):\n                if cnt + j == k-1:\n                    ret = (ret + dp2[n-i-1][j]) % MOD\n            cnt += 1\n    if cnt == k-1:\n        ret = (ret + 1) % MOD\n    return ret\ns = input().strip()\nk = int(input().strip())\nprint(solve(s, k))\n"
    },
    "3699": {
        "negative_solution": "import math\ndef solve():\n    ax, ay, bx, by, tx, ty = map(int, input().split())\n    n = int(input())\n    bottles = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        bottles.append((x, y, math.hypot(x - tx, y - ty)))\n    bottles.sort(key=lambda x: x[2])\n    total = sum(x[2] for x in bottles) * 2\n    ans = total\n    for i in range(n):\n        ans = min(ans, total - bottles[i][2] + math.hypot(bottles[i][0] - ax, bottles[i][1] - ay))\n    for i in range(n):\n        ans = min(ans, total - bottles[i][2] + math.hypot(bottles[i][0] - bx, bottles[i][1] - by))\n    for i in range(min(n, 2)):\n        for j in range(i + 1, min(n, 2)):\n            ans = min(ans, total - bottles[i][2] - bottles[j][2] + math.hypot(bottles[i][0] - ax, bottles[i][1] - ay) + math.hypot(bottles[j][0] - bx, bottles[j][1] - by))\n    print(\"%.9f\" % ans)\n\nsolve()\n"
    },
    "3700": {
        "negative_solution": "def toy_pairs(n, k):\n    if k <= 1 or k > 2 * n:\n        return 0\n    elif k <= n + 1:\n        return (k - 1) // 2\n    else:\n        return (2 * n - k + 1) // 2\n\nn, k = map(int, input().split())\nprint(toy_pairs(n, k))\n"
    },
    "3701": {
        "negative_solution": "n, x, y = map(int, input().split())\ns = input().strip()\ns = s.split('1')\ns = [i for i in s if i != '']\ncnt = len(s)\nif cnt == 0:\n    print(0)\nelse:\n    print(min((cnt - 1) * x + y, cnt * y))\n"
    },
    "3702": {
        "negative_solution": "def solve(n, a, d):\n    b = 10**6 + a\n    e = d\n    return b, e\n\nn, a, d = map(int, input().split())\nb, e = solve(n, a, d)\nprint(b, e)\n"
    },
    "3703": {
        "negative_solution": "MOD = 10**9 + 7\nMAXN = 10**6 + 5\nphi = [0]*MAXN\nmark = [0]*MAXN\ndef sievephi():\n    for i in range(1,MAXN):\n        phi[i] = i\n    mark[1] = 1\n    for i in range(2,MAXN):\n        if(not mark[i]):\n            for j in range(i,MAXN,i):\n                mark[j] = i\n                phi[j] = phi[j]//i*(i-1)\nsievephi()\ndef f(n):\n    if(n<MAXN):\n        return phi[n]\n    i = 2\n    ans = n\n    while(i*i<=n):\n        if(n%i==0):\n            while(n%i==0):\n                n//=i\n            ans-=ans//i\n        i+=1\n    if(n>1):\n        ans-=ans//n\n    return ans%MOD\ndef g(n):\n    i = 1\n    ans = 0\n    while(i*i<n):\n        if(n%i==0):\n            ans+=f(i)\n            ans%=MOD\n            ans+=f(n//i)\n            ans%=MOD\n        i+=1\n    if(i*i==n):\n        ans+=f(i)\n        ans%=MOD\n    return ans\ndef F(k,n):\n    if(k==1):\n        return f(n)\n    if(k%2==0):\n        return g(F(k-1,n))\n    else:\n        return f(F(k-1,n))\nn,k = map(int,input().split())\nprint(F(k,n))\n"
    },
    "3704": {
        "negative_solution": "import sys\nfrom heapq import *\ninput = sys.stdin.readline\nn = int(input())\nseg = []\nfor _ in range(n):\n    s = input().strip()\n    if '/' in s:\n        s, l = s.split('/')\n        l = int(l)\n    else:\n        s, l = s, 32\n    s = s.split('.')\n    s = int(s[0]) << 24 | int(s[1]) << 16 | int(s[2]) << 8 | int(s[3])\n    seg.append((s, s + (1 << (32 - l)) - 1, l, _))\nseg.sort()\nst = []\nres = []\nfor l, r, _, i in seg:\n    while st and st[-1][1] < r:\n        if st[-1][1] > l:\n            print(-1)\n            exit(0)\n        res.append(st.pop())\n    if st and st[-1][1] > r:\n        if st[-1][0] < l:\n            print(-1)\n            exit(0)\n        res.append((st[-1][0], l - 1, st[-1][2]))\n        st[-1] = (l, r, _)\n    elif not st or st[-1][1] < l:\n        st.append((l, r, _))\nwhile st:\n    res.append(st.pop())\nres.sort()\nprint(len(res))\nfor l, r, _ in res:\n    l = [str((l >> 24) & 255), str((l >> 16) & 255), str((l >> 8) & 255), str(l & 255)]\n    r = [str((r >> 24) & 255), str((r >> 16) & 255), str((r >> 8) & 255), str(r & 255)]\n    if l == r:\n        print('.'.join(l))\n    else:\n        for i in range(4):\n            if l[i] != r[i]:\n                break\n        print('.'.join(l[:i + 1]) + '/' + str(32 - i * 8))\n"
    },
    "3705": {
        "negative_solution": "n = int(input())\ns = input()\nprint(min(s.count('8'), n // 11))\n"
    },
    "3706": {
        "negative_solution": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [[0]*m for _ in range(n)]\nc = [0]*n\nd = [0]*m\ne = []\nif n < m:\n    for i in range(n):\n        c[i] = min(a[i])\n        for j in range(m):\n            a[i][j] -= c[i]\n        e += ['row '+str(i+1)]*c[i]\n    for j in range(m):\n        d[j] = max(a[i][j] for i in range(n))\n        e += ['col '+str(j+1)]*d[j]\nelse:\n    for j in range(m):\n        d[j] = min(a[i][j] for i in range(n))\n        for i in range(n):\n            a[i][j] -= d[j]\n        e += ['col '+str(j+1)]*d[j]\n    for i in range(n):\n        c[i] = max(a[i])\n        e += ['row '+str(i+1)]*c[i]\nfor i in range(n):\n    for j in range(m):\n        b[i][j] = c[i]+d[j]\nif a != b:\n    print(-1)\nelse:\n    print(len(e))\n    print('\\n'.join(e))\n"
    },
    "3707": {
        "negative_solution": "import math\nn, t, k, d = map(int, input().split())\nif math.ceil(n/k)*t > d + t:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n"
    },
    "3708": {
        "negative_solution": "This problem cannot be solved using Python because it requires a time complexity of O(n^2) which is not feasible when n is up to 10^9. This problem is more suitable for languages like C++ which can handle larger computations more efficiently."
    },
    "3709": {
        "negative_solution": "n, k = map(int, input().split())\nproblems = [0] * (1 << k)\nfor _ in range(n):\n    problem = sum(1 << i for i, x in enumerate(input().split()) if x == '1')\n    problems[problem] += 1\nfor mask in range(1 << k):\n    if problems[mask] == 0:\n        continue\n    problems[mask] -= 1\n    for submask in range(1 << k):\n        if problems[submask] == 0 or bin(mask & submask).count('1') * 2 > bin(mask).count('1'):\n            continue\n        problems[submask] -= 1\n        break\n    else:\n        print('NO')\n        break\nelse:\n    print('YES')\n"
    },
    "3710": {
        "negative_solution": "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    n, k = map(int, input().split())\n    c = list(map(int, input().split()))\n    if k in c:\n        print(\"Yes\")\n    else:\n        lcm_val = reduce(lcm, c)\n        if lcm_val % k == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nmain()\n"
    },
    "3711": {
        "negative_solution": "def solve(n, m, k):\n    if k > n + m - 2:\n        return -1\n    if k < n:\n        x = n // (k + 1)\n    else:\n        x = n\n    if k < m:\n        y = m // (k + 1)\n    else:\n        y = m\n    return max(x, y)\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))\n"
    },
    "3712": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\nc = [0]*5\nfor i in a:\n    c[i] += 1\nx = min(c[1], c[2])\nc[1] -= x\nc[2] -= x\nif c[1]:\n    x += c[1]//3*2\n    c[1] %= 3\n    if c[1] == 1:\n        if c[3] >= 1:\n            x += 1\n        elif c[4] >= 2:\n            x += 2\n        else:\n            x = -1\n    elif c[1] == 2:\n        if c[3] >= 2 or (c[3] >= 1 and c[4] >= 1) or c[4] >= 3:\n            x += 2\n        else:\n            x = -1\nelif c[2]:\n    x += c[2]\nprint(x)\n"
    },
    "3713": {
        "negative_solution": "n = int(input())\ns = input()\ncnt = 1\nfor i in range(1, n):\n    if s[i] != s[i - 1]:\n        cnt += 1\nprint(min(n, cnt + 2))\n"
    },
    "3714": {
        "negative_solution": "from math import gcd\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nn = int(input())\na = list(map(int, input().split()))\na = [x-1 for x in a]\nb = [0]*n\nc = [0]*n\nfor i in range(n):\n    if b[i]:\n        continue\n    x = i\n    while True:\n        b[x] = i+1\n        c[x] += 1\n        x = a[x]\n        if b[x] == i+1:\n            break\n    if b[x] != i+1:\n        print(-1)\n        exit(0)\n    if c[x] % 2 == 0:\n        c[x] //= 2\nt = 1\nfor i in range(n):\n    t = lcm(t, c[i])\nprint(t)\n"
    },
    "3715": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\ndp = [[0]*3 for _ in range(n+1)]\nfor i in range(1, n+1):\n    dp[i][0] = min(dp[i-1])\n    if a[i-1] == 1 or a[i-1] == 3:\n        dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + 1\n    if a[i-1] == 2 or a[i-1] == 3:\n        dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + 1\nprint(n - max(dp[n]))"
    },
    "3716": {
        "negative_solution": "def max_lcm(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n % 2 == 1:\n        return n * (n - 1) * (n - 2)\n    elif n % 3 == 0:\n        return (n - 1) * (n - 2) * (n - 3)\n    else:\n        return n * (n - 1) * (n - 3)\n\nn = int(input())\nprint(max_lcm(n))\n"
    },
    "3717": {
        "negative_solution": "n = int(input())\nrects = [list(map(int, input().split())) for _ in range(n)]\nx1 = sorted(rects, key=lambda x: x[0])\nx2 = sorted(rects, key=lambda x: -x[2])\ny1 = sorted(rects, key=lambda x: x[1])\ny2 = sorted(rects, key=lambda x: -x[3])\nx = max(x1[-1][0], x1[-2][0])\ny = max(y1[-1][1], y1[-2][1])\nif x <= min(x2[0][2], x2[1][2]) and y <= min(y2[0][3], y2[1][3]):\n    print(x, y)\nelse:\n    x = max(x1[-1][0], x1[-3][0])\n    y = max(y1[-1][1], y1[-3][1])\n    print(x, y)\n"
    },
    "3718": {
        "negative_solution": "n = int(input())\nballs = list(map(int, input().split()))\nballs = sorted(set(balls))\nfor i in range(len(balls) - 2):\n    if balls[i + 2] - balls[i] == 2:\n        print(\"YES\")\n        exit(0)\nprint(\"NO\")\n"
    },
    "3719": {
        "negative_solution": "from bisect import bisect_left, bisect_right\n\ndef solve(n, m, a, b):\n    a.sort()\n    b.sort()\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            l = a[i:j]\n            x = len(l)\n            y = bisect_right(b, l[-1]) - bisect_left(b, l[0])\n            ans = max(ans, min(x + y, m))\n    return ans\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nprint(solve(n, m, a, b))\n"
    },
    "3720": {
        "negative_solution": "import math\n\ndef solve(n):\n    grundy = [0, 1, 2, 1, 4, 3, 2, 1, 5, 6, 2, 1, 8, 7, 5, 9, 8, 7, 3, 4, 7, 6, 8, 7, 5, 3, 8, 7, 2, 1, 1]\n    primes = [0, 0, 1, 1, 2, 1, 2, 1, 2, 1, 4, 1, 2, 1, 6, 1, 4, 1, 2, 1, 8, 1, 6, 1, 4, 1, 2, 1, 10, 3, 2]\n    xor_sum = 0\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if primes[i] == i:\n            cnt = 0\n            x = i * i\n            while x <= n:\n                x *= i\n                cnt += 1\n            xor_sum ^= grundy[cnt]\n    xor_sum ^= max(0, n - sum(primes[:int(math.sqrt(n)) + 1]) * 2)\n    return \"Vasya\" if xor_sum else \"Petya\"\n\nn = int(input())\nprint(solve(n))\n"
    },
    "3721": {
        "negative_solution": "from sys import stdin, stdout\nfrom collections import defaultdict\n\nn, m, q = map(int, stdin.readline().split())\nrows = defaultdict(list)\ncols = defaultdict(list)\nfor _ in range(q):\n    r, c = map(int, stdin.readline().split())\n    rows[r].append(c)\n    cols[c].append(r)\nvisited = [0] * (n + m + 2)\ngraph = defaultdict(list)\nfor r in rows:\n    for c in rows[r]:\n        graph[r].append(n + c)\n        graph[n + c].append(r)\nfor c in cols:\n    for r in cols[c]:\n        graph[n + c].append(r)\n        graph[r].append(n + c)\ndef dfs(v):\n    visited[v] = 1\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\ncnt = 0\nfor v in range(1, n + m + 1):\n    if not visited[v]:\n        dfs(v)\n        cnt += 1\nstdout.write(str(cnt - 1) + '\\n')\n"
    },
    "3722": {
        "negative_solution": "N = int(input())\ncAA = input()\ncAB = input()\ncBA = input()\ncBB = input()\n\nMOD = 10**9+7\n\ndp = [[[[0]*2 for _ in range(2)] for _ in range(2)] for _ in range(N+1)]\ndp[2][0][0][0] = 1\ndp[2][0][0][1] = 1\ndp[2][0][1][0] = 1\ndp[2][0][1][1] = 1\ndp[2][1][0][0] = 1\ndp[2][1][0][1] = 1\ndp[2][1][1][0] = 1\ndp[2][1][1][1] = 1\n\nfor i in range(2, N):\n    for j in range(2):\n        for k in range(2):\n            for l in range(2):\n                if dp[i][j][k][l] == 0:\n                    continue\n                if cAA == 'A':\n                    dp[i+1][j][k][0] += dp[i][j][k][l]\n                    dp[i+1][j][k][0] %= MOD\n                else:\n                    dp[i+1][1][k][0] += dp[i][j][k][l]\n                    dp[i+1][1][k][0] %= MOD\n                if cAB == 'A':\n                    dp[i+1][j][l][0] += dp[i][j][k][l]\n                    dp[i+1][j][l][0] %= MOD\n                else:\n                    dp[i+1][1][l][0] += dp[i][j][k][l]\n                    dp[i+1][1][l][0] %= MOD\n                if cBA == 'A':\n                    dp[i+1][k][j][0] += dp[i][j][k][l]\n                    dp[i+1][k][j][0] %= MOD\n                else:\n                    dp[i+1][k][1][0] += dp[i][j][k][l]\n                    dp[i+1][k][1][0] %= MOD\n                if cBB == 'A':\n                    dp[i+1][l][j][0] += dp[i][j][k][l]\n                    dp[i+1][l][j][0] %= MOD\n                else:\n                    dp[i+1][l][1][0] += dp[i][j][k][l]\n                    dp[i+1][l][1][0] %= MOD\n\nans = 0\nfor j in range(2):\n    for k in range(2):\n        for l in range(2):\n            ans += dp[N][j][k][l]\n            ans %= MOD\nprint(ans)\n"
    },
    "3723": {
        "negative_solution": "from math import sqrt\nfrom collections import Counter\n\ndef max_pokemons(n, s):\n    counter = Counter(s)\n    max_count = max(counter.values())\n    for i in range(2, int(sqrt(max(s))) + 1):\n        count = sum([counter[j] for j in range(i, max(s) + 1, i)])\n        max_count = max(max_count, count)\n    return max_count\n\nn = int(input().strip())\ns = list(map(int, input().strip().split()))\nprint(max_pokemons(n, s))\n"
    },
    "3724": {
        "negative_solution": "from collections import Counter\nfrom math import factorial as f\n\nMOD = 10**9+7\nN = int(input())\nS = input()\nc = Counter(S)\nA, B, C = c['A'], c['B'], c['C']\n\ndp = [[[0]*(C+1) for _ in range(B+1)] for _ in range(A+1)]\ndp[0][0][0] = 1\nfor i in range(A+1):\n    for j in range(B+1):\n        for k in range(C+1):\n            if i > 0:\n                dp[i][j][k] += dp[i-1][j][k] * f(i+j+k-1) // (f(i-1)*f(j)*f(k)) % MOD\n            if j > 0:\n                dp[i][j][k] += dp[i][j-1][k] * f(i+j+k-1) // (f(i)*f(j-1)*f(k)) % MOD\n            if k > 0:\n                dp[i][j][k] += dp[i][j][k-1] * f(i+j+k-1) // (f(i)*f(j)*f(k-1)) % MOD\n            dp[i][j][k] %= MOD\n\nprint(sum(dp[i][j][k] for i in range(A+1) for j in range(B+1) for k in range(C+1)) % MOD)\n"
    },
    "3725": {
        "negative_solution": "def solve():\n    m = int(input())\n    h1, a1 = map(int, input().split())\n    x1, y1 = map(int, input().split())\n    h2, a2 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    t1 = -1\n    t2 = -1\n    t3 = -1\n    t4 = -1\n    for i in range(m):\n        if h1 == a1 and t1 == -1:\n            t1 = i\n        if h1 == a1 and h2 == a2 and t2 == -1:\n            t2 = i\n        if h1 == a1 and t3 == -1:\n            t3 = i\n        if h2 == a2 and t4 == -1:\n            t4 = i\n        h1 = (x1 * h1 + y1) % m\n        h2 = (x2 * h2 + y2) % m\n    if t2 != -1:\n        print(t2)\n    elif t1 != -1 and t4 != -1 and t3 != t1:\n        print(t1 + t3 * ((t4 - t1 + t3 - 1) // t3))\n    else:\n        print(-1)\n\nsolve()\n"
    },
    "3726": {
        "negative_solution": "from collections import deque\ndef bfs():\n    dist=[-1]*(2*n+2)\n    dist[0]=0\n    q=deque([0])\n    while q:\n        v=q.popleft()\n        for u in g[v]:\n            if dist[u]==-1 and cap[v][u]-flow[v][u]>0:\n                dist[u]=dist[v]+1\n                q.append(u)\n    return dist[2*n+1]!=-1\n\ndef dfs(v,t,f):\n    if v==t:\n        return f\n    used[v]=True\n    for u in g[v]:\n        if not used[u] and cap[v][u]-flow[v][u]>0:\n            d=dfs(u,t,min(f,cap[v][u]-flow[v][u]))\n            if d>0:\n                flow[v][u]+=d\n                flow[u][v]-=d\n                return d\n    return 0\n\ndef max_flow(s,t):\n    flow=0\n    while bfs():\n        used=[0]*(2*n+2)\n        f=dfs(s,t,10**9+7)\n        while f:\n            flow+=f\n            f=dfs(s,t,10**9+7)\n    return flow\n\nn=int(input())\nx=list(map(int,input().split()))\nx.sort()\ny=[0]*(2*n+2)\nfor i in range(n):\n    y[2*i+1]=x[i]\n    y[2*i+2]=x[i]+1\ny=list(set(y))\ny.sort()\nn=len(y)-1\ng=[[] for _ in range(2*n+2)]\ncap=[[0]*(2*n+2) for _ in range(2*n+2)]\nflow=[[0]*(2*n+2) for _ in range(2*n+2)]\nfor i in range(1,n+1):\n    g[0].append(i)\n    g[i].append(0)\n    cap[0][i]=1\n    g[n+i].append(2*n+1)\n    g[2*n+1].append(n+i)\n    cap[n+i][2*n+1]=1\nfor i in range(1,n):\n    for j in range(i+1,n+1):\n        if y[j]-y[i]>1:\n            break\n        g[i].append(n+j)\n        g[n+j].append(i)\n        cap[i][n+j]=1\nprint(max_flow(0,2*n+1))"
    },
    "3727": {
        "negative_solution": "import heapq\n\ndef solve():\n    a, b, c, d = map(int, input().split())\n    nums = [a, b, c, d]\n    seq = []\n    for i in range(3, -1, -1):\n        if nums[i] > 0:\n            heapq.heappush(seq, i)\n            nums[i] -= 1\n            break\n    while nums != [0, 0, 0, 0]:\n        if len(seq) == 0 or seq[-1] + 1 < seq[0] - 1:\n            return \"NO\"\n        if nums[seq[-1] + 1] > 0:\n            heapq.heappush(seq, seq[-1] + 1)\n            nums[seq[-1] + 1] -= 1\n        elif nums[seq[0] - 1] > 0:\n            heapq.heappush(seq, seq[0] - 1)\n            nums[seq[0] - 1] -= 1\n        else:\n            return \"NO\"\n    return \"YES\\n\" + \" \".join(map(str, seq))\n\nprint(solve())\n"
    },
    "3728": {
        "negative_solution": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [[0]*m for _ in range(m)]\nfor i in range(n):\n    for j in range(m):\n        b[a[i][j]-1][j] += 1\nfor i in range(m):\n    for j in range(i+1, m):\n        c = b[i][:i] + b[j][i+1:j] + b[i][j+1:] + [b[i][i]+b[j][j]]\n        d = b[j][:i] + b[i][i+1:j] + b[j][j+1:] + [b[i][i]+b[j][j]]\n        if max(c) <= 1 and max(d) <= 1:\n            print('YES')\n            exit(0)\nprint('NO')\n"
    },
    "3729": {
        "negative_solution": "import sys\nfrom math import factorial as f\nmod = 10**9+7\nf,w,h = map(int,input().split())\nn = f+w\nfact = [1]*(n+1)\nfor i in range(1,n+1):\n    fact[i] = (fact[i-1]*i)%mod\ninv = [1]*(n+1)\ninv[n] = pow(fact[n],mod-2,mod)\nfor i in range(n-1,-1,-1):\n    inv[i] = (inv[i+1]*(i+1))%mod\ndef C(n,r):\n    if r>n or r<0:\n        return 0\n    return (fact[n]*inv[r]*inv[n-r])%mod\ndef solve(f,w,h):\n    ans = 0\n    for i in range(1,min(f,w)+1):\n        if i<h:\n            continue\n        ans += C(f+w,i)*C(i-1,f)*2\n        ans %= mod\n    if f>=w and w>=h:\n        ans += C(f+w,w)*C(w,f+1)\n        ans %= mod\n    return ans\nprint(solve(f,w,h))\n"
    },
    "3730": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na = [0] + a + [1e9 + 7]\nf = [0] * (n + 2)\ng = [0] * (n + 2)\nfor i in range(1, n + 1):\n    if a[i] > a[i - 1]:\n        f[i] = f[i - 1] + 1\n    else:\n        f[i] = 1\nfor i in range(n, 0, -1):\n    if a[i] < a[i + 1]:\n        g[i] = g[i + 1] + 1\n    else:\n        g[i] = 1\nans = max(f)\nfor i in range(1, n):\n    if a[i - 1] + 1 < a[i + 1]:\n        ans = max(ans, f[i - 1] + 1 + g[i + 1])\n    else:\n        ans = max(ans, f[i - 1] + 1, g[i + 1] + 1)\nprint(ans)\n"
    },
    "3731": {
        "negative_solution": "def solve(a, b, l, r):\n    if a > b:\n        return min(a, r - l + 1)\n    if a == b:\n        if a == 1:\n            return 1 if l % 2 == r % 2 else 2\n        return min(a + 1, r - l + 1)\n    if a == 1 and b == 2:\n        return 2 if l % 3 != r % 3 or l % 3 == 0 and r % 3 == 0 else 3\n    if a == 2 and b == 1:\n        return 2 if l % 3 != r % 3 else 3\n    if a == 2 and b == 2:\n        return 3 if l % 4 != r % 4 or l % 4 == 0 and r % 4 == 0 else 4\n    if a == 1:\n        return 1 if (r - l + 1) % (2 * b + 2) <= b else 2\n    if a == 2:\n        return 2 if (r - l + 1) % (2 * b + 2) <= b else 3\n    if a == 3:\n        return 3 if (r - l + 1) % (2 * b + 2) <= b else 4\n    return min(a + b, r - l + 1)\n\na, b, l, r = map(int, input().split())\nprint(solve(a, b, l, r))\n"
    },
    "3732": {
        "negative_solution": "x, y, m = map(int, input().split())\nif max(x, y) >= m:\n    print(0)\nelif x <= 0 and y <= 0:\n    print(-1)\nelse:\n    if x > y:\n        x, y = y, x\n    ans = 0\n    if x < 0:\n        t = (-x + y - 1) // y\n        x += t * y\n        ans += t\n    while max(x, y) < m:\n        x, y = y, x + y\n        ans += 1\n    print(ans)\n"
    },
    "3733": {
        "negative_solution": "from math import ceil, log2\nfrom collections import Counter\n\nn, I = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nc = Counter(a)\nb = list(c.values())\nb = [0] + b\nfor i in range(1, len(b)):\n    b[i] += b[i - 1]\nk = int(I * 8 / n)\nK = min(2 ** k, len(c))\nprint(min(b[i] - b[i - K] for i in range(K - 1, len(b))))\n"
    },
    "3734": {
        "negative_solution": "week = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']\na = input()\nb = input()\nif (week.index(b) - week.index(a)) % 7 in [0, 2, 3]:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n"
    },
    "3735": {
        "negative_solution": "def max_sum(n):\n    if n < 10:\n        return n\n    else:\n        return 9 + max_sum(n - 10)\n\nn = int(input())\nprint(max_sum(n))\n"
    },
    "3736": {
        "negative_solution": "def is_mirror_word(word):\n    mirror_letters = set('AHIMOTUVWXY')\n    return word == word[::-1] and set(word) <= mirror_letters\n\nword = input().strip()\nprint('YES' if is_mirror_word(word) else 'NO')\n"
    },
    "3737": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nl = a.count(a[0])\nr = a.count(a[-1])\nif a[0] == a[-1]:\n    print(0)\nelse:\n    print(n - l - r)\n"
    },
    "3738": {
        "negative_solution": "def main():\n    a, b = map(int, input().split())\n    s = input().strip()\n    n = len(s)\n    dx = [0]*n\n    dy = [0]*n\n    for i in range(n):\n        dx[i] = dx[i-1] + (s[i] == 'R') - (s[i] == 'L')\n        dy[i] = dy[i-1] + (s[i] == 'U') - (s[i] == 'D')\n    for i in range(n):\n        x = a - dx[i]\n        y = b - dy[i]\n        if x*dx[-1] >= 0 and x % dx[-1] == 0 and y*dy[-1] >= 0 and y % dy[-1] == 0 and x//dx[-1] == y//dy[-1]:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nmain()\n"
    },
    "3740": {
        "negative_solution": "MOD = 10**9+7\nS = int(input())\ndp = [0]*(S+1)\ndp[0] = 1\nfor i in range(1, S+1):\n    if i-3 >= 0:\n        dp[i] = dp[i-1] + dp[i-3]\n        dp[i] %= MOD\nprint(dp[S])\n"
    },
    "3741": {
        "negative_solution": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == 0:\n        print(3)\n        return\n    b = [0]*61\n    for i in range(n):\n        for j in range(60, -1, -1):\n            if (a[i]>>j)&1:\n                if b[j] != 0:\n                    print(3)\n                    return\n                b[j] = i+1\n                break\n    g = defaultdict(list)\n    for i in range(n):\n        for j in range(60, -1, -1):\n            if (a[i]>>j)&1:\n                if b[j] != i+1:\n                    g[i+1].append(b[j])\n                    g[b[j]].append(i+1)\n                break\n    ans = 1<<60\n    for i in range(1, n+1):\n        d = [1<<60]*(n+1)\n        d[i] = 0\n        q = [(i, 0)]\n        while q:\n            v, p = q.pop()\n            for u in g[v]:\n                if u == p:\n                    continue\n                if d[u] == 1<<60:\n                    d[u] = d[v]+1\n                    q.append((u, v))\n                else:\n                    ans = min(ans, d[v]+d[u]+1)\n    if ans == 1<<60:\n        print(-1)\n    else:\n        print(ans)\n\nsolve()\n"
    },
    "3742": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na = [0] + a + [0]\nb = [i for i in range(1, n + 1) if i not in a]\nb.sort()\nb = [0] + b + [0]\nf = [[0] * 105 for _ in range(105)]\nfor i in range(n + 2):\n    for j in range(len(b)):\n        if a[i] > 0:\n            if i > 0:\n                f[i][j] = min(f[i - 1][j] + (a[i] % 2 != a[i - 1] % 2), f[i][j])\n            if j > 0:\n                f[i][j] = min(f[i - 1][j - 1] + (a[i] % 2 != b[j] % 2), f[i][j])\n        else:\n            if i > 0:\n                f[i][j] = min(f[i - 1][j] + (b[j] % 2 != a[i - 1] % 2), f[i][j])\n            if j > 0:\n                f[i][j] = min(f[i - 1][j - 1] + (b[j] % 2 != b[j - 1] % 2), f[i][j])\nprint(min(f[n + 1]))\n"
    },
    "3743": {
        "negative_solution": "def max_colors(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\nn = int(input().strip())\nprint(max_colors(n))\n"
    },
    "3744": {
        "negative_solution": "import sys\nfrom heapq import *\ndef solve():\n    n, p, s = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = [(a[i], b[i], i + 1) for i in range(n)]\n    c.sort(reverse=True)\n    dp = [[0] * (s + 1) for _ in range(p + 1)]\n    pre = [[None] * (s + 1) for _ in range(p + 1)]\n    for i in range(1, n + 1):\n        dp1 = [dp[j][:] for j in range(p + 1)]\n        pre1 = [pre[j][:] for j in range(p + 1)]\n        for j in range(min(i, p), -1, -1):\n            for k in range(min(i - j, s), -1, -1):\n                if j + k < i:\n                    if dp1[j][k] < dp[j][k] + c[i - 1][1]:\n                        dp1[j][k] = dp[j][k] + c[i - 1][1]\n                        pre1[j][k] = (j, k, 0)\n                if j > 0 and dp1[j][k] < dp[j - 1][k] + c[i - 1][0]:\n                    dp1[j][k] = dp[j - 1][k] + c[i - 1][0]\n                    pre1[j][k] = (j - 1, k, 1)\n                if k > 0 and dp1[j][k] < dp[j][k - 1] + c[i - 1][1]:\n                    dp1[j][k] = dp[j][k - 1] + c[i - 1][1]\n                    pre1[j][k] = (j, k - 1, 0)\n        dp = dp1\n        pre = pre1\n    print(dp[p][s])\n    ans1 = []\n    ans2 = []\n    j = p\n    k = s\n    for i in range(n, 0, -1):\n        if pre[j][k][2] == 1:\n            ans1.append(c[i - 1][2])\n            j -= 1\n        else:\n            ans2.append(c[i - 1][2])\n            k -= 1\n    print(*ans1)\n    print(*ans2)\nsolve()\n"
    },
    "3745": {
        "negative_solution": "n, m = map(int, input().split())\nedges = [set() for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges[u - 1].add(v - 1)\n    edges[v - 1].add(u - 1)\nfor i in range(n):\n    if len(edges[i]) == n - 1:\n        continue\n    for j in range(i + 1, n):\n        if len(edges[j]) == n - 1:\n            continue\n        if len(edges[i] & edges[j]) != len(edges[i]) + len(edges[j]) - n + 1:\n            print('No')\n            exit(0)\ns = ['b'] * n\nfor i in range(n):\n    if len(edges[i]) == n - 1:\n        continue\n    s[i] = 'a'\n    for j in edges[i]:\n        if s[j] == 'b':\n            s[j] = 'c'\nprint('Yes')\nprint(''.join(s))\n"
    },
    "3746": {
        "negative_solution": "def solve(n, a, b, c):\n    if n == 0:\n        return 0\n    if dp[n][a][b] != -1:\n        return dp[n][a][b]\n    dp[n][a][b] = min(solve(n - 1, a, c, b) + t[a][b] + solve(n - 1, c, a, b), solve(n - 1, a, b, c) + t[a][c] + solve(n - 1, b, a, c) + t[c][b] + solve(n - 1, a, b, c))\n    return dp[n][a][b]\n\nt = [[0 for _ in range(3)] for _ in range(3)]\ndp = [[[-1 for _ in range(3)] for _ in range(3)] for _ in range(41)]\nfor i in range(3):\n    t[i] = list(map(int, input().split()))\nn = int(input())\nprint(solve(n, 0, 1, 2))\n"
    },
    "3747": {
        "negative_solution": "def main():\n    s = input().strip()\n    print(min(s.count('B'), s.count('u')//2, s.count('l'), s.count('b'), s.count('a')//2, s.count('s'), s.count('r')))\n\nmain()\n"
    },
    "3748": {
        "negative_solution": "from collections import Counter\n\nH, W = map(int, input().split())\nS = [input() for _ in range(H)]\n\ndef check(n, S):\n    cnt = Counter(S)\n    pair, single = divmod(n, 2)\n    for v in cnt.values():\n        pair -= v // 2\n        single -= v % 2\n        if pair < 0 or single < 0:\n            return False\n    return True\n\nprint(\"YES\" if check(H, [\"\".join(sorted(s)) for s in zip(*S)]) and check(W, S) else \"NO\")\n"
    },
    "3749": {
        "negative_solution": "MOD = 998244353\nN, X = input().split()\nN = int(N)\nA = [int(input(), 2) for _ in range(N)]\nX = int(X, 2)\nA.sort(key=lambda x: -x.bit_length())\n\ndef f(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ng = A[0]\nfor a in A[1:]:\n    g = f(g, a)\n\nB = [0]*4001\nfor i in range(4001):\n    B[i] = B[i-1]*2+((g>>i)&1)\n    if i < 4000:\n        B[i] %= MOD\n\ndp = [[0]*2 for _ in range(4001)]\ndp[0][0] = 1\nfor i in range(4000):\n    dp[i+1][0] += dp[i][0]\n    if (X>>i)&1:\n        dp[i+1][1] += dp[i][0]\n    dp[i+1][0] += dp[i][1]\n    dp[i+1][1] += dp[i][1]\n    dp[i+1][0] %= MOD\n    dp[i+1][1] %= MOD\n\nans = (dp[4000][0]+dp[4000][1])%MOD\nif X >= g:\n    ans = (ans+pow(2, B[X.bit_length()-1], MOD))%MOD\nprint(ans)\n"
    },
    "3750": {
        "negative_solution": "k, a, b = map(int, input().split())\nif a < b:\n    a, b = b, a\nif a // k == 0:\n    print(-1)\nelif a // k == 1 and b < k:\n    print(-1)\nelse:\n    print(a // k + b // k)\n"
    },
    "3751": {
        "negative_solution": "def kostya_obfuscation(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for i in range(len(s)):\n        if s[i] > alphabet[i]:\n            return 'NO'\n    return 'YES'\n\ns = input().strip()\nprint(kostya_obfuscation(s))\n"
    },
    "3752": {
        "negative_solution": "from math import ceil\nk, d, t = map(int, input().split())\nt *= 2\ncycle = ceil(k / d) * d\non = min(k, cycle)\noff = cycle - on\nif on >= t:\n    print(t / 2)\nelse:\n    t -= on\n    print(on / 2 + ceil(t / (on + off)) * cycle - (on + off - t % (on + off)) / 2)\n"
    },
    "3753": {
        "negative_solution": "def main():\n    n, m = map(int, input().split())\n    a = [list(input()) for _ in range(n)]\n    dp1 = [[0]*m for _ in range(n)]\n    dp2 = [[0]*m for _ in range(n)]\n    dp1[0][0] = 1\n    dp2[n-1][m-1] = 1\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == '#':\n                continue\n            if i > 0:\n                dp1[i][j] += dp1[i-1][j]\n            if j > 0:\n                dp1[i][j] += dp1[i][j-1]\n    for i in range(n-1, -1, -1):\n        for j in range(m-1, -1, -1):\n            if a[i][j] == '#':\n                continue\n            if i < n-1:\n                dp2[i][j] += dp2[i+1][j]\n            if j < m-1:\n                dp2[i][j] += dp2[i][j+1]\n    if dp1[n-1][m-1] == 0:\n        print(0)\n        return\n    for i in range(n):\n        for j in range(m):\n            if dp1[i][j] > 0 and dp2[i][j] > 0 and dp1[i][j] == dp1[n-1][m-1] and dp2[i][j] == dp2[0][0]:\n                print(1)\n                return\n    print(2)\n\nmain()\n"
    },
    "3754": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nmod = 998244353\nN = int(input())\nd = list(map(int,input().split()))\nd.sort()\nd.append(0)\nd = [0] + d\nfact = [1]*(N+1)\ninv = [1]*(N+1)\nfor i in range(1,N+1):\n    fact[i] = fact[i-1]*i%mod\n    inv[i] = pow(fact[i],mod-2,mod)\ndef comb(n,k):\n    return fact[n]*inv[k]*inv[n-k]%mod\nans = 0\nfor i in range(1,N+1):\n    if d[i] >= N:\n        ans += comb(N,i)*fact[i]%mod*fact[N-i]%mod\n        ans %= mod\n    else:\n        ans += comb(N,i)*fact[i]%mod*fact[N-i-1]%mod*d[i]%mod\n        ans %= mod\nprint(ans)\n"
    },
    "3755": {
        "negative_solution": "N = int(input())\nA = list(map(int, input().split()))\n\nif max(A) <= 0:\n    idx = A.index(max(A))\n    print(A[idx])\n    print(N-1)\n    for i in range(idx+1, N):\n        print(N)\n    for i in range(idx):\n        print(1)\nelse:\n    dp = [[-10**18]*N for _ in range(N)]\n    for i in range(N):\n        dp[i][i] = A[i]\n    for i in range(N-1):\n        if dp[i][i] > 0:\n            dp[i+1][i+1] = max(dp[i+1][i+1], dp[i][i] + A[i+1])\n        dp[i+1][i] = max(dp[i+1][i], dp[i][i])\n    ans = max(dp[i][i] for i in range(N))\n    print(ans)\n    idx = [i for i in range(N) if dp[i][i] == ans][-1]\n    seq = [idx+1]\n    for i in range(idx, 0, -1):\n        if dp[i][i] == dp[i-1][i-1] + A[i]:\n            seq.append(i)\n        else:\n            seq.append(i+1)\n    print(len(seq))\n    for i in seq[::-1]:\n        print(i)\n"
    },
    "3756": {
        "negative_solution": "n, t = map(int, input().split())\ns = list(input())\ndot = s.index('.')\ni = dot + 1\nwhile i < len(s) and s[i] < '5':\n    i += 1\nif i == len(s):\n    print(''.join(s))\nelse:\n    while t > 0 and i > dot:\n        if s[i] >= '5':\n            s[i] = ''\n            if s[i-1] == '.':\n                j = i - 2\n                while s[j] == '9':\n                    s[j] = '0'\n                    j -= 1\n                s[j] = str(int(s[j]) + 1)\n                i -= 2\n            else:\n                s[i-1] = str(int(s[i-1]) + 1)\n                i -= 1\n            t -= 1\n        else:\n            break\n    if s[0] == '0':\n        s = ['1'] + s\n    print(''.join(s).rstrip('.'))\n"
    },
    "3757": {
        "negative_solution": "from math import sqrt\na00, a01, a10, a11 = map(int, input().split())\nn0 = int((sqrt(1 + 8 * a00) - 1) / 2)\nn1 = int((sqrt(1 + 8 * a11) - 1) / 2)\nif n0 * (n0 - 1) // 2 != a00 or n1 * (n1 - 1) // 2 != a11 or n0 + n1 > 1000000:\n    print('Impossible')\nelse:\n    if n0 == 0 and n1 == 0:\n        if a01 + a10 > 0:\n            print('Impossible')\n        else:\n            print('0')\n    elif n0 == 0:\n        if a01 + a10 > 0:\n            print('Impossible')\n        else:\n            print('1' * n1)\n    elif n1 == 0:\n        if a01 + a10 > 0:\n            print('Impossible')\n        else:\n            print('0' * n0)\n    else:\n        if a01 + a10 != n0 * n1:\n            print('Impossible')\n        else:\n            s = ['0'] * n0 + ['1'] * n1\n            for i in range(n1 - 1, -1, -1):\n                if a10 >= n0:\n                    a10 -= n0\n                    s.insert(a10, '1')\n                else:\n                    s.insert(a10, '1')\n                    break\n            print(''.join(s))\n"
    },
    "3758": {
        "negative_solution": "def check(mid):\n    last = [0]*len(p)\n    for i in range(len(p)):\n        if i == 0:\n            last[i] = max(2*a[0], a[-1])\n        else:\n            j = last[i-1]\n            while j < len(a) and a[j] <= p[i] + mid:\n                j += 1\n            if j == len(a):\n                last[i] = max(2*a[-1], p[i] + mid)\n            elif a[j] > p[i] + mid and a[j-1] <= p[i] + mid/2:\n                last[i] = max(2*a[j-1], p[i] + mid)\n            else:\n                return False\n    return last[-1] <= mid\n\nn = int(input().strip())\ns = input().strip()\na = [i for i in range(n) if s[i] == '*']\np = [i for i in range(n) if s[i] == 'P']\nl = 0\nr = 2*n\nwhile r - l > 1:\n    mid = (l + r) // 2\n    if check(mid):\n        r = mid\n    else:\n        l = mid\nprint(r)\n"
    },
    "3759": {
        "negative_solution": "import math\nn = int(input().strip())\nif n == 0:\n    print(1)\nelse:\n    print(4 * int(n * math.sqrt(2)))"
    },
    "3760": {
        "negative_solution": "import math\nn, m, x, y, a, b = map(int, input().split())\ng = math.gcd(a, b)\na //= g\nb //= g\nl = min(n // a, m // b)\na *= l\nb *= l\nx1 = max(0, x - (a + 1) // 2)\ny1 = max(0, y - (b + 1) // 2)\nx2 = x1 + a\ny2 = y1 + b\nif x2 > n:\n    x1 -= x2 - n\n    x2 = n\nif y2 > m:\n    y1 -= y2 - m\n    y2 = m\nprint(x1, y1, x2, y2)\n"
    },
    "3761": {
        "negative_solution": "import sys\nfrom collections import deque\n\ns = input().strip()\nx, y = map(int, input().split())\n\ns = s.split('T')\nx_list = [len(s[i]) for i in range(0, len(s), 2)]\ny_list = [len(s[i]) for i in range(1, len(s), 2)]\n\nx -= x_list[0]\nx_list = x_list[1:]\n\nx_dp = [0]*(8005)\ny_dp = [0]*(8005)\nx_dp[4002] = 1\ny_dp[4002] = 1\n\nfor i in x_list:\n    nx_dp = [0]*(8005)\n    for j in range(8005):\n        if x_dp[j]:\n            if j+i < 8005:\n                nx_dp[j+i] = 1\n            if j-i >= 0:\n                nx_dp[j-i] = 1\n    x_dp = nx_dp\n\nfor i in y_list:\n    ny_dp = [0]*(8005)\n    for j in range(8005):\n        if y_dp[j]:\n            if j+i < 8005:\n                ny_dp[j+i] = 1\n            if j-i >= 0:\n                ny_dp[j-i] = 1\n    y_dp = ny_dp\n\nif x_dp[x+4002] and y_dp[y+4002]:\n    print('Yes')\nelse:\n    print('No')\n"
    },
    "3762": {
        "negative_solution": "MOD = 10**9 + 7\ndp = [[0]*31 for _ in range(31)]\ndp[0][0] = 1\n\nfor i in range(30):\n    for j in range(i+1):\n        dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD\n        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]*2**j) % MOD\n\nk = int(input())\nk = bin(k)[2:][::-1]\nn = len(k)\n\ndp2 = [[0]*31 for _ in range(31)]\ndp2[0][0] = 1\n\nfor i in range(n):\n    for j in range(i+1):\n        if k[i] == '1':\n            for l in range(j+1):\n                dp2[i+1][max(j, l+1)] = (dp2[i+1][max(j, l+1)] + dp2[i][j]*dp[i][l]) % MOD\n            for l in range(j):\n                dp2[i+1][j] = (dp2[i+1][j] + dp2[i][j]*dp[i][l]) % MOD\n        else:\n            for l in range(j+1):\n                dp2[i+1][j] = (dp2[i+1][j] + dp2[i][j]*dp[i][l]) % MOD\n\nprint(sum(dp2[n][j] for j in range(n+1)) % MOD)\n"
    },
    "3763": {
        "negative_solution": "from math import factorial as f\nfrom itertools import permutations as p\n\ndef solve(n, a, p):\n    a.sort()\n    dp = [[0 for _ in range(p+1)] for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(i+1):\n            for k in range(p+1):\n                dp[j+1][min(p, k+a[i])] += dp[j][k]\n                dp[j][k] *= 2\n    ans = 0\n    for i in range(n+1):\n        for j in range(p+1):\n            ans += dp[i][j] * i\n    return ans / (2**n)\n\nn = int(input())\na = list(map(int, input().split()))\np = int(input())\nprint(solve(n, a, p))\n"
    },
    "3764": {
        "negative_solution": "import heapq\n\nn, k, x = map(int, input().split())\nstrengths = list(map(int, input().split()))\nstrengths = [-1 * i for i in strengths]\nheapq.heapify(strengths)\n\nfor _ in range(k):\n    for i in range(n):\n        if i % 2 == 0:\n            temp = -1 * heapq.heappop(strengths)\n            temp ^= x\n            heapq.heappush(strengths, -1 * temp)\n        else:\n            break\n\nprint(-1 * min(strengths), -1 * max(strengths))\n"
    },
    "3765": {
        "negative_solution": "import sys\nfrom heapq import *\n\na, b, h, w, n = map(int, sys.stdin.readline().split())\np = list(map(int, sys.stdin.readline().split()))\np.sort(reverse=True)\np += [1] * (n + 2)\n\ndef solve(a, b, h, w):\n    if a <= h and b <= w:\n        return 0\n    if a > h:\n        a, h = h, a\n    if b > w:\n        b, w = w, b\n    if a > h:\n        a, h = h, a\n    if a <= h and b <= w:\n        return 0\n    if a * b > h * w * p[0] * p[1]:\n        return -1\n    if a <= h and b * p[0] <= w:\n        return 1\n    if b <= w and a * p[0] <= h:\n        return 1\n    if a * p[0] <= h and b * p[1] <= w:\n        return 2\n    if b * p[0] <= w and a * p[1] <= h:\n        return 2\n    return 3\n\nprint(min(solve(a, b, h, w), solve(a, b, w, h)))\n"
    },
    "3766": {
        "negative_solution": "import sys\nfrom itertools import combinations\n\ndef solve():\n    n = int(input())\n    cards = set(input().split())\n    colors = {'R', 'G', 'B', 'Y', 'W'}\n    numbers = {'1', '2', '3', '4', '5'}\n    color_hints = [set() for _ in range(5)]\n    number_hints = [set() for _ in range(5)]\n    for card in cards:\n        color, number = card\n        color_hints[ord(color) - ord('A')].add(card)\n        number_hints[int(number) - 1].add(card)\n    for i in range(10):\n        for hints in combinations(range(10), i):\n            color_hints_to_give = [color_hints[hint] for hint in hints if hint < 5]\n            number_hints_to_give = [number_hints[hint - 5] for hint in hints if hint >= 5]\n            if len(set.union(*color_hints_to_give, *number_hints_to_give)) == len(cards):\n                return i\n    return 10\n\nprint(solve())\n"
    },
    "3767": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nb.sort()\ns = sum(a)\nt = 0\nk = 0\nwhile s > 0:\n    s -= b.pop()\n    t += min(s, b[-1])\n    k += 1\nprint(k, t)\n"
    },
    "3768": {
        "negative_solution": "x, y = map(int, input().split())\nif x < y:\n    x, y = y, x\n    c = 'B'\nelse:\n    c = 'A'\nans = []\nwhile y:\n    q, r = divmod(x, y)\n    ans.append((q, c))\n    x, y = y, r\n    c = 'A' if c == 'B' else 'B'\nif x != 1:\n    print('Impossible')\nelse:\n    ans[-1] = (ans[-1][0] - 1, ans[-1][1])\n    ans.append((1, 'A' if ans[-1][1] == 'B' else 'B'))\n    for a, b in ans:\n        print(a, b, sep='', end='')\n"
    },
    "3769": {
        "negative_solution": "MOD = 10**9 + 7\n\ndef power(x, y):\n    if y == 0:\n        return 1\n    elif y % 2 == 0:\n        return power((x * x) % MOD, y // 2)\n    else:\n        return (x * power((x * x) % MOD, y // 2)) % MOD\n\ndef solve(p, k):\n    if k == 0:\n        return power(p, p - 1)\n    elif k == 1:\n        return power(p, p)\n    else:\n        a = [1]\n        x = k\n        while x != 1:\n            a.append(x)\n            x = (x * k) % p\n        return power(p, len(a))\n\np, k = map(int, input().split())\nprint(solve(p, k))\n"
    },
    "3770": {
        "negative_solution": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(M)]\nedges = [[u-1, v-1] for u, v in edges]\n\nG = [[] for _ in range(N)]\nfor u, v in edges:\n    G[u].append(v)\n    G[v].append(u)\n\nvisited = [False]*N\ncomponents = []\nfor i in range(N):\n    if not visited[i]:\n        stack = deque([i])\n        visited[i] = True\n        component = [i]\n        while stack:\n            v = stack.pop()\n            for u in G[v]:\n                if not visited[u]:\n                    stack.append(u)\n                    visited[u] = True\n                    component.append(u)\n        components.append(component)\n\ndp = [[-float('inf')]*(N+1) for _ in range(len(components)+1)]\ndp[0][0] = 0\nfor i, component in enumerate(components, start=1):\n    total_B = sum(B[v] for v in component)\n    total_A = sum(A[v] for v in component)\n    for j in range(N+1):\n        if j >= total_A:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-total_A] + total_B)\n        dp[i][j] = max(dp[i][j], dp[i-1][j])\n\nprint(max(dp[-1]))\n"
    },
    "3771": {
        "negative_solution": "from collections import deque\nH, W = map(int, input().split())\nG = [list(input()) for _ in range(H)]\nINF = 10**9\nN = 2*H + 2*W + 2\ncap = [[0]*N for _ in range(N)]\ncost = [[0]*N for _ in range(N)]\nto = [[] for _ in range(N)]\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\nS = 2*H + 2*W\nT = S + 1\ndef add_edge(u, v, c, d):\n    cap[u][v] = c\n    cap[v][u] = 0\n    cost[u][v] = d\n    cost[v][u] = -d\n    to[u].append(v)\n    to[v].append(u)\nfor i in range(H):\n    for j in range(W):\n        if G[i][j] == 'o':\n            add_edge(2*i, 2*H + 2*j, 1, 1)\n            add_edge(2*H + 2*j, 2*i + 1, 1, 0)\n            add_edge(2*j, 2*H + 2*i + 1, 1, 1)\n            add_edge(2*H + 2*i + 1, 2*j + 1, 1, 0)\n        elif G[i][j] == 'S':\n            add_edge(S, 2*i, INF, 0)\n            add_edge(S, 2*j, INF, 0)\n            add_edge(2*i + 1, T, INF, 0)\n            add_edge(2*j + 1, T, INF, 0)\n        elif G[i][j] == 'T':\n            add_edge(2*i, T, INF, 0)\n            add_edge(2*j, T, INF, 0)\n            add_edge(S, 2*i + 1, INF, 0)\n            add_edge(S, 2*j + 1, INF, 0)\nres = 0\nwhile True:\n    dist = [INF]*N\n    dist[S] = 0\n    prevv = [0]*N\n    preve = [0]*N\n    que = deque([(0, S)])\n    while que:\n        d, v = que.popleft()\n        if dist[v] < d:\n            continue\n        for i, u in enumerate(to[v]):\n            if cap[v][u] > 0 and dist[u] > dist[v] + cost[v][u]:\n                dist[u] = dist[v] + cost[v][u]\n                prevv[u] = v\n                preve[u] = i\n                que.append((dist[u], u))\n    if dist[T] == INF:\n        break\n    v = T\n    while v != S:\n        u = prevv[v]\n        cap[u][v] -= 1\n        cap[v][u] += 1\n        v = u\n    res += dist[T]\nprint(res if res < INF else -1)\n"
    },
    "3772": {
        "negative_solution": "def solve(a, b):\n    if a % b == 0:\n        return a // b\n    else:\n        return a // b + solve(b, a % b)\n\na, b = map(int, input().split())\nprint(solve(a, b))\n"
    },
    "3773": {
        "negative_solution": "def mex(s):\n    i = 0\n    while i in s:\n        i += 1\n    return i\n\ndef grundy(a, k):\n    if a % k == 0:\n        return a // k\n    b = a // k * k\n    if a - b >= b // k + 1:\n        return grundy(a - b // k - 1, k)\n    return grundy(b, k)\n\nN = int(input())\nG = 0\nfor _ in range(N):\n    a, k = map(int, input().split())\n    G ^= grundy(a, k)\nif G == 0:\n    print(\"Aoki\")\nelse:\n    print(\"Takahashi\")\n"
    },
    "3774": {
        "negative_solution": "def solve(n, m):\n    if n > m:\n        n, m = m, n\n    if n == 1:\n        if m % 6 <= 3:\n            return m // 6 * 6\n        else:\n            return m // 6 * 6 + 2 * (m % 6 - 3)\n    elif n == 2:\n        if m in [2, 3, 7]:\n            return m\n        else:\n            return n * m // 2 * 2\n    else:\n        return n * m // 2 * 2\n\nn, m = map(int, input().split())\nprint(solve(n, m))\n"
    },
    "3775": {
        "negative_solution": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(m)]\nc = [0]*10\nd = [0]*10\ne = [0]*10\nf = [0]*10\nfor i in range(n):\n    c[a[i][0]] += 1\n    c[a[i][1]] += 1\n    e[a[i][0]] += 1\n    e[a[i][1]] += 1\nfor i in range(m):\n    d[b[i][0]] += 1\n    d[b[i][1]] += 1\n    f[b[i][0]] += 1\n    f[b[i][1]] += 1\nfor i in range(10):\n    if c[i] > 0 and d[i] > 0:\n        if c[i] > 1:\n            for j in range(n):\n                if a[j][0] == i or a[j][1] == i:\n                    e[a[j][0]] -= 1\n                    e[a[j][1]] -= 1\n        if d[i] > 1:\n            for j in range(m):\n                if b[j][0] == i or b[j][1] == i:\n                    f[b[j][0]] -= 1\n                    f[b[j][1]] -= 1\nif max(e) > 1 or max(f) > 1:\n    print(-1)\nelif sum([1 for i in range(10) if c[i] > 0 and d[i] > 0]) > 1:\n    print(0)\nelse:\n    for i in range(10):\n        if c[i] > 0 and d[i] > 0:\n            print(i)\n            break\n"
    },
    "3776": {
        "negative_solution": "format = int(input())\ntime = input()\n\nhours, minutes = map(int, time.split(':'))\n\nif format == 24:\n    if hours > 23:\n        hours = 10\n    if minutes > 59:\n        minutes = 10\nelse:\n    if hours > 12 or hours == 0:\n        hours = 10\n    if minutes > 59:\n        minutes = 10\n\nprint(\"{:02}:{:02}\".format(hours, minutes))\n"
    },
    "3777": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nmod = 10**9+7\nn,m = map(int,input().split())\nx = int(input())\nedge = sorted([list(map(int,input().split())) for _ in range(m)],key=lambda x:x[2])\npar = list(range(n+1))\nrank = [0]*(n+1)\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\ndef same(x,y):\n    return find(x) == find(y)\ncnt = [0]*(m+1)\nfor i in range(m):\n    if not same(edge[i][0],edge[i][1]):\n        cnt[i+1] = cnt[i]+1\n        unite(edge[i][0],edge[i][1])\n    else:\n        cnt[i+1] = cnt[i]\ndp = [[0]*(n+1) for _ in range(m+1)]\ndp[0][0] = 1\nfor i in range(m):\n    for j in range(cnt[i]+1):\n        if dp[i][j] == 0:\n            continue\n        if j < cnt[i+1]:\n            dp[i+1][j+1] += dp[i][j]\n            dp[i+1][j+1] %= mod\n        dp[i+1][j] += dp[i][j]*2\n        dp[i+1][j] %= mod\nans = 0\nfor i in range(m):\n    if edge[i][2]*cnt[i+1] > x:\n        break\n    for j in range(cnt[i+1]):\n        if edge[i][2]*j+(n-1-j)*edge[i+1][2] <= x:\n            ans += dp[i+1][j]\n            ans %= mod\nprint(ans)\n"
    },
    "3778": {
        "negative_solution": "import heapq\n\nn = int(input())\na = list(map(int, input().split()))\n\npq = []\nfor i in range(n):\n    if a[i] > 0:\n        heapq.heappush(pq, (-a[i], i+1))\n\ntargets = []\nprev = 0\nwhile pq:\n    hits, col = heapq.heappop(pq)\n    hits = -hits\n    if hits > prev + 1:\n        print(-1)\n        exit(0)\n    elif hits == prev + 1:\n        targets.append((len(targets)+1, col))\n    else:\n        targets.insert(len(targets)-prev-1, (len(targets)+1, col))\n    prev = hits\n\nprint(len(targets))\nfor r, c in targets:\n    print(r, c)\n"
    },
    "3779": {
        "negative_solution": "import math\nfrom functools import reduce\nfrom operator import mul\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    g = reduce(gcd, a)\n    if g > 1:\n        a = [i // g for i in a]\n    g = reduce(gcd, a)\n    if g > 1:\n        print(1)\n        print(0)\n    else:\n        print(k)\n        print(' '.join(map(str, range(k))))\n\nsolve()\n"
    },
    "3780": {
        "negative_solution": "import math\ndef solve():\n    x1, y1, x2, y2 = map(int, input().split())\n    v, t = map(int, input().split())\n    vx, vy = map(int, input().split())\n    wx, wy = map(int, input().split())\n    x2 -= x1 + vx * t\n    y2 -= y1 + vy * t\n    l = 0\n    r = 1e18\n    for _ in range(200):\n        m = (l + r) / 2\n        if m < t:\n            if (x2 - vx * m) ** 2 + (y2 - vy * m) ** 2 <= (v * m) ** 2:\n                r = m\n            else:\n                l = m\n        else:\n            if (x2 - wx * (m - t)) ** 2 + (y2 - wy * (m - t)) ** 2 <= (v * m) ** 2:\n                r = m\n            else:\n                l = m\n    print('%.15f' % r)\n\nsolve()\n"
    },
    "3781": {
        "negative_solution": "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    sum_a = sum(a)\n    if sum_a % 2 == 1 or a[-1] > sum_a - a[-1]:\n        print('First')\n    else:\n        print('Second')\n"
    },
    "3782": {
        "negative_solution": "from heapq import *\nfrom collections import deque\nN, K, Q = map(int, input().split())\nA = list(map(int, input().split()))\nA.append(10**10)\nB = sorted(A)\nans = 10**10\nfor b in B:\n    C = []\n    D = deque()\n    for a in A:\n        if a >= b:\n            D.append(a)\n        else:\n            if len(D) >= K:\n                E = list(D)\n                E.sort()\n                for _ in range(len(E)-K+1):\n                    C.append(E.pop(0))\n            D = deque()\n    if len(D) >= K:\n        E = list(D)\n        E.sort()\n        for _ in range(len(E)-K+1):\n            C.append(E.pop(0))\n    if len(C) >= Q:\n        C.sort()\n        ans = min(ans, C[Q-1]-b)\nprint(ans)\n"
    },
    "3783": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nmod = 10**9+7\nN, K = map(int,input().split())\nfact = [1]*(K+1)\ninv = [1]*(K+1)\nfor i in range(1,K+1):\n    fact[i] = (fact[i-1]*i)%mod\n    inv[i] = pow(fact[i],mod-2,mod)\ndp = [0]*(K+1)\ndp[0] = pow(2,N,mod)\nfor i in range(1,K+1):\n    dp[i] = (dp[i-1]*2*N)%mod\n    for j in range(i):\n        dp[i] = (dp[i]-dp[j]*fact[i]*inv[i-j]%mod*inv[j]%mod)%mod\nprint(dp[K])\n"
    },
    "3784": {
        "negative_solution": "MOD = 10**9 + 7\nN = 55\ncomb = [[0]*N for _ in range(N)]\ndp = [[[0]*N for _ in range(N)] for _ in range(N)]\nways = [[0]*N for _ in range(N)]\ndp[2][1][1] = comb[2][2] = ways[2][1] = 1\n\nfor i in range(3, N):\n    comb[i][0] = comb[i][i] = 1\n    for j in range(1, i):\n        comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD\n    for j in range(1, i):\n        ways[i][j] = pow(2, i*(i-1)//2 - j, MOD)\n        for k in range(1, j+1):\n            dp[i][j][k] = ways[i][j]\n            for l in range(2, i):\n                for x in range(max(1, j-(i-l)*(i-l-1)//2), min(j, l*(l-1)//2)+1):\n                    for y in range(1, min(x, k)+1):\n                        dp[i][j][k] = (dp[i][j][k] - comb[i-2][l-2]*comb[i][l]%MOD*dp[l][x][y]%MOD*ways[i-l][j-x]%MOD) % MOD\n\nn, m = map(int, input().split())\nprint(dp[n+2][n+1][m])\n"
    },
    "3785": {
        "negative_solution": "from collections import deque\nn, m, k = map(int, input().split())\nmaze = [list(input()) for _ in range(n)]\ndx = [0, 0, -1, 1]\ndy = [-1, 1, 0, 0]\nvisited = [[False]*m for _ in range(n)]\nqueue = deque()\nfor i in range(n):\n    for j in range(m):\n        if maze[i][j] == '.':\n            queue.append((i, j))\n            visited[i][j] = True\n            break\n    else:\n        continue\n    break\nwhile queue:\n    x, y = queue.popleft()\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == '.':\n            queue.append((nx, ny))\n            visited[nx][ny] = True\nwhile k:\n    x, y = queue.pop()\n    maze[x][y] = 'X'\n    k -= 1\nfor row in maze:\n    print(''.join(row))\n"
    },
    "3786": {
        "negative_solution": "from collections import defaultdict\nn = int(input())\np = list(map(int, input().split()))\np = [0] + p\ndist = [0]*n\nfor i in range(2, n+1):\n    dist[i-1] = dist[p[i-1]-1] + 1\ndist.sort()\ncnt = defaultdict(int)\nfor i in dist:\n    cnt[i] += 1\nans = 0\nfor i in cnt.values():\n    ans += i % 2\nprint(ans)\n"
    },
    "3787": {
        "negative_solution": "N, A, B = map(int, input().split())\nif A + B - 1 > N or A * B < N:\n    print(-1)\nelse:\n    ans = []\n    x = N\n    for i in range(A):\n        y = max(B - 1, N - x + 1)\n        ans += list(range(x - y + 1, x + 1))[::-1]\n        x -= y\n    print(*ans)\n"
    },
    "3788": {
        "negative_solution": "import sys\nfrom collections import defaultdict\nfrom math import gcd\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    dp = [[0]*n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for l in range(2, n+1):\n        for i in range(n-l+1):\n            j = i+l-1\n            for k in range(i, j):\n                if gcd(a[k], a[j]) > 1:\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])\n                if gcd(a[i], a[k+1]) > 1:\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])\n    print(\"Yes\" if dp[0][n-1] == n else \"No\")\n\nsolve()\n"
    },
    "3789": {
        "negative_solution": "import heapq\n\nN = int(input())\nA = list(map(int, input().split()))\nA.sort()\nA = [-a for a in A]\nheapq.heapify(A)\nans = 0\nwhile A:\n    a = -heapq.heappop(A)\n    ans += a\n    while A and -A[0] < a:\n        heapq.heappop(A)\nprint(ans)\n"
    },
    "3790": {
        "negative_solution": "n, T = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nb = [0]*301\nc = [0]*301\nfor i in range(n):\n    b[a[i]] += 1\nm = max(a)\nfor i in range(1, m+1):\n    c[i] = c[i-1] + b[i]\nans = b[m]*min(T, 300)\nT -= min(T, 300)\nif T > 0:\n    ans += (c[m] - c[m-1] + c[m])*T\nprint(ans)\n"
    },
    "3791": {
        "negative_solution": "import sys\nfrom collections import defaultdict\n\nn = int(sys.stdin.readline())\np = list(map(int, sys.stdin.readline().split()))\nd = defaultdict(int)\ns = [0] * (n + 1)\na = b = 0\nfor i in range(n):\n    p[i] -= 1\n    a += abs(p[i] - i)\n    if p[i] > i:\n        d[p[i] - i] += 1\n        s[0] += 1\n        s[p[i] - i + 1] -= 1\n    else:\n        d[0] += 1\n        d[n - i + p[i]] -= 1\n        s[n - i + p[i]] += 1\nfor i in range(1, n + 1):\n    s[i] += s[i - 1]\nm = a\nk = 0\nfor i in range(1, n):\n    a += s[i - 1] - d[i] + n - 1\n    if a < m:\n        m = a\n        k = i\nprint(m, k)\n"
    },
    "3792": {
        "negative_solution": "n, k = map(int, input().split())\ns = input()\nt = input()\ns = list(s)\nt = list(t)\ns.append('a')\nt.append('b')\nf = [0]*(n+2)\ng = [0]*(n+2)\nf[n+1] = 1\ng[n+1] = 1\nfor i in range(n, -1, -1):\n    f[i] = min(f[i+1]*2+(s[i] == 'b'), k)\n    g[i] = min(g[i+1]*2+(t[i] == 'b'), k)\nres = 1\nfor i in range(1, n+1):\n    if s[i] == t[i]:\n        if s[i] == 'b':\n            res += 1\n    else:\n        res += min(f[i], g[i])\n        break\nprint(res)\n"
    },
    "3793": {
        "negative_solution": "from itertools import permutations\n\ndef dist(p1, p2):\n    return sum((a-b)**2 for a, b in zip(p1, p2))\n\ndef solve():\n    points = [list(map(int, input().split())) for _ in range(8)]\n    for perm in permutations(points):\n        d = [dist(perm[0], perm[i]) for i in range(1, 8)]\n        d.sort()\n        if d[0] == d[1] == d[2] == d[3] == d[4] != d[5] == d[6] == d[7]:\n            print(\"YES\")\n            for p in perm:\n                print(*p)\n            return\n    print(\"NO\")\n\nsolve()\n"
    },
    "3794": {
        "negative_solution": "from math import gcd\nfrom sys import stdin, stdout\nfrom collections import deque\n\ndef solve():\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    a.sort()\n    g = [0]*(n+1)\n    g[n] = a[n-1]\n    for i in range(n-2, -1, -1):\n        g[i] = gcd(g[i+1], a[i])\n    f = a[0]\n    for i in range(1, n):\n        f = gcd(f, a[i])\n        if gcd(f, g[i+1]) == 1:\n            break\n    else:\n        stdout.write('NO\\n')\n        return\n    stdout.write('YES\\n')\n    b = [1]*n\n    b[i] = 2\n    f = a[i]\n    q = deque([(i, f, g[i+1])])\n    while q:\n        i, f, g = q.popleft()\n        for j in range(i-1, -1, -1):\n            if b[j] == 1 and gcd(f, a[j]) > 1:\n                b[j] = 2\n                f = gcd(f, a[j])\n                q.append((j, f, g))\n            elif b[j] == 2 and gcd(g, a[j]) > 1:\n                b[j] = 1\n                g = gcd(g, a[j])\n                q.append((j, f, g))\n    stdout.write(' '.join(map(str, b)) + '\\n')\n\nsolve()\n"
    },
    "3795": {
        "negative_solution": "n = int(input())\nd = int(input())\ne = int(input())\ne *= 5\nans = n\nfor i in range(n // d + 1):\n    ans = min(ans, (n - d * i) % e)\nprint(ans)\n"
    },
    "3796": {
        "negative_solution": "from collections import Counter\nfrom heapq import *\nn = int(input())\na = list(map(int,input().split()))\nc = Counter(a)\nh = []\nfor i in c:\n    heappush(h, -c[i])\nmaxi = 0\nl = 0\nr = 0\nfor i in range(1, n+1):\n    while h and -h[0] < i:\n        heappop(h)\n    if len(h) >= i:\n        if i * min(-h[0], i) > maxi:\n            maxi = i * min(-h[0], i)\n            l = i\n            r = min(-h[0], i)\nprint(maxi)\nprint(l, r)\nc = Counter(a)\nh = []\nfor i in c:\n    heappush(h, (-c[i], i))\nmat = [[0]*r for _ in range(l)]\nfor i in range(r):\n    for j in range(l):\n        if h[0][0] == -1:\n            heappop(h)\n        mat[(i+j)%l][i] = h[0][1]\n        h[0] = (h[0][0]+1, h[0][1])\nfor row in mat:\n    print(*row)\n"
    },
    "3797": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nmod = 10**9+7\nN, M = map(int,input().split())\ndp = [[[0]*305 for _ in range(305)] for _ in range(305)]\ndp[0][0][0] = 1\ncond = [[] for _ in range(305)]\nfor _ in range(M):\n    l, r, x = map(int,input().split())\n    cond[r-1].append((l-1, x))\nfor i in range(N):\n    for j in range(i+1):\n        for k in range(j+1):\n            if dp[i][j][k] == 0:\n                continue\n            dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]) % mod\n            dp[i+1][k][i] = (dp[i+1][k][i] + dp[i][j][k]) % mod\n            dp[i+1][j][i] = (dp[i+1][j][i] + dp[i][j][k]) % mod\n    for l, x in cond[i]:\n        for j in range(i+1):\n            for k in range(j+1):\n                if min(l, j, k) >= l and [j, k, i].count(l) == x:\n                    continue\n                dp[i][j][k] = 0\nprint(sum(sum(dp[N-1][j][k] for j in range(N)) for k in range(N)) % mod)\n"
    },
    "3798": {
        "negative_solution": "import math\n\ndef f(b, n):\n    if n < b:\n        return n\n    else:\n        return f(b, n // b) + n % b\n\nn = int(input().strip())\ns = int(input().strip())\n\nif n == s:\n    print(n + 1)\nelif n < s:\n    print(-1)\nelse:\n    for b in range(2, int(math.sqrt(n)) + 1):\n        if f(b, n) == s:\n            print(b)\n            break\n    else:\n        for p in range(int(math.sqrt(n)), 0, -1):\n            b = (n - s) // p + 1\n            if b >= 2 and f(b, n) == s:\n                print(b)\n                break\n        else:\n            print(-1)\n"
    },
    "3799": {
        "negative_solution": "s = input().strip()\nn = len(s)\nif s[0] == s[-1]:\n    if n % 2 == 0:\n        print(\"First\")\n    else:\n        print(\"Second\")\nelse:\n    if n % 2 == 0:\n        print(\"Second\")\n    else:\n        print(\"First\")\n"
    },
    "3800": {
        "negative_solution": "a = int(input().strip())\ns = list(map(int, list(input().strip())))\nn = len(s)\nprefix = [0]*(n+1)\nfor i in range(n):\n    prefix[i+1] = prefix[i] + s[i]\ncount = [0]*(n*n+1)\nfor i in range(n):\n    for j in range(i+1, n+1):\n        count[prefix[j] - prefix[i]] += 1\nanswer = 0\nif a == 0:\n    for i in range(1, n*n+1):\n        answer += count[i] * count[0]\n    answer += count[0] * (count[0] - 1) // 2\nelse:\n    for i in range(1, (n*n+1)//2+1):\n        if a % i == 0 and a // i <= n*n:\n            answer += count[i] * count[a // i]\nprint(answer)\n"
    },
    "3801": {
        "negative_solution": "MOD = 998244353\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nw = list(map(int, input().split()))\ns1 = sum(w[i] for i in range(n) if a[i])\ns2 = sum(w[i] for i in range(n) if not a[i])\ndp = [[[0]*(m+1) for _ in range(m+1)] for _ in range(m+1)]\ndp[0][0][0] = 1\nfor i in range(m):\n    for j in range(i+1):\n        for k in range(i-j+1):\n            if s1+j > 0:\n                dp[i+1][j+1][k] = (dp[i+1][j+1][k] + dp[i][j][k]*((s1+j)*pow(s1+s2-j+k, MOD-2, MOD))%MOD)%MOD\n            if s2+k > 0:\n                dp[i+1][j][k+1] = (dp[i+1][j][k+1] + dp[i][j][k]*((s2+k)*pow(s1+s2-j+k, MOD-2, MOD))%MOD)%MOD\n            dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]*((s1+s2-j+k)*pow(s1+s2-j+k, MOD-2, MOD))%MOD)%MOD\nfor i in range(n):\n    ans = 0\n    for j in range(m+1):\n        for k in range(m-j+1):\n            if a[i]:\n                ans = (ans + dp[m][j][k]*(w[i]+j))%MOD\n            else:\n                ans = (ans + dp[m][j][k]*max(0, w[i]-k))%MOD\n    print(ans)\n"
    },
    "3802": {
        "negative_solution": "def longest_common_subsequence(s1, s2, virus):\n    n, m, v = len(s1), len(s2), len(virus)\n    dp = [[[\"\", 0] for _ in range(m+1)] for _ in range(n+1)]\n    fail = [0]*v\n    for i in range(1, v):\n        j = fail[i-1]\n        while j and virus[i] != virus[j]:\n            j = fail[j-1]\n        fail[i] = j + (virus[i] == virus[j])\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if s1[i-1] == s2[j-1]:\n                k = dp[i-1][j-1][1]\n                while k and (k == v or virus[k] != s1[i-1]):\n                    k = fail[k-1]\n                dp[i][j] = max([dp[i][j], [dp[i-1][j-1][0] + s1[i-1], k + 1]], key=lambda x: (len(x[0]), -x[1]))\n            else:\n                dp[i][j] = max([dp[i][j], dp[i-1][j], dp[i][j-1]], key=lambda x: (len(x[0]), -x[1]))\n    return dp[n][m][0] if dp[n][m][0] and dp[n][m][1] != v else \"0\"\n\nprint(longest_common_subsequence(\"AJKEQSLOBSROFGZ\", \"OVGURWZLWVLUXTH\", \"OZ\"))  # Output: \"ORZ\"\nprint(longest_common_subsequence(\"AA\", \"A\", \"A\"))  # Output: \"0\"\n"
    },
    "3803": {
        "negative_solution": "def min_bitcoins():\n    HP_Y, ATK_Y, DEF_Y = map(int, input().split())\n    HP_M, ATK_M, DEF_M = map(int, input().split())\n    h, a, d = map(int, input().split())\n    min_bitcoins = float('inf')\n    for ATK_Y in range(ATK_Y, 101):\n        for DEF_Y in range(DEF_Y, 101):\n            HP_Y_needed = max(0, ((HP_M + max(0, ATK_Y - DEF_M) - 1) // max(0, ATK_Y - DEF_M)) * max(0, ATK_M - DEF_Y) + 1)\n            cost = max(0, HP_Y_needed - HP_Y) * h + (ATK_Y - ATK_Y) * a + (DEF_Y - DEF_Y) * d\n            min_bitcoins = min(min_bitcoins, cost)\n    return min_bitcoins\n\nprint(min_bitcoins())\n"
    },
    "3804": {
        "negative_solution": "def solve(n, t):\n    if t == 1:\n        return n\n    t -= 1\n    n -= 1\n    ans = 0\n    for i in range(60):\n        if (t >> i) & 1:\n            if i > n:\n                break\n            ans += C[n][i]\n    return ans\n\nC = [[0 for _ in range(61)] for _ in range(61)]\nC[0][0] = 1\nfor i in range(1, 61):\n    C[i][0] = 1\n    for j in range(1, i + 1):\n        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]\n\nn, t = map(int, input().split())\nprint(solve(n, t))\n"
    },
    "3805": {
        "negative_solution": "def can_be_untangled(s):\n    stack = []\n    for c in s:\n        if stack and stack[-1] == c:\n            stack.pop()\n        else:\n            stack.append(c)\n    return \"Yes\" if not stack else \"No\"\n\ns = input().strip()\nprint(can_be_untangled(s))\n"
    },
    "3806": {
        "negative_solution": "import math\nfrom sys import stdin\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef dot(x1, y1, x2, y2):\n    return x1 * x2 + y1 * y2\n\ndef cross(x1, y1, x2, y2):\n    return x1 * y2 - x2 * y1\n\ndef lineDist(x1, y1, x2, y2, x3, y3):\n    return abs(cross(x2 - x1, y2 - y1, x1 - x3, y1 - y3)) / dist(x1, y1, x2, y2)\n\nn, px, py = map(int, stdin.readline().split())\nx = [0] * n\ny = [0] * n\nfor i in range(n):\n    x[i], y[i] = map(int, stdin.readline().split())\n    x[i] -= px\n    y[i] -= py\nx.append(x[0])\ny.append(y[0])\nminR = 1e100\nmaxR = max(dist(x[i], y[i], 0, 0) for i in range(n))\nfor i in range(n):\n    if dot(x[i], y[i], x[i + 1], y[i + 1]) > 0 and dot(x[i + 1], y[i + 1], x[i], y[i]) > 0:\n        minR = min(minR, lineDist(x[i], y[i], x[i + 1], y[i + 1], 0, 0))\n    else:\n        minR = min(minR, dist(x[i], y[i], 0, 0), dist(x[i + 1], y[i + 1], 0, 0))\nprint(\"%.15f\" % (math.pi * (maxR ** 2 - minR ** 2)))\n"
    },
    "3807": {
        "negative_solution": "def solve(m):\n    if m < 8:\n        return m, m\n    q, r = divmod(m, 8)\n    if r == 0:\n        return 3*q, m\n    if r == 7:\n        return 3*q+3, m\n    if r == 1:\n        return 3*q+1, m\n    return max((3*q+1, m-1), solve(8*q+r-1))\n\nm = int(input().strip())\nprint(*solve(m))\n"
    },
    "3808": {
        "negative_solution": "n = int(input())\ns = input()\nif n % 2 != 0 or s.count('(') != s.count(')'):\n    print('No')\nelse:\n    cnt = 0\n    for i in s:\n        if i == '(':\n            cnt += 1\n        else:\n            cnt -= 1\n        if cnt < -1:\n            print('No')\n            break\n    else:\n        print('Yes')\n"
    },
    "3809": {
        "negative_solution": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na = [x//50 for x in a]\nk //= 50\ndp = [[[[0]*101 for _ in range(51)] for _ in range(51)] for _ in range(2)]\ndp[0][n][a.count(2)][a.count(1)] = 1\nans = [float('inf'), 0]\nfor t in range(2*n):\n    i = t%2\n    for x in range(n+1):\n        for y in range(min(x, k)+1):\n            for z in range(min(n-x, k-y*2)+1):\n                if dp[i][x][y][z] == 0: continue\n                if x == 0: ans = [t, dp[i][x][y][z]]\n                j = 1-i\n                dp[j][x][y][z] = 0\n                for p in range(y+1):\n                    for q in range(min(z, k-p*2)+1):\n                        if p*2+q > k: break\n                        dp[j][x-p-q][y-p][z-q] += dp[i][x][y][z]\n                        dp[j][x-p-q][y-p][z-q] %= MOD\nif ans[0] == float('inf'): print(-1, 0)\nelse: print(ans[0], ans[1])\n"
    },
    "3810": {
        "negative_solution": "from collections import defaultdict\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\nfrom math import gcd\n\nMOD = 10 ** 9 + 7\nMAX = 61\nnCr = [[0] * MAX for _ in range(MAX)]\nfor i in range(MAX):\n    nCr[i][0] = nCr[i][i] = 1\n    for j in range(1, i):\n        nCr[i][j] = (nCr[i - 1][j - 1] + nCr[i - 1][j]) % MOD\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ng = [0] * MAX\nfor x in a:\n    g[x] = reduce(gcd, (g[y] for y in range(1, x + 1) if x % y == 0))\ncnt = defaultdict(int)\nfor x in a:\n    cnt[g[x]] += 1\ndp = [1] + [0] * n\nfor x in sorted(cnt.keys(), reverse=True):\n    ndp = dp[:]\n    for i in range(cnt[x]):\n        for j in range(n, i, -1):\n            ndp[j] = (ndp[j] + dp[j - i - 1] * nCr[cnt[x]][i + 1]) % MOD\n    dp = ndp\nprint(dp[cnt[1]])\n"
    },
    "3811": {
        "negative_solution": "import math\nn = int(input())\npairs = [list(map(int, input().split())) for _ in range(n)]\nfactors = set()\nfor i in range(2, int(math.sqrt(pairs[0][0]))+1):\n    if pairs[0][0] % i == 0:\n        factors.add(i)\n        while pairs[0][0] % i == 0:\n            pairs[0][0] //= i\nif pairs[0][0] > 1:\n    factors.add(pairs[0][0])\nfor i in range(2, int(math.sqrt(pairs[0][1]))+1):\n    if pairs[0][1] % i == 0:\n        factors.add(i)\n        while pairs[0][1] % i == 0:\n            pairs[0][1] //= i\nif pairs[0][1] > 1:\n    factors.add(pairs[0][1])\nfor i in range(1, n):\n    new_factors = set()\n    for f in factors:\n        if pairs[i][0] % f == 0 or pairs[i][1] % f == 0:\n            new_factors.add(f)\n    factors = new_factors\nif len(factors) == 0:\n    print(-1)\nelse:\n    print(max(factors))\n"
    },
    "3812": {
        "negative_solution": "s = input().strip()\nt = input().strip()\nn = len(s)\nm = len(t)\ns += 'b' * (m - n)\nt += 'a' * (n - m)\nn = len(s)\nm = len(t)\ns = list(s)\nt = list(t)\ns1 = [0] * (n + 1)\nt1 = [0] * (m + 1)\nfor i in range(n - 1, -1, -1):\n    s1[i] = s1[i + 1] + (s[i] == 'a')\nfor i in range(m - 1, -1, -1):\n    t1[i] = t1[i + 1] + (t[i] == 'a')\ns1 = s1[:-1]\nt1 = t1[:-1]\ns = s[:-1]\nt = t[:-1]\nn = len(s)\nm = len(t)\nif (s1[0] + t1[0]) % 2 == 1:\n    print(-1)\nelse:\n    ans = []\n    i = 0\n    j = 0\n    while i < n or j < m:\n        if s[i] == t[j]:\n            while i < n and j < m and s[i] == t[j]:\n                i += 1\n                j += 1\n            ans.append((i, j))\n        else:\n            while i < n and j < m and s[i] == s[i - 1]:\n                i += 1\n            while j < m and i < n and t[j] == t[j - 1]:\n                j += 1\n            ans.append((i, j))\n    print(len(ans))\n    for i in ans:\n        print(i[0], i[1])\n"
    },
    "3813": {
        "negative_solution": "import sys\nfrom collections import defaultdict\nfrom heapq import heapify,heappop,heappush\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nP = [0] + list(map(int,input().split()))\nX = [0] + list(map(int,input().split()))\nG = defaultdict(list)\nfor i in range(2,N+1):\n    G[P[i]].append(i)\ndp = [0]*(N+1)\ndp2 = [0]*(N+1)\ndp3 = [0]*(N+1)\ndef dfs(v):\n    if len(G[v]) == 0:\n        dp[v] = X[v]\n        dp2[v] = 0\n        dp3[v] = X[v]\n        return\n    dp[v] = X[v]\n    dp2[v] = 0\n    dp3[v] = 0\n    H = []\n    for u in G[v]:\n        dfs(u)\n        dp[v] -= dp[u]\n        dp2[v] += dp2[u]\n        dp3[v] += dp3[u]\n        heappush(H,dp2[u]-dp3[u])\n    if dp[v] < 0:\n        print(\"IMPOSSIBLE\")\n        exit()\n    while dp[v] < dp2[v]:\n        dp2[v] -= heappop(H)\n    if dp[v] < dp2[v] or dp[v] > dp3[v]:\n        print(\"IMPOSSIBLE\")\n        exit()\n    return\ndfs(1)\nprint(\"POSSIBLE\")\n"
    },
    "3814": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nfac = [1]\nfor i in range(1, N+2):\n    fac.append(fac[-1]*i%M)\ninv = [pow(fac[-1], M-2, M)]\nfor i in range(N+1, 0, -1):\n    inv.append(inv[-1]*i%M)\ninv.reverse()\npw = [1]\nfor _ in range(N+1):\n    pw.append(pw[-1]*2%M)\ndp = [[0]*(N+2) for _ in range(N+2)]\ndp[0][0] = 1\nfor i in range(1, N+2):\n    dp[i][0] = 1\n    for j in range(1, i+1):\n        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]*(j+1)) % M\nans = 0\nfor i in range(N+1):\n    cur = 0\n    for j in range(i+1):\n        cur = (cur + dp[i+1][j]*pw[N-i]*(pw[j]-1)) % M\n    cur = cur * fac[N] % M * inv[i] % M * inv[N-i] % M\n    if i % 2 == 0:\n        ans = (ans + cur) % M\n    else:\n        ans = (ans - cur) % M\nprint(ans)\n"
    },
    "3815": {
        "negative_solution": "MOD = 10**9 + 9\n\ndef power(x, y):\n    if y == 0:\n        return 1\n    elif y % 2 == 0:\n        return power(x, y // 2)**2 % MOD\n    else:\n        return x * power(x, y // 2)**2 % MOD\n\ndef inverse(x):\n    return power(x, MOD - 2)\n\nn, a, b, k = map(int, input().split())\ns = input().strip()\n\na = power(a, n)\nb = power(b, 1)\ninv_a = inverse(a)\ninv_b = inverse(b)\n\nsum_period = 0\nfor i in range(k):\n    if s[i] == '+':\n        sum_period = (sum_period + a * b) % MOD\n    else:\n        sum_period = (sum_period - a * b) % MOD\n    a = a * inv_a % MOD\n    b = b * inv_b % MOD\n\nnum_periods = (n + 1) // k\nsum_total = 0\nif num_periods > 1:\n    q = power(b, k)\n    inv_q = inverse(q)\n    sum_total = sum_period * (power(q, num_periods) - 1) * inv_q % MOD\nelse:\n    sum_total = sum_period\n\nprint(sum_total)\n"
    },
    "3816": {
        "negative_solution": "def solve():\n    a, b, c, l = map(int, input().split())\n    ans = 0\n    for i in range(l + 1):\n        ans += (i + 1) * (i + 2) // 2\n    for i in range(l + 1):\n        if a - b - c + i < 0:\n            continue\n        x = min(l - i, a - b - c + i)\n        ans -= (x + 1) * (x + 2) // 2\n    for i in range(l + 1):\n        if b - a - c + i < 0:\n            continue\n        x = min(l - i, b - a - c + i)\n        ans -= (x + 1) * (x + 2) // 2\n    for i in range(l + 1):\n        if c - a - b + i < 0:\n            continue\n        x = min(l - i, c - a - b + i)\n        ans -= (x + 1) * (x + 2) // 2\n    print(ans)\n\nsolve()\n"
    },
    "3817": {
        "negative_solution": "MOD = 10**9 + 9\nn, m = map(int, input().split())\np = [1]\nfor i in range(1, n + 1):\n    p.append(p[-1] * 2 % MOD)\nf = [0, p[m] - 1]\nfor i in range(2, n + 1):\n    f.append((f[-1] * 2 + p[m - 1] * (p[i - 1] - 1)) % MOD)\nprint(f[n])\n"
    },
    "3818": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nmod = 10**9+7\n\nn = int(input())\nG = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n    a, b = map(int,input().split())\n    G[a].append(b)\n    G[b].append(a)\n\ndp1 = [1]*(n+1)\ndp2 = [1]*(n+1)\norder = []\nstack = [1]\ncheck = [0]*(n+1)\ncheck[1] = 1\nwhile stack:\n    v = stack[-1]\n    order.append(v)\n    if G[v]:\n        w = G[v].pop()\n        if check[w]:\n            continue\n        check[w] = 1\n        stack.append(w)\n    else:\n        stack.pop()\n\nfor v in order[::-1]:\n    for w in G[v]:\n        dp1[v] *= dp2[w]\n        dp1[v] %= mod\n        dp2[v] *= dp1[w]+dp2[w]\n        dp2[v] %= mod\n    dp1[v] += dp2[v]\n    dp1[v] %= mod\n\nprint((pow(2,n,mod)-dp1[1]+mod)%mod)\n"
    },
    "3819": {
        "negative_solution": "import sys\nfrom collections import deque\nn = int(input())\nhand = list(map(int,input().split()))\npile = deque(list(map(int,input().split())))\nhand.sort()\nhand = deque(hand)\ncnt = [0]*(n+1)\nfor i in range(n):\n    if hand[i] != 0:\n        cnt[hand[i]] = i+1\nfor i in range(1,n+1):\n    cnt[i] = max(cnt[i],cnt[i-1])\nidx = 0\nwhile idx < n and pile[idx] == 0:\n    idx += 1\nif idx == n:\n    print(n)\n    sys.exit()\nstart = pile[idx]\nflag = False\nfor i in range(start,n+1):\n    if pile[idx] != i:\n        flag = True\n        break\n    idx += 1\nif not flag and cnt[start-1] <= n-idx:\n    print(n-idx)\nelse:\n    print(n+max(0,pile[idx-1]-1-cnt[pile[idx-1]-1]))\n"
    },
    "3820": {
        "negative_solution": "n, m = map(int, input().split())\ns = input()\nt = input()\n\nif '*' in s:\n    prefix, suffix = s.split('*')\n    if not t.startswith(prefix) or not t.endswith(suffix) or len(t) < len(s) - 1:\n        print('NO')\n    else:\n        print('YES')\nelse:\n    if s == t:\n        print('YES')\n    else:\n        print('NO')\n"
    },
    "3821": {
        "negative_solution": "n = int(input())\np = list(map(float, input().split()))\np.sort(reverse=True)\ndp = [0] * (n + 1)\ndp[0] = 1\nfor i in range(n):\n    for j in range(i + 1, -1, -1):\n        dp[j] = max(dp[j] * (1 - p[i]), dp[j - 1] * p[i] if j else 0)\nprint(max(dp))\n"
    },
    "3822": {
        "negative_solution": "import math\nn, l, v1, v2, k = map(int, input().split())\ng = math.ceil(n / k)\nb = (l / (1 + (v1 / v2) * ((g - 1) / g)))\na = l - b\nprint(a / v1 + b / v2)\n"
    },
    "3823": {
        "negative_solution": "import math\nn = int(input())\na = list(map(float, input().split()))\ndp = [[0 for _ in range(n+1)] for _ in range(n+1)]\nfor i in range(n+1):\n    for j in range(n+1):\n        dp[i][j] = 1e9\ndp[0][0] = 0\ncnt = [0, 0]\nfor i in range(2*n):\n    cnt[int(a[i] == int(a[i]))] += 1\n    for j in range(cnt[0]+1):\n        if cnt[1] >= i-j+1:\n            dp[cnt[0]][j] = min(dp[cnt[0]][j], abs(j - (a[i] - int(a[i]))))\n        if j > 0:\n            dp[cnt[0]][j] = min(dp[cnt[0]][j], dp[cnt[0]][j-1] + abs((j-1) - (a[i] - math.floor(a[i]))))\nprint(\"%.3f\" % min(dp[cnt[0]][j] for j in range(n+1)))\n"
    },
    "3824": {
        "negative_solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\nif dx == 0 or dy == 0:\n    print(2 * (dx + dy + 2))\nelse:\n    print(2 * (dx + dy))"
    },
    "3825": {
        "negative_solution": "n = int(input())\nif n <= 3:\n    print(n * (n + 1) // 2)\nelif n == 4:\n    print(10)\nelse:\n    print((n - 3) * (n - 4) // 2 + 10)\n"
    },
    "3826": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na = [0] + a + [0]\nf = [0]*(n+2)\ng = [0]*(n+2)\npos = [0]*(n+2)\nres = n\nfor i in range(1, n+1):\n    f[i] = f[i-1]\n    if pos[a[i]] > f[i]:\n        f[i] = pos[a[i]]\n    pos[a[i]] = i\npos = [0]*(n+2)\nfor i in range(n, 0, -1):\n    g[i] = g[i+1]\n    if pos[a[i]] < g[i]:\n        g[i] = pos[a[i]]\n    pos[a[i]] = i\nfor i in range(1, n+2):\n    res = min(res, g[i] - f[i-1] - 1)\nprint(res)\n"
    },
    "3827": {
        "negative_solution": "s = input()\na = s.count('a')\nb = s.count('b')\nc = s.count('c')\nif a >= 1 and b >= 1 and (c == a or c == b) and s == 'a' * a + 'b' * b + 'c' * c:\n    print('YES')\nelse:\n    print('NO')\n"
    },
    "3828": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\ndp = [0]*(n+1)\nfor i in range(n):\n    dp[a[i]] = dp[a[i]-1] + 1\nprint(n - max(dp))\n"
    },
    "3829": {
        "negative_solution": "m, n = map(int, input().split())\np = [0] * (m + 1)\nfor i in range(1, m + 1):\n    p[i] = pow(i / m, n) - pow((i - 1) / m, n)\nprint(sum([i * p[i] for i in range(m + 1)]))\n"
    },
    "3830": {
        "negative_solution": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    if '>' in s and '<' in s:\n        s += s[0]\n        ans = 0\n        for i in range(n):\n            if s[i] == '-' or s[i+1] == '-':\n                ans += 1\n        print(ans)\n    else:\n        print(n)\n"
    },
    "3831": {
        "negative_solution": "n = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [a[i][0] + a[i][1] for i in range(n)]\nfor i in range(1, n):\n    b[i] = min(b[i], b[i - 1] + 1)\nfor i in range(n - 2, -1, -1):\n    b[i] = min(b[i], b[i + 1] + 1)\nif any(b[i] < a[i][0] for i in range(n)):\n    print(-1)\nelse:\n    print(sum(b) - sum(a[i][0] for i in range(n)))\n    print(*b)\n"
    },
    "3832": {
        "negative_solution": "import sys\nfrom math import inf\n\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\ndp = [[inf]*n for _ in range(n//2+1)]\ndp[0][0] = 0\nfor i in range(1, n):\n    dp[0][i] = min(dp[0][i-1], max(0, a[i-1]-a[i]+1))\n\nfor i in range(1, n//2+1):\n    dp[i][2*i-1] = dp[i-1][2*i-3] if i > 1 else 0\n    dp[i][2*i-1] += max(0, a[2*i-2]-min(a[2*i-1], a[2*i-3] if i > 1 else inf)+1)\n    for j in range(2*i, n):\n        dp[i][j] = min(dp[i][j-1], dp[i-1][j-2]+max(0, a[j-1]-min(a[j], a[j-2] if j > 2 else inf)+1))\n\nfor i in range(1, n//2+1):\n    dp[i][n-1] = min(dp[i][n-1], dp[i-1][n-2] if i > 1 else 0)\n\nprint(*[dp[i][n-1] for i in range(1, n//2+1)])\n"
    },
    "3833": {
        "negative_solution": "s = input().strip()\nt = input().strip()\ns1 = s.count('1')\ns0 = s.count('0')\nt1 = t.count('1')\nt0 = t.count('0')\nif s1 < t1 or s0 < t0:\n    print(s)\nelse:\n    s1 -= t1\n    s0 -= t0\n    i = len(t) - 1\n    while i > 0 and t[i:] != t[:-i]:\n        i -= 1\n    t1 -= t[:i].count('1')\n    t0 -= t[:i].count('0')\n    print(t + (s1 // t1 * t0 + s0) * '0' + (s1 // t1 * t1) * '1' + (s1 % t1) * '1')\n"
    },
    "3834": {
        "negative_solution": "n, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nif m == 1 or n == 1:\n    ans = min(sum(a[i][0] != a[i - 1][0] for i in range(1, n)), sum(a[i][0] != a[i - 1][0] for i in range(1, m)))\n    print(ans if ans <= k else -1)\nelse:\n    ans = float('inf')\n    for i in range(1 << n):\n        b = [list(row) for row in a]\n        res = bin(i).count('1')\n        for j in range(m):\n            cnt = sum(b[x][j] != ((i >> x) & 1) for x in range(n))\n            if cnt * 2 > n:\n                res += n - cnt\n            else:\n                for x in range(n):\n                    b[x][j] = (i >> x) & 1\n        if res <= k:\n            ans = min(ans, res)\n    print(ans if ans != float('inf') else -1)\n"
    },
    "3835": {
        "negative_solution": "import math\nn = int(input())\na = [list(map(int,input().split())) for _ in range(n)]\nx = int(math.sqrt(a[0][1]*a[0][2]/a[1][2]))\nprint(x, end=' ')\nfor i in range(1,n):\n    print(a[0][i]//x, end=' ')\n"
    },
    "3836": {
        "negative_solution": "from sys import stdin, stdout\nfrom operator import itemgetter\n\nn = int(stdin.readline())\npeople = []\nalice = []\nbob = []\nnone = []\nfor _ in range(n):\n    s, a = stdin.readline().split()\n    a = int(a)\n    if s == '11':\n        people.append(a)\n    elif s == '10':\n        alice.append(a)\n    elif s == '01':\n        bob.append(a)\n    else:\n        none.append(a)\npeople.sort(reverse=True)\nalice.sort(reverse=True)\nbob.sort(reverse=True)\nnone.sort(reverse=True)\nwhile len(alice) > 0 and len(bob) > 0:\n    people.append(alice.pop(0))\n    people.append(bob.pop(0))\nif len(alice) > 0:\n    people += alice\nelif len(bob) > 0:\n    people += bob[:len(people)-len(bob)]\npeople += none[:len(people)-len(none)]\nstdout.write(str(sum(people)) + '\\n')\n"
    },
    "3837": {
        "negative_solution": "import heapq\nimport sys\nfrom operator import itemgetter\n\ndef solve():\n    n, m, s = map(int, input().split())\n    bugs = list(map(int, input().split()))\n    students = list(zip(map(int, input().split()), map(int, input().split()), range(n)))\n    students.sort(reverse=True)\n    bugs = [(bug, i) for i, bug in enumerate(bugs)]\n    bugs.sort(reverse=True)\n\n    l = 0\n    r = m + 1\n    while r - l > 1:\n        mid = (l + r) // 2\n        total_passes = 0\n        heap = []\n        j = 0\n        for i in range(mid - 1, -1, -1):\n            while j < n and students[j][0] >= bugs[i][0]:\n                heapq.heappush(heap, (-students[j][1], students[j][2]))\n                j += 1\n            if not heap:\n                total_passes = s + 1\n                break\n            total_passes += -heap[0][0]\n            bugs[i] = (bugs[i][1], heap[0][1] + 1)\n            heapq.heappop(heap)\n        if total_passes <= s:\n            r = mid\n        else:\n            l = mid\n\n    if r == m + 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        bugs.sort()\n        print(\" \".join(map(str, [bug[1] for bug in bugs])))\n\nsolve()\n"
    },
    "3838": {
        "negative_solution": "def main():\n    n, k = map(int, input().split())\n    q = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    q = [i-1 for i in q]\n    s = [i-1 for i in s]\n    p = [i for i in range(n)]\n    q_inv = [0]*n\n    for i in range(n):\n        q_inv[q[i]] = i\n    if k == 1:\n        p = [p[q[i]] for i in range(n)]\n        if p == s:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        p1 = [p[q[i]] for i in range(n)]\n        p2 = [p[q_inv[i]] for i in range(n)]\n        if p1 == s or p2 == s:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\nmain()\n"
    },
    "3839": {
        "negative_solution": "n = int(input())\nfor i in range(1, n+1):\n    if i%3 == 0:\n        print(i//3*2, 3)\n    else:\n        print((i+2)//3*2-1, i%3)\n"
    },
    "3840": {
        "negative_solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1 or n % 2 == 0:\n        print(-1)\n        return\n    a = [0] + a\n    f = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        need = (a[i] + 1) // 2\n        f[i] = max(need, f[2 * i] + f[2 * i + 1] if 2 * i + 1 <= n else f[2 * i])\n        a[i - 1] = max(0, a[i - 1] - (a[i] - f[i]))\n    print(f[1])\n\nsolve()\n"
    },
    "3841": {
        "negative_solution": "def solve(p, k):\n    res = []\n    while p:\n        res.append(p % k)\n        p = -(p // k)\n    return res\n\np, k = map(int, input().split())\nres = solve(p, k)\nprint(len(res))\nprint(*res)\n"
    },
    "3842": {
        "negative_solution": "import sys\nfrom bisect import bisect_right\n\nn, p, q = map(int, input().split())\nprojects = sorted([list(map(int, input().split())) for _ in range(n)], reverse=True)\n\nhull = [(0, 0)]\nfor a, b in projects:\n    while hull[-1][1] <= b:\n        hull.pop()\n    hull.append((a, b))\n\nINF = 1e18\nlo, hi = 0, INF\nwhile hi - lo > 1e-9:\n    mid = (lo + hi) / 2\n    max_b = -INF\n    for a, b in hull:\n        if a * mid >= p:\n            max_b = max(max_b, b)\n        else:\n            idx = bisect_right(hull, ((p - a * mid) / (mid - a), INF))\n            if idx < len(hull):\n                max_b = max(max_b, (p - a * mid) / (mid - a) * hull[idx][1] + b)\n            break\n    if max_b * mid >= q:\n        hi = mid\n    else:\n        lo = mid\n\nprint('%.15f' % hi)\n"
    },
    "3843": {
        "negative_solution": "def solve():\n    n, m = map(int, input().split())\n    n -= 1\n    m -= 1\n    a = 0\n    while n:\n        a += 1\n        n //= 7\n    b = 0\n    while m:\n        b += 1\n        m //= 7\n    if a == 0:\n        a = 1\n    if b == 0:\n        b = 1\n    if a + b > 7:\n        print(0)\n        return\n    n = 7\n    m = a + b\n    ans = 0\n    for i in range(1 << n):\n        if bin(i).count('1') == m:\n            a = [0] * m\n            b = [0] * m\n            c = 0\n            for j in range(n):\n                if i & (1 << j):\n                    a[c] = j\n                    c += 1\n            for j in range(m):\n                for k in range(j + 1, m):\n                    if a[j] > a[k]:\n                        a[j], a[k] = a[k], a[j]\n            while True:\n                x = 0\n                y = 0\n                for j in range(m):\n                    if j < b:\n                        x = x * 7 + a[j]\n                    else:\n                        y = y * 7 + a[j]\n                if x < int(input().split()[0]) and y < int(input().split()[1]):\n                    ans += 1\n                j = m - 1\n                while j > 0 and a[j - 1] >= a[j]:\n                    j -= 1\n                if j == 0:\n                    break\n                k = m - 1\n                while a[j - 1] >= a[k]:\n                    k -= 1\n                a[j - 1], a[k] = a[k], a[j - 1]\n                a[j:] = a[:j - 1:-1]\n    print(ans)\n\n\nsolve()\n"
    },
    "3844": {
        "negative_solution": "from collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\nc = Counter(a)\n\nfor i in c.values():\n    if i % 2 != 0:\n        print(\"Conan\")\n        break\nelse:\n    print(\"Agasa\")\n"
    },
    "3845": {
        "negative_solution": "A, B = map(int, input().split())\nA -= 1\nB -= 1\ngrid = [['.' if i < 50 else '#' for _ in range(100)] for i in range(100)]\nfor i in range(0, 50, 2):\n    for j in range(0, 100, 2):\n        if A == 0:\n            break\n        grid[i][j] = '#'\n        A -= 1\n    if A == 0:\n        break\nfor i in range(51, 100, 2):\n    for j in range(0, 100, 2):\n        if B == 0:\n            break\n        grid[i][j] = '.'\n        B -= 1\n    if B == 0:\n        break\nprint(100, 100)\nfor row in grid:\n    print(''.join(row))\n"
    },
    "3846": {
        "negative_solution": "n, m = map(int, input().split())\na = [0]*n\nb = [0]*n\nc = [0]*n\nd = [0]*n\ne = [0]*n\nf = [0]*n\ng = [0]*n\nh = [0]*n\nj = [0]*n\nk = [0]*n\nl = [0]*n\np = [0]*n\nq = [0]*n\nr = [0]*n\ns = [0]*n\nt = [0]*n\nu = [0]*n\nv = [0]*n\nw = [0]*n\nx = [0]*n\ny = [0]*n\nz = [0]*n\nfor i in range(m):\n    s, t = input().split()\n    t = int(t)-1\n    if s == '+':\n        if i > 0 and a[i-1] > 0:\n            b[t] = 1\n        a[i] = a[i-1]+1\n        c[t] = 1\n        if a[i] > 1:\n            d[t] = 1\n    else:\n        if c[t] == 0:\n            if i > 0 and a[i-1] > 0:\n                b[t] = 1\n            a[i] = a[i-1]+1\n            c[t] = 1\n        else:\n            a[i] = a[i-1]-1\n            if a[i] > 0:\n                d[t] = 1\n    e[t] = i\nfor i in range(n):\n    if e[i] < m-1 and a[e[i]]-1 > 0:\n        b[i] = 1\n    if a[-1] > 0 and c[i] == 1 and d[i] == 0:\n        b[i] = 1\nprint(b.count(0))\nfor i in range(n):\n    if b[i] == 0:\n        print(i+1, end=' ')\n"
    },
    "3847": {
        "negative_solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nx = int(input())\n\na.sort()\nb.sort()\n\nprefix_a = [0] * (n + 1)\nprefix_b = [0] * (m + 1)\n\nfor i in range(n):\n    prefix_a[i + 1] = prefix_a[i] + a[i]\n\nfor i in range(m):\n    prefix_b[i + 1] = prefix_b[i] + b[i]\n\nmax_size_a = [0] * (prefix_a[-1] + 1)\nmax_size_b = [0] * (prefix_b[-1] + 1)\n\nfor i in range(n):\n    for j in range(i, n):\n        sum_a = prefix_a[j + 1] - prefix_a[i]\n        size_a = j - i + 1\n        max_size_a[sum_a] = max(max_size_a[sum_a], size_a)\n\nfor i in range(m):\n    for j in range(i, m):\n        sum_b = prefix_b[j + 1] - prefix_b[i]\n        size_b = j - i + 1\n        max_size_b[sum_b] = max(max_size_b[sum_b], size_b)\n\nfor i in range(1, len(max_size_a)):\n    max_size_a[i] = max(max_size_a[i], max_size_a[i - 1])\n\nfor i in range(1, len(max_size_b)):\n    max_size_b[i] = max(max_size_b[i], max_size_b[i - 1])\n\nanswer = 0\nfor sum_a in range(len(max_size_a)):\n    if sum_a > x:\n        break\n    size_a = max_size_a[sum_a]\n    size_b = max_size_b[min(x // sum_a, prefix_b[-1])]\n    answer = max(answer, size_a * size_b)\n\nprint(answer)\n"
    },
    "3848": {
        "negative_solution": "def solve():\n    n, p = map(int, input().split())\n    s = list(input())\n    s.append('a')\n    for i in range(n - 1, -1, -1):\n        for j in range(ord(s[i]) + 1, ord('a') + p):\n            s[i] = chr(j)\n            if (i >= 2 and s[i] == s[i - 1] == s[i - 2]) or (i >= 1 and s[i] == s[i - 1]):\n                continue\n            for k in range(i + 1, n):\n                for l in range(ord('a'), ord('a') + p):\n                    s[k] = chr(l)\n                    if (k >= 2 and s[k] == s[k - 1] == s[k - 2]) or (k >= 1 and s[k] == s[k - 1]):\n                        continue\n                    break\n                else:\n                    break\n            else:\n                print(''.join(s[:-1]))\n                return\n    print('NO')\n\nsolve()\n"
    },
    "3849": {
        "negative_solution": ""
    },
    "3850": {
        "negative_solution": "from heapq import *\nn, k, p = map(int, input().split())\na = sorted(list(map(int, input().split())))\nb = sorted(list(map(int, input().split())))\nl = 0\nr = 2 * 10 ** 9\nwhile r - l > 1:\n    m = (l + r) // 2\n    q = []\n    j = 0\n    f = 1\n    for i in range(n):\n        while j < k and b[j] <= a[i] + m:\n            heappush(q, b[j] - a[i])\n            j += 1\n        if not q or q[0] < a[i] - p:\n            f = 0\n            break\n        heappop(q)\n    if f and j == k and len(q) < n - i - 1:\n        f = 0\n    if f:\n        r = m\n    else:\n        l = m\nprint(r)\n"
    },
    "3851": {
        "negative_solution": "from math import gcd\nfrom sys import stdin, stdout\nn, k = map(int, stdin.readline().split())\na, b = map(int, stdin.readline().split())\ndef solve(n, k, a, b):\n    x = n * k\n    y = 1\n    for i in range(n):\n        for j in range(-1, 2, 2):\n            p = (i * k + a) % (n * k)\n            q = (i * k + b + j * k) % (n * k)\n            g = gcd(n * k, abs(p - q))\n            x = min(x, n * k // g)\n            y = max(y, n * k // g)\n    return x, y\nx, y = solve(n, k, a, b)\nstdout.write(str(x) + ' ' + str(y) + '\\n')\n"
    },
    "3852": {
        "negative_solution": "N = int(input())\nA = list(map(int, input().split()))\nmin_a = min(A)\nmax_a = max(A)\nmin_i = A.index(min_a)\nmax_i = A.index(max_a)\nif abs(min_a) > abs(max_a):\n    print(2*N-1)\n    for i in range(N):\n        print(min_i+1, i+1)\n    for i in range(N-1):\n        print(i+1, i+2)\nelse:\n    print(2*N-1)\n    for i in range(N):\n        print(max_i+1, i+1)\n    for i in range(N-1, 0, -1):\n        print(i+1, i)\n"
    },
    "3853": {
        "negative_solution": "import math\nn = int(input())\na = [list(map(int,input().split())) for _ in range(n)]\na.sort()\nb = [0]*(n+1)\nb[n] = a[n-1][0]+1\nfor i in range(n-1,-1,-1):\n    b[i] = max(b[i+1],a[i][0]+1+math.ceil(math.log2(a[i][1])))\nprint(b[0])\n"
    },
    "3854": {
        "negative_solution": "n, k = map(int, input().split())\nc = list(map(int, input().split()))\ndp = [[0]*501 for _ in range(501)]\ndp[0][0] = 1\nfor i in range(n):\n    for j in range(k, -1, -1):\n        for l in range(c[i], 501):\n            if dp[j][l-c[i]]:\n                dp[j+c[i]][l] = 1\nres = [i for i in range(501) if dp[k][i]]\nprint(len(res))\nprint(*res)\n"
    },
    "3855": {
        "negative_solution": "import math\nn = int(input().strip())\nprint(math.ceil(math.log2(n+1)))\n"
    },
    "3856": {
        "negative_solution": "from sys import stdin, stdout\nfrom heapq import *\nn = int(stdin.readline())\na = []\nfor i in range(n):\n    w, h = map(int, stdin.readline().split())\n    a.append((max(w, h), min(w, h)))\na.sort(reverse=True)\nH = a[0][0]\nW = sum(x[1] for x in a)\nheap = []\nfor i in range(n):\n    if len(heap) < n // 2:\n        heappush(heap, a[i][1])\n        W += a[i][0] - a[i][1]\n    else:\n        if heap and heap[0] < a[i][1]:\n            W += a[i][0] - heap[0]\n            heappushpop(heap, a[i][1])\n        else:\n            W += a[i][0] - a[i][1]\n            H = max(H, a[i][1])\nstdout.write(str(min(W * H, sum(x[0] for x in a) * H)))\n"
    },
    "3857": {
        "negative_solution": "n = int(input())\nx = list(map(int, input().split()))\nx.sort()\npiles = [0]*n\nfor i in range(n):\n    piles[i%n] += 1\n    if piles[i%n] > x[i]:\n        print(-1)\n        exit(0)\nprint(max(piles))\n"
    },
    "3858": {
        "negative_solution": "from collections import defaultdict\nfrom itertools import combinations\n\nMOD = 998244353\nN = int(input())\nXY = [tuple(map(int, input().split())) for _ in range(N)]\nXY.sort()\n\npow2 = [1]\nfor _ in range(N):\n    pow2.append(pow2[-1]*2%MOD)\n\nans = pow2[N] - 1 - N\nfor n in range(2, N+1):\n    for comb in combinations(range(N), n):\n        x0, y0 = XY[comb[0]]\n        vec = defaultdict(int)\n        for i in range(1, n):\n            x, y = XY[comb[i]]\n            vec[(y-y0, x-x0)] += 1\n        ans -= pow2[n] - 1 - n\n        for v in vec.values():\n            ans += pow2[v] - 1 - v\n        ans %= MOD\n\nprint(ans)\n"
    },
    "3859": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nINF = 10**18\n\nN = int(input())\nballs = [tuple(map(str, input().split())) for _ in range(2*N)]\nballs = [(c, int(a)) for c, a in balls]\n\ndp = [[INF]*(N+1) for _ in range(N+1)]\ndp[0][0] = 0\n\nW = [0]*(N+1)\nB = [0]*(N+1)\n\nfor i in range(2*N):\n    c, a = balls[i]\n    if c == 'W':\n        W[a] = i+1\n    else:\n        B[a] = i+1\n\nfor i in range(N+1):\n    for j in range(N+1):\n        if i > 0:\n            dp[i][j] = min(dp[i][j], dp[i-1][j] + sum(1 for k in range(j+1, N+1) if B[k] < W[i]))\n        if j > 0:\n            dp[i][j] = min(dp[i][j], dp[i][j-1] + sum(1 for k in range(i+1, N+1) if W[k] < B[j]))\n\nprint(dp[N][N])\n"
    },
    "3860": {
        "negative_solution": "b = int(input())\ng = int(input())\nn = int(input())\n\nprint(min(b, g, n) - max(0, n - max(b, g)) + 1)"
    },
    "3861": {
        "negative_solution": "import math\nn = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\nfor i in a:\n    if math.sqrt(i) != int(math.sqrt(i)):\n        print(i)\n        break\n"
    },
    "3862": {
        "negative_solution": "from heapq import *\nfrom sys import stdin, stdout\nn, k = map(int, stdin.readline().split())\na = list(map(int, stdin.readline().split()))\na = list(set(a))\na.sort()\nk = len(a)\nl = 0\nr = k - 1\nd = [0] * 2005\nq = []\nfor i in range(2005):\n    d[i] = 10**9\nd[a[l] - n + 1000] = a[l]\nd[a[r] - n + 1000] = a[r]\nheappush(q, (a[l], a[l] - n + 1000))\nheappush(q, (a[r], a[r] - n + 1000))\nwhile len(q) > 0:\n    v, p = heappop(q)\n    if p == 1000:\n        stdout.write(str(v) + \"\\n\")\n        exit(0)\n    if l > 0 and p - a[l - 1] + 1000 >= 0 and d[p - a[l - 1] + 1000] > v + a[l - 1]:\n        d[p - a[l - 1] + 1000] = v + a[l - 1]\n        heappush(q, (v + a[l - 1], p - a[l - 1] + 1000))\n    if r + 1 < k and p + a[r + 1] - 1000 >= 0 and d[p + a[r + 1] - 1000] > v + a[r + 1]:\n        d[p + a[r + 1] - 1000] = v + a[r + 1]\n        heappush(q, (v + a[r + 1], p + a[r + 1] - 1000))\nstdout.write(\"-1\\n\")\n"
    },
    "3863": {
        "negative_solution": "This problem cannot be solved using Python as it requires a deep understanding of number theory and combinatorics, which are beyond the scope of Python's capabilities. The solution involves calculating the number of ways to arrange the integers in a palindrome sequence and then rotating the sequence an arbitrary number of times. This requires the use of mathematical formulas and algorithms that cannot be implemented in Python."
    },
    "3864": {
        "negative_solution": "MOD = 998244353\nn = int(input())\ninv = [0, 1]\nfor i in range(2, n+2):\n    inv.append((MOD - MOD//i)*inv[MOD%i]%MOD)\ns = [0, 0]\nt = [0, 1]\nfor i in range(2, n+2):\n    s.append((s[-1]+t[-1]*2)%MOD)\n    t.append((t[-1]+s[-2]*2)%MOD)\nx = [0, 1]\ny = [0, 1]\nfor i in range(2, n+2):\n    x.append((x[-1]+y[-1]*inv[i])%MOD)\n    y.append((y[-1]+x[-2]*inv[i])%MOD)\nfor i in range(1, n+1):\n    print((500000004*(s[n+1-i]+s[i]-1)+x[n+1-i]*t[i-1]+y[i]*s[n+1-i])%MOD)\n"
    },
    "3865": {
        "negative_solution": "a = int(input().strip())\nif a % 3 == 0:\n    print(-1)\nelse:\n    print('1' * a)\n"
    },
    "3866": {
        "negative_solution": "n = int(input())\nif n % 2 == 0:\n    print(-1)\nelse:\n    a = [i for i in range(n)]\n    b = a.copy()\n    c = [(2 * i) % n for i in range(n)]\n    print(*a)\n    print(*b)\n    print(*c)\n"
    },
    "3867": {
        "negative_solution": "from collections import deque\nfrom sys import stdin, stdout\n\ndef bfs(n, graph, bfs_order):\n    visited = [0] * (n + 1)\n    queue = deque([1])\n    visited[1] = 1\n    bfs_index = 1\n\n    while queue:\n        node = queue.popleft()\n        unvisited = [child for child in graph[node] if not visited[child]]\n        expected = bfs_order[bfs_index:bfs_index + len(unvisited)]\n        if set(unvisited) != set(expected):\n            return False\n        bfs_index += len(unvisited)\n        queue.extend(expected)\n        for child in expected:\n            visited[child] = 1\n    return True\n\nn = int(stdin.readline())\ngraph = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, stdin.readline().split())\n    graph[u].add(v)\n    graph[v].add(u)\nbfs_order = list(map(int, stdin.readline().split()))\nstdout.write(\"Yes\\n\" if bfs(n, graph, bfs_order) else \"No\\n\")\n"
    },
    "3868": {
        "negative_solution": "import sys\nfrom heapq import *\nn, m, k = map(int, sys.stdin.readline().split())\nflights = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]\nflights.sort()\narrive = [10**9]*n\ndepart = [10**9]*n\narrive_time = [0]*n\ndepart_time = [10**6]*n\narrive_sum = [0]\ndepart_sum = [0]\nfor d, f, t, c in flights:\n    if t == 0:\n        if c < arrive[f-1]:\n            arrive_sum.append(arrive_sum[-1]-arrive[f-1]+c)\n            arrive[f-1] = c\n            arrive_time[f-1] = d\n    else:\n        if c < depart[t-1] and d > depart_time[t-1]:\n            depart_sum.append(depart_sum[-1]-depart[t-1]+c)\n            depart[t-1] = c\n            depart_time[t-1] = d\narrive_sum = arrive_sum[1:]\ndepart_sum = depart_sum[1:]\ndepart_sum.reverse()\ndepart_time.reverse()\ni = 0\nj = 0\nwhile i < len(arrive_sum) and j < len(depart_sum):\n    if arrive_time[i]+k <= depart_time[j]:\n        i += 1\n        j += 1\n    else:\n        j += 1\nif i == len(arrive_sum):\n    print(-1)\nelse:\n    print(min(arrive_sum[i:])+min(depart_sum[:j])*n)\n"
    },
    "3869": {
        "negative_solution": "import math\n\ndef solve(w, h, a):\n    if w < h:\n        w, h = h, w\n    if a > 90:\n        a = 180 - a\n    a = math.radians(a)\n    if a >= math.atan(h / w):\n        return h * h / math.sin(a)\n    else:\n        return w * h - (math.pow(w, 2) + math.pow(h, 2) - math.pow(w * h * math.sin(a), 2) / 4) / 2\n\nw, h, a = map(int, input().split())\nprint(\"{0:.15f}\".format(solve(w, h, a)))\n"
    },
    "3870": {
        "negative_solution": "def solve():\n    n, m = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(n):\n        s, x = input().split()\n        x = int(x)\n        if s == \"ATK\":\n            a.append(x)\n        else:\n            b.append(x)\n    a.sort()\n    b.sort()\n    c = list(map(int, input().split()))\n    c.sort()\n    ans = 0\n    while a and c and c[-1] >= a[0]:\n        ans += c[-1] - a[0]\n        a.pop(0)\n        c.pop()\n    while b and c and c[-1] > b[-1]:\n        b.pop()\n        c.pop()\n    if b:\n        print(ans)\n    else:\n        ans += sum(c)\n        print(ans)\n\n\nsolve()\n"
    },
    "3871": {
        "negative_solution": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    l = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    l = [(l[i], s[i]) for i in range(n)]\n    l.sort(reverse=True)\n    dp = [[-sys.maxsize] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(i + 1):\n            dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + c[l[i][0]] - l[i][1])\n            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n        for j in range(i + 2, 0, -1):\n            dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i + 1][j] + c[l[i][0] + 1])\n    print(max(dp[n]))\n\nsolve()\n"
    },
    "3872": {
        "negative_solution": "def solve(s):\n    if len(s) % 2:\n        return s\n    else:\n        s1 = solve(s[:len(s)//2])\n        s2 = solve(s[len(s)//2:])\n        if s1 < s2:\n            return s1 + s2\n        else:\n            return s2 + s1\n\ns1 = input().strip()\ns2 = input().strip()\n\nif solve(s1) == solve(s2):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n"
    },
    "3873": {
        "negative_solution": "n = int(input().strip())\nif n % 4 > 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(1, n + 1, 4):\n        for j in range(i + 1, min(n + 1, i + 4)):\n            for k in range(i, j):\n                print(k, j)\n    for i in range(2, n + 1, 4):\n        for j in range(i + 1, min(n + 1, i + 4)):\n            for k in range(i, j):\n                print(k, j)\n"
    },
    "3874": {
        "negative_solution": "n, m = map(int, input().split())\nfiles = [input() for _ in range(n)]\nto_delete = list(map(int, input().split()))\nto_delete = [files[i-1] for i in to_delete]\npattern = list(to_delete[0])\nfor file in to_delete[1:]:\n    if len(file) != len(pattern):\n        print('No')\n        exit(0)\n    for i in range(len(file)):\n        if file[i] != pattern[i]:\n            pattern[i] = '?'\nfor file in files:\n    if file not in to_delete:\n        if len(file) == len(pattern) and all(file[i] == pattern[i] or pattern[i] == '?' for i in range(len(file))):\n            print('No')\n            exit(0)\nprint('Yes')\nprint(''.join(pattern))\n"
    },
    "3875": {
        "negative_solution": "MOD = 10**9+7\nN = int(input())\nA = list(map(int, input().split()))\nA.sort()\ndp = [0]*(N+1)\ndp[0] = 1\nfor a in A:\n    ndp = dp[:]\n    for i in range(N):\n        if a >= i+1:\n            ndp[i+1] += dp[i]\n            ndp[i+1] %= MOD\n    dp = ndp\nprint(sum(dp[i]*i%MOD for i in range(N+1))%MOD)\n"
    },
    "3876": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nmod = 10**9+7\n\nN = int(input())\nG = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nsize = [0]*(N+1)\ndp = [[0]*(N+1) for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(N):\n    dp[i+1][0] = 1\n    for j in range(i+1):\n        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod\n        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j+1]) % mod\n\ndef dfs(v, p=-1):\n    size[v] = 1\n    tmp = [0]*(N+1)\n    tmp[0] = 1\n    for u in G[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n        for i in range(size[v], -1, -1):\n            for j in range(size[u]+1):\n                tmp[i+j] = (tmp[i+j] + dp[size[u]][j]*tmp[i]) % mod\n        size[v] += size[u]\n    for i in range(size[v]+1):\n        dp[v][i] = tmp[i]\n\ndfs(1)\nans = 0\nfor i in range(N+1):\n    if i % 2 == 1:\n        continue\n    ans = (ans + dp[1][i]) % mod\nprint((pow(2, N, mod) - ans + mod) % mod)\n"
    },
    "3877": {
        "negative_solution": "def solve(n, l, r):\n    def count_ones(n, l, r):\n        if n == 0 or r <= 0 or l > n:\n            return 0\n        m = (n + 1) // 2\n        if r <= m:\n            return count_ones(m, l, r)\n        elif l > m:\n            return count_ones(m, l - m, r - m)\n        else:\n            return count_ones(m, l, m) + count_ones(m, 1, r - m)\n    return count_ones(2 ** n.bit_length(), l, r)\n\nn, l, r = map(int, input().split())\nprint(solve(n, l, r))\n"
    },
    "3878": {
        "negative_solution": "import sys\nfrom itertools import combinations\n\ndef solve():\n    n, m = map(int, input().split())\n    if m == n * (n - 1) // 2:\n        print(0)\n        return\n    g = [0] * n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u] |= 1 << v\n        g[v] |= 1 << u\n    for i in range(n):\n        g[i] |= 1 << i\n    dp = [float('inf')] * (1 << n)\n    dp[0] = 0\n    for mask in range(1 << n):\n        for submask in range(mask):\n            if submask & mask == submask and dp[mask] > dp[mask ^ submask] + 1:\n                dp[mask] = dp[mask ^ submask] + 1\n    print(dp[(1 << n) - 1])\n    mask = (1 << n) - 1\n    while mask:\n        for submask in range(mask):\n            if submask & mask == submask and dp[mask] == dp[mask ^ submask] + 1:\n                print(bin(mask ^ submask).count('1'), end=' ')\n                mask ^= submask\n                break\n    print()\n\nsolve()\n"
    },
    "3879": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    while a[i] % 2 == 0:\n        a[i] //= 2\n    while a[i] % 3 == 0:\n        a[i] //= 3\nif len(set(a)) == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n"
    },
    "3880": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nif n % 2 == 1 or a.count(0) > 0:\n    print(sum(map(abs, a)))\nelse:\n    print(sum(map(abs, a)) - 2 * min(map(abs, a)))\n"
    },
    "3881": {
        "negative_solution": "def solve(n, q, a, b):\n    dp = [[0]*6 for _ in range(n+1)]\n    dp[1][0] = 1\n    for i in range(2, n+1):\n        for j in range(6):\n            for k in range(q):\n                if b[k] == chr(ord('a')+j):\n                    dp[i][j] += dp[i-1][ord(a[k][0])-ord('a')] * dp[i-1][ord(a[k][1])-ord('a')]\n    return dp[n][0]\n\nn, q = map(int, input().split())\na = []\nb = []\nfor _ in range(q):\n    ai, bi = input().split()\n    a.append(ai)\n    b.append(bi)\nprint(solve(n, q, a, b))\n"
    },
    "3882": {
        "negative_solution": "MOD = 10**9 + 7\nn = int(input().strip())\nC = [[0 for _ in range(n+1)] for _ in range(n+1)]\nC[0][0] = 1\nfor i in range(1, n+1):\n    C[i][0] = 1\n    for j in range(1, i+1):\n        C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD\ndp = [0 for _ in range(n+1)]\ndp[0] = dp[1] = 1\nfor i in range(2, n+1):\n    dp[i] = pow(2, pow(2, i-1, MOD-1), MOD)\n    for j in range(1, i):\n        dp[i] -= C[i][j] * dp[j] % MOD\n        dp[i] %= MOD\nprint(dp[n])\n"
    },
    "3883": {
        "negative_solution": "a, b = map(int, input().split())\nif a < b:\n    print(-1)\nelif a == b:\n    print(a)\nelse:\n    k = a // (2 * b)\n    if a % (2 * b) <= b:\n        print(a / (2 * k))\n    else:\n        print(a / (2 * k + 1))\n"
    },
    "3884": {
        "negative_solution": "n = int(input())\nm = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na = a[::-1] + a\nb = b[::-1] + b\nf = [0] * (2 * n + 1)\nf[0] = m\nfor i in range(1, 2 * n + 1):\n    f[i] = (f[i - 1] + a[i - 1] - 1) / a[i - 1]\n    if i != 2 * n:\n        f[i] = (f[i] + b[i] - 1) / b[i]\nif f[n] < m:\n    print(-1)\nelse:\n    print(f[2 * n] - m)\n"
    },
    "3885": {
        "negative_solution": "n = int(input())\nprint(n // 2)\n"
    },
    "3886": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\ns = \"What are you doing at the end of the world? Are you busy? Will you save us?\"\na, b, c = \"What are you doing while sending '\", \"'? Are you busy? Will you send '\", \"'?\"\nf = [len(s)]\nfor i in range(1, 55):\n    f.append(f[-1]*2 + len(a) + len(b) + len(c))\ndef solve(n, k):\n    if n == 0 or k <= len(a):\n        return a[k-1] if n == 0 or k <= len(a) else b[k-len(a)-1]\n    if k <= len(a) + f[n-1]:\n        return solve(n-1, k-len(a))\n    if k <= len(a) + f[n-1] + len(b):\n        return b[k-len(a)-f[n-1]-1]\n    if k <= len(a) + f[n-1]*2 + len(b):\n        return solve(n-1, k-len(a)-f[n-1]-len(b))\n    if k <= len(a) + f[n-1]*2 + len(b) + len(c):\n        return c[k-len(a)-f[n-1]*2-len(b)-1]\n    return '.'\nfor n, k in queries:\n    sys.stdout.write(solve(n, k) if n < 55 and k <= f[n] else '.')\n"
    },
    "3887": {
        "negative_solution": "s = input().strip().split()\nn = int(s[-1])\ns = s[:-2]\np = [i for i in range(len(s)) if s[i] == '+']\nm = [i for i in range(len(s)) if s[i] == '-']\nif len(p) + 1 - len(m) > n or len(p) + 1 < n - len(m):\n    print('Impossible')\nelse:\n    print('Possible')\n    a = [1] * (len(s) + 1)\n    d = n - len(p) - len(m) - 1\n    for i in p + [-1]:\n        while d > 0 and a[i + 1] < n:\n            a[i + 1] += 1\n            d -= 1\n    d = n - sum(a[i + 1] for i in p) + sum(a[i + 1] for i in m)\n    for i in m:\n        while d > 0 and a[i + 1] < n:\n            a[i + 1] += 1\n            d -= 1\n    for i in range(len(s)):\n        print(a[i], s[i], end=' ')\n    print(a[-1], '=', n)\n"
    },
    "3888": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = [list(map(int, input().split())) for _ in range(N)]\nB = [A[i][0] for i in range(N)]\nA = A[0]\n\nmex = [[0]*3 for _ in range(3)]\nmex[0][1] = mex[1][0] = 1\nmex[0][2] = mex[2][0] = 1\nmex[1][2] = mex[2][1] = 0\n\nC = [[0]*3 for _ in range(N+1)]\nD = [[0]*3 for _ in range(N+1)]\nfor i in range(N):\n    for j in range(3):\n        C[i+1][j] = C[i][j] + (A[i] == j)\n        D[i+1][j] = D[i][j] + (B[i] == j)\n\ndp = [[0]*3 for _ in range(3)]\nfor i in range(N):\n    ndp = [[0]*3 for _ in range(3)]\n    for j in range(3):\n        for k in range(3):\n            for l in range(3):\n                for m in range(3):\n                    if mex[j][k] == l and mex[l][m] == j:\n                        cnt = [C[i+1][j] - C[i][l], D[i+1][j] - D[i][l], N - C[i+1][j] - D[i+1][j] + C[i][l] + D[i][l]]\n                        ndp[k][m] = max(ndp[k][m], dp[j][k] + cnt[0] + cnt[1] + cnt[2])\n    dp = ndp\n\nprint(N*N - max(max(dp)))\n"
    },
    "3889": {
        "negative_solution": "n = int(input())\ns = input()\ncounts = [0]*26\nfor i in range(n):\n    counts[ord(s[i])-97] += 1\nif n == 1 or max(counts) >= 2:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n"
    },
    "3890": {
        "negative_solution": "def main():\n    n, k = map(int, input().split())\n    MOD = 10**9 + 7\n    ans = pow(k, k - 1, MOD) * pow(n - k, n - k, MOD) % MOD\n    print(ans)\n\nmain()\n"
    },
    "3891": {
        "negative_solution": "n, m = map(int, input().split())\ntable = [list(input()) for _ in range(n)]\nx1 = y1 = 115\nx2 = y2 = -1\nfor i in range(n):\n    for j in range(m):\n        if table[i][j] == 'B':\n            x1 = min(x1, i)\n            y1 = min(y1, j)\n            x2 = max(x2, i)\n            y2 = max(y2, j)\nprint((x1 + x2) // 2 + 1, (y1 + y2) // 2 + 1)\n"
    },
    "3892": {
        "negative_solution": "from sys import stdin, stdout\nfrom collections import defaultdict\nn, m = map(int, stdin.readline().split())\na = [0]*n\nb = [0]*n\nc = [0]*n\nd = defaultdict(list)\nfor _ in range(m):\n    x, y = map(int, stdin.readline().split())\n    x -= 1\n    y -= 1\n    a[x] += 1\n    d[x].append((y-x+n)%n)\nfor i in range(n):\n    if d[i]:\n        d[i].sort()\n        b[i] = d[i][0]\n        c[i] = d[i][-1]\nmaxi = max(a[i]*n+c[i] for i in range(n))\nfor i in range(n):\n    if a[i]:\n        stdout.write(str(max(maxi-b[i], (a[i]-1)*n+c[i]))+' ')\n    else:\n        stdout.write(str(maxi)+' ')\n"
    },
    "3893": {
        "negative_solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nn = int(input())\nlines = [list(map(int, input().split())) for _ in range(n)]\nhome_blocks = [a*x1 + b*y1 + c > 0 for a, b, c in lines]\nuniversity_blocks = [a*x2 + b*y2 + c > 0 for a, b, c in lines]\nsteps = sum(h != u for h, u in zip(home_blocks, university_blocks))\nprint(steps)\n"
    },
    "3894": {
        "negative_solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    if k % 2 == 0:\n        f = [0, 1, 0, 1, 2, 0, 2, 0]\n        for i in range(8, 100005):\n            if i % 2 == 0:\n                f.append(1)\n            else:\n                f.append(0)\n    else:\n        f = [0, 1, 2, 0, 1, 2, 0, 1]\n        for i in range(8, 100005):\n            if i % 2 == 0:\n                f.append(i - 2)\n            else:\n                f.append(0)\n    xor = 0\n    for i in range(n):\n        if a[i] < 100005:\n            xor ^= f[a[i]]\n        else:\n            xor ^= f[a[i] % 2]\n    if xor == 0:\n        print(\"Nicky\")\n    else:\n        print(\"Kevin\")\n\nsolve()\n"
    },
    "3895": {
        "negative_solution": "n = int(input())\nf = list(map(int, input().split()))\nf = [x-1 for x in f]\ng = [-1]*n\nh = [-1]*n\nm = 0\nfor i in range(n):\n    if h[f[i]] == -1:\n        h[f[i]] = m\n        m += 1\n    g[i] = h[f[i]]\nfor i in range(m):\n    if h[i] == -1:\n        print(-1)\n        exit(0)\nprint(m)\nfor i in range(n):\n    print(g[i]+1, end=' ')\nprint()\nfor i in range(m):\n    print(h[i]+1, end=' ')\n"
    },
    "3896": {
        "negative_solution": "MOD = 10**9 + 7\nx = input().strip()\nn = len(x)\nx = int(x, 2)\nans = 0\nfor i in range(n):\n    if (x >> i) & 1:\n        ans += pow(2, i+1, MOD)\n        ans %= MOD\nprint((ans * pow(2, n-1, MOD)) % MOD)\n"
    },
    "3897": {
        "negative_solution": "from collections import Counter\nfrom math import sqrt\nfrom sys import stdin, stdout\n\nMOD = 10**9 + 7\nMAX = 10**4 + 10\nfact = [1] * MAX\ninv = [1] * MAX\ninvfact = [1] * MAX\n\ndef power(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef C(n, k):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD\n\nfor i in range(1, MAX):\n    fact[i] = i * fact[i - 1] % MOD\n    inv[i] = power(i, MOD - 2)\n    invfact[i] = inv[i] * invfact[i - 1] % MOD\n\nn = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\nm = 1\nfor x in a:\n    m *= x\nfactors = Counter()\nfor i in range(2, int(sqrt(m)) + 1):\n    while m % i == 0:\n        factors[i] += 1\n        m //= i\nif m > 1:\n    factors[m] += 1\nres = 1\nfor x in factors.values():\n    res = res * C(x + n - 1, n - 1) % MOD\nstdout.write(str(res))\n"
    },
    "3898": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na0 = a.index(0)\nb0 = b.index(0)\na = a[a0:] + a[:a0]\nb = b[b0:] + b[:b0]\nif a == b or a == b[::-1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n"
    },
    "3899": {
        "negative_solution": "import math\nfrom heapq import *\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    tasks = sorted([(a[i], b[i]) for i in range(n)], reverse=True)\n    l = 0\n    r = 10**11\n    while r - l > 1:\n        mid = (l + r) // 2\n        q = []\n        cur = 0\n        for i in range(n):\n            while len(q) > 0 and cur + q[0] <= tasks[i][1]:\n                cur += heappop(q)\n            heappush(q, tasks[i][1] - cur)\n            cur = tasks[i][1]\n            if len(q) > 0 and q[0] < 0:\n                cur += heappop(q)\n        while len(q) > 0:\n            cur += heappop(q)\n        if cur * mid <= sum(a[i] * b[i] for i in range(n)):\n            r = mid\n        else:\n            l = mid\n    print(math.ceil(r * 1000))\n\nsolve()\n"
    },
    "3900": {
        "negative_solution": "import sys\nfrom collections import defaultdict\nfrom bisect import bisect_right\n\nn, p = map(int, input().split())\na = [0] * n\nb = [0] * n\ncnt = defaultdict(int)\ncnt2 = [0] * (n + 1)\nfor i in range(n):\n    x, y = map(int, input().split())\n    if x > y:\n        x, y = y, x\n    a[i] = x - 1\n    b[i] = y - 1\n    cnt[(x - 1, y - 1)] += 1\na.sort()\nb.sort()\nres = 0\nfor x, y in cnt.keys():\n    cnt2[cnt[(x, y)]] += 1\n    res += bisect_right(a, y - 1) - cnt[(x, y)]\nfor i in range(n, 0, -1):\n    cnt2[i - 1] += cnt2[i]\nfor x, y in cnt.keys():\n    if cnt[(x, y)] < p:\n        res -= cnt2[p - cnt[(x, y)]]\n    if cnt[(x, y)] + bisect_right(a, x - 1) >= p and cnt[(x, y)] + bisect_right(a, y - 1) < p:\n        res += 1\nprint(res)\n"
    },
    "3901": {
        "negative_solution": "from math import gcd\nfrom sys import stdin, stdout\n\ndef solve():\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    if 1 in a:\n        stdout.write(str(n - a.count(1)) + '\\n')\n        return\n    ans = float('inf')\n    for i in range(n):\n        g = a[i]\n        for j in range(i + 1, n):\n            g = gcd(g, a[j])\n            if g == 1:\n                ans = min(ans, j - i)\n                break\n    if ans == float('inf'):\n        stdout.write('-1\\n')\n    else:\n        stdout.write(str(ans + n - 1) + '\\n')\n\nsolve()\n"
    },
    "3902": {
        "negative_solution": "s = input()\nn = len(s)\ndp = [[0]*n for _ in range(4)]\ndp[2][n-2] = dp[3][n-3] = 1\nsuffixes = set([s[n-2:], s[n-3:]])\nfor i in range(n-4, -1, -1):\n    if s[i:i+2] != s[i+2:i+4]:\n        dp[2][i] = dp[2][i+2] or dp[3][i+2]\n    if s[i:i+3] != s[i+3:i+6]:\n        dp[3][i] = dp[2][i+3] or dp[3][i+3]\n    if dp[2][i]:\n        suffixes.add(s[i:i+2])\n    if dp[3][i]:\n        suffixes.add(s[i:i+3])\nsuffixes = sorted(list(suffixes))\nprint(len(suffixes))\nfor suffix in suffixes:\n    print(suffix)\n"
    },
    "3903": {
        "negative_solution": "from collections import deque\nfrom sys import stdin, stdout\n\ndx = [-1, 0, 1, 0]\ndy = [0, 1, 0, -1]\n\ndef bfs(x, y, z):\n    d = [[-1]*m for _ in range(n)]\n    d[x][y] = 0\n    q = deque()\n    q.append((x, y))\n    while q:\n        x, y = q.popleft()\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if nx>=0 and nx<n and ny>=0 and ny<m and d[nx][ny]==-1 and s[nx][ny]!='#':\n                d[nx][ny] = d[x][y] + 1\n                q.append((nx, ny))\n    for i in range(n):\n        for j in range(m):\n            if s[i][j] == '.':\n                dist[z][i][j] = d[i][j]\n            elif s[i][j] == '1':\n                dist[z][0][0] = min(dist[z][0][0], d[i][j])\n            elif s[i][j] == '2':\n                dist[z][0][1] = min(dist[z][0][1], d[i][j])\n            elif s[i][j] == '3':\n                dist[z][0][2] = min(dist[z][0][2], d[i][j])\n    return d\n\nn, m = map(int, stdin.readline().split())\ns = [list(stdin.readline().strip()) for _ in range(n)]\ndist = [[[1e9]*3 for _ in range(m)] for _ in range(3)]\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == '1':\n            d1 = bfs(i, j, 0)\n        elif s[i][j] == '2':\n            d2 = bfs(i, j, 1)\n        elif s[i][j] == '3':\n            d3 = bfs(i, j, 2)\nres = min(dist[0][0][1] + dist[0][0][2], dist[1][0][0] + dist[1][0][2], dist[2][0][0] + dist[2][0][1])\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == '.':\n            res = min(res, dist[0][i][j] + dist[1][i][j] + dist[2][i][j] - 2)\nif res >= 1e9:\n    stdout.write('-1\\n')\nelse:\n    stdout.write(str(res) + '\\n')\n"
    },
    "3904": {
        "negative_solution": "n = int(input().strip())\ns = input().strip()\ncnt = 0\nres = 0\nfor i in range(n):\n    if s[i] == '(':\n        cnt += 1\n    else:\n        cnt -= 1\n    if cnt < 0:\n        res += 1\n    if cnt == 0 and s[i] == ')':\n        res += 1\nif cnt != 0:\n    print(-1)\nelse:\n    print(res)"
    },
    "3905": {
        "negative_solution": "import sys\nfrom collections import defaultdict\n\ndef dfs1(v):\n    used[v] = True\n    for to in g[v]:\n        if not used[to]:\n            dfs1(to)\n    order.append(v)\n\ndef dfs2(v, cl):\n    comp[v] = cl\n    for to in gr[v]:\n        if comp[to] == -1:\n            dfs2(to, cl)\n\nn, m, h = map(int, sys.stdin.readline().split())\nu = list(map(int, sys.stdin.readline().split()))\ng = defaultdict(list)\ngr = defaultdict(list)\nfor _ in range(m):\n    a, b = map(int, sys.stdin.readline().split())\n    a -= 1\n    b -= 1\n    if (u[a] + 1) % h == u[b]:\n        g[a].append(b)\n        gr[b].append(a)\n    if (u[b] + 1) % h == u[a]:\n        g[b].append(a)\n        gr[a].append(b)\nused = [False] * n\norder = []\ncomp = [-1] * n\nfor i in range(n):\n    if not used[i]:\n        dfs1(i)\norder = order[::-1]\nj = 0\nfor i in range(n):\n    v = order[i]\n    if comp[v] == -1:\n        dfs2(v, j)\n        j += 1\ncnt = [0] * j\nfor i in range(n):\n    cnt[comp[i]] += 1\nmin_comp = min(range(j), key=lambda i: cnt[i])\nprint(cnt[min_comp])\nfor i in range(n):\n    if comp[i] == min_comp:\n        print(i + 1, end=' ')\n"
    },
    "3906": {
        "negative_solution": "MOD = 10**9 + 7\nn, m = map(int, input().split())\ndp = [0]*max(n, m)\ndp[0] = 2\ndp[1] = 4\nfor i in range(2, max(n, m)):\n    dp[i] = (dp[i-1] + dp[i-2]) % MOD\nprint((dp[n-1] + dp[m-1] - 2) % MOD)\n"
    },
    "3907": {
        "negative_solution": "import heapq\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\na.sort(key=lambda x: -x[1])\nheap = []\nans = 0\nfor q, w in a:\n    heapq.heappush(heap, w)\n    if len(heap) > 1:\n        ans += heapq.heappop(heap)\n    if len(heap) > 1:\n        ans += heapq.heappop(heap)\nwhile len(heap) > 1:\n    ans += heapq.heappop(heap)\nprint(ans)\n"
    },
    "3908": {
        "negative_solution": "s = input()\nn = len(s)\ncnt = [0]*26\ndp = [[0]*26 for _ in range(26)]\nfor i in range(n-1, -1, -1):\n    for j in range(26):\n        if ord(s[i])-ord('a') != j:\n            dp[ord(s[i])-ord('a')][j] += cnt[j]\n    cnt[ord(s[i])-ord('a')] += 1\nans = max(max(dp[i]) for i in range(26))\nans = max(ans, max(cnt))\nprint(ans)\n"
    },
    "3909": {
        "negative_solution": "n = int(input().strip())\np = 3\nwhile n % p == 0:\n    p *= 3\nprint(n // p + 1)\n"
    },
    "3910": {
        "negative_solution": "n = int(input())\na = [0]*(2*n+1)\nb = [0]*(2*n+1)\nc = [0]*(2*n+1)\nd = [0]*(2*n+1)\ne = [0]*(2*n+1)\nfor i in range(1, n+1):\n    x, y = map(int, input().split())\n    a[x] = a[y] = i\n    b[x] = y\n    b[y] = x\nfor i in range(1, 2*n+1):\n    if c[i] == 0:\n        c[i] = 1\n        c[b[i]] = 2\n        j = b[b[i]]\n        while c[j] == 0:\n            c[j] = 2\n            c[b[j]] = 1\n            j = b[b[j]]\nfor i in range(1, 2*n+1):\n    d[a[i]] = max(d[a[i]], c[i])\nfor i in range(1, 2*n+1):\n    e[a[i]] = max(e[a[i]], c[b[i]])\nfor i in range(1, n+1):\n    print(d[i], e[i])\n"
    },
    "3911": {
        "negative_solution": "n = int(input())\na = [0]*20\nfor i in range(n):\n    j = 0\n    while a[j] == 1:\n        a[j] = 0\n        j += 1\n    a[j] = 1\nfor i in range(20):\n    if a[i] == 1:\n        print(i+1, end = ' ')\n"
    },
    "3912": {
        "negative_solution": "from collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\ndef solve():\n    n = int(input())\n    s = input()\n    c = Counter(s)\n    g = reduce(gcd, c.values())\n    p = [k * (v // g) for k, v in c.items()]\n    p.sort()\n    print(g)\n    for _ in range(g):\n        print(''.join(p[i::g]), end=' ')\n\nsolve()\n"
    },
    "3913": {
        "negative_solution": "n = int(input())\ns = input()\nm = int(input())\nwords = [input() for _ in range(m)]\npossible = [word for word in words if all(s[i] == '*' or s[i] == word[i] for i in range(n))]\nletters = set(''.join(possible))\nrevealed = set(s.replace('*', ''))\nprint(len(letters - revealed))\n"
    },
    "3914": {
        "negative_solution": "import sys\nfrom bisect import bisect_right\n\ndef read():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef solve():\n    n, d, b = read()\n    a = read()\n    s = [0]*(n+1)\n    for i in range(1, n+1):\n        s[i] = s[i-1] + a[i-1]\n    ans = [0]*2\n    for _ in range(2):\n        l = 0\n        for r in range(n, 0, -2):\n            while l < n and l <= r and l <= r - d*(r-l+1>>1):\n                l += 1\n            if l == 0 or s[l-1] < (_+1)*b*(n-r+1>>1):\n                ans[_] += 1\n        a.reverse()\n        s = [0]*(n+1)\n        for i in range(1, n+1):\n            s[i] = s[i-1] + a[i-1]\n    print(min(ans))\n\nsolve()\n"
    },
    "3915": {
        "negative_solution": "def is_prime(n):\n    if n == 2:\n        return True\n    if n < 2 or n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_palindromic(n):\n    return str(n) == str(n)[::-1]\n\np, q = map(int, input().split())\nprimes = [0] * 200000\npalindromes = [0] * 200000\nprime_count = 0\npalindrome_count = 0\nfor i in range(1, 200000):\n    if is_prime(i):\n        prime_count += 1\n    if is_palindromic(i):\n        palindrome_count += 1\n    primes[i] = prime_count\n    palindromes[i] = palindrome_count\n\nresult = -1\nfor i in range(1, 200000):\n    if primes[i] * q <= p * palindromes[i]:\n        result = i\n\nif result == -1:\n    print(\"Palindromic tree is better than splay tree\")\nelse:\n    print(result)\n"
    },
    "3916": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nn = int(input())\nk = list(map(int,input().split()))\nk.sort()\ncnt = [0]*5001\nfor i in range(n):\n    cnt[k[i]] += 1\nfor i in range(1,5001):\n    cnt[i] += cnt[i-1]\nl = 0\nr = 5000\nwhile r-l>1:\n    mid = (l+r)//2\n    if cnt[mid]*2 >= n:\n        r = mid\n    else:\n        l = mid\nans = sum((abs(i-r)+1)*cnt[i] for i in range(r+1,5001))\nprint(ans)\n"
    },
    "3917": {
        "negative_solution": "n = int(input().strip())\na = list(map(int, input().strip().split()))\na = [0] + a\nfor i in range(2, n + 1):\n    a[i] += a[i - 1]\nans = float('inf')\nfor i in range(1, n + 1):\n    for j in range(i + 1, min(n + 1, i + 3)):\n        ans = min(ans, (i - j) ** 2 + (a[j - 1] - a[i]) ** 2)\nprint(ans)\n"
    },
    "3918": {
        "negative_solution": "import heapq\n\nn, k1, k2 = map(int, input().split())\nk = k1 + k2\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\npq = []\n\nfor i in range(n):\n    pq.append(-abs(a[i] - b[i]))\n\nheapq.heapify(pq)\n\nwhile k > 0:\n    max_diff = -heapq.heappop(pq)\n    heapq.heappush(pq, -abs(max_diff - 1))\n    k -= 1\n\nresult = 0\nfor i in range(n):\n    diff = -heapq.heappop(pq)\n    result += diff * diff\n\nprint(result)\n"
    },
    "3919": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nmod = 10**9+7\nN, M = map(int,input().split())\nS = input().strip()\nLR = [list(map(int,input().split())) for i in range(M)]\nLR.append([N+1,N+1])\nS += \"1\"\ndp = [[0]*(N+2) for i in range(N+2)]\ndp[0][0] = 1\ncum = [0]*(N+2)\ncum[0] = 1\ncnt = [0]*(N+2)\ncnt[0] = 1\ncnt[1] = S[0] == \"1\"\nfor i in range(1,N+1):\n    cnt[i+1] = cnt[i] + (S[i] == \"1\")\n    for j in range(i+1):\n        dp[i][j] = cum[j]\n        if j > cnt[i]:\n            dp[i][j] -= cum[cnt[i]]\n        dp[i][j] %= mod\n    for j in range(i+2):\n        cum[j] += dp[i][j]\n        cum[j] %= mod\nidx = 0\nfor i in range(1,N+1):\n    while LR[idx][0] == i+1:\n        l, r = LR[idx]\n        l -= 1\n        r -= 1\n        idx += 1\n        for j in range(r+1,l-1,-1):\n            for k in range(j-l+2):\n                dp[j][k] = dp[j-1][k]\n                if k > 0:\n                    dp[j][k] += dp[j-1][k-1]\n                dp[j][k] %= mod\n        for j in range(l,r+1):\n            cum[j+1] = (cum[j+1]+dp[j][j-l+1])%mod\nprint(sum(dp[N-1])%mod)\n"
    },
    "3920": {
        "negative_solution": ""
    },
    "3921": {
        "negative_solution": "import math\nfrom sys import stdin, stdout\nfrom collections import defaultdict as ddic\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import deque\nfrom collections import Counter as C\nfrom random import randint as R\nfrom heapq import heapify,heappop,heappush\nfrom itertools import permutations as P\nfrom math import factorial as F\ndef prime(n):\n    if n==1:\n        return False\n    if n==2 or n==3:\n        return True\n    if n%2==0 or n%3==0:\n        return False\n    i=5\n    w=2\n    while i*i<=n:\n        if n%i==0:\n            return False\n        i+=w\n        w=6-w\n    return True\ndef get_prime(n):\n    sieve=[True for _ in range(n+1)]\n    p=2\n    while p*p<=n:\n        if sieve[p]==True:\n            for i in range(p*p,n+1,p):\n                sieve[i]=False\n        p+=1\n    prime=[p for p in range(2,n) if sieve[p]]\n    return prime\ndef dist(a,b):\n    return abs(a[0]-b[0])+abs(a[1]-b[1])\ndef dist1(a,b):\n    return abs(a-b)\ndef pair(n):\n    return [(i,j) for i in range(n) for j in range(i+1,n)]\ndef sort_dict(d):\n    return sorted(d.items(), key=lambda x: x[1], reverse=True)\ndef sort_list(l):\n    l.sort(key=lambda x: x[1], reverse=True)\n    return l\ndef search(l,r,n):\n    while l<=r:\n        mid=(l+r)//2\n        if n==mid:\n            return True\n        if n<mid:\n            r=mid-1\n        else:\n            l=mid+1\n    return False\ndef search1(l,r,n):\n    while l<=r:\n        mid=(l+r)//2\n        if n==mid:\n            return mid\n        if n<mid:\n            r=mid-1\n        else:\n            l=mid+1\n    return -1\ndef sieve(n):\n    if n<2:\n        return []\n    prime=[True for _ in range(n+1)]\n    p=2\n    while p*p<=n:\n        if prime[p]==True:\n            for i in range(p*p,n+1,p):\n                prime[i]=False\n        p+=1\n    return [p for p in range(2,n+1) if prime[p]]\ndef lcm(a,b):\n    return (a*b)//math.gcd(a,b)\ndef binary(n):\n    return bin(n).replace(\"0b\",\"\")\ndef isPowerofTwo(n):\n    return (n and (not(n&(n-1))))\ndef decimal(s):\n    return int(s,2)\ndef isPrime(n):\n    if n<=1:\n        return False\n    if n<=3:\n        return True\n    if n%2==0 or n%3==0:\n        return False\n    p=5\n    while p*p<=n:\n        if n%p==0 or n%(p+2)==0:\n            return False\n        p+=6\n    return True\ndef isPerfectSquare(n):\n    p=int(math.sqrt(n))\n    return p*p==n\ndef mostFrequent(arr,n):\n    Hash=dict()\n    for i in range(n):\n        if arr[i] in Hash.keys():\n            Hash[arr[i]]+=1\n        else:\n            Hash[arr[i]]=1\n    max_count=0\n    res=-1\n    for i in Hash:\n        if (max_count<Hash[i]):\n            res=i\n            max_count=Hash[i]\n    return res\ndef allPrimes(n):\n    prime=[True for i in range(n+1)]\n    p=2\n    while(p*p<=n):\n        if(prime[p]==True):\n            for i in range(p*p,n+1,p):\n                prime[i]=False\n        p+=1\n    return [p for p in range(2,n) if prime[p]]\ndef factors(n):\n    return [i for i in range(1,n+1) if n%i==0]\ndef nCr(n, r):\n    return F(n) / (F(r) * F(n - r))\ndef nPr(n,r):\n    return F(n)//F(n-r)\ndef lower_bound(li, num):\n    answer = len(li) - 1\n    start = 0\n    end = len(li) - 1\n    while (start <= end):\n        middle = (end + start) // 2\n        if (li[middle] >= num):\n            answer = middle\n            end = middle - 1\n        else:\n            start = middle + 1\n    return (answer)\ndef upper_bound(li, num):\n    answer = -1\n    start = 0\n    end = len(li) - 1\n    while(start <= end):\n        middle = (end + start) // 2\n        if (li[middle] <= num):\n            answer = middle\n            start = middle + 1\n        else:\n            end = middle - 1\n    return (answer + 1)\ndef abs(x):\n    return x if x >=0 else -x\ndef binary_search(li, val, lb, ub):\n    ans = 0\n    while(lb <= ub):\n        mid = (lb+ub)//2\n        if li[mid] > val:\n            ub = mid-1\n        else:\n            lb = mid+1\n    return ub\ndef kadane(x): #maximum sum contiguous subarray\n    sum_so_far = 0\n    current_sum = 0\n    for i in range(len(x)):\n        current_sum += x[i]\n        if current_sum < 0:\n            current_sum = 0\n        else:\n            sum_so_far = max(sum_so_far,current_sum)\n    return sum_so_far\ndef pref(li):\n    pref_sum = [0]\n    for i in range(len(li)):\n        pref_sum.append(pref_sum[-1]+li[i])\n    return pref_sum\ndef graph(n,m):\n    adj=[[] for _ in range(n+1)]\n    for _ in range(m):\n        a,b=map(int,input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    return adj\ndef dfs(v,vis,adj):\n    vis[v]=True\n    for i in adj[v]:\n        if not vis[i]:\n            dfs(i,vis,adj)\ndef bfs(v,vis,adj):\n    q=deque([v])\n    while q:\n        ele=q.popleft()\n        if not vis[ele]:\n            vis[ele]=True\n        for i in adj[ele]:\n            if not vis[i]:\n                q.append(i)\ndef bfs_dis(v,vis,adj,dis):\n    q=deque([v])\n    dis[v]=0\n    while q:\n        ele=q.popleft()\n        if not vis[ele]:\n            vis[ele]=True\n        for i in adj[ele]:\n            if not vis[i]:\n                q.append(i)\n                dis[i]=dis[ele]+1\ndef count(li):\n    return [C(li[i]) for i in range(len(li))]\ndef solve():\n    n=int(input())\n    a=list(map(int,input().split()))\n    dp=[0]*100005\n    dp[0]=1\n    for i in range(1,n):\n        dp[i]=1\n        for j in range(1,int(a[i]**0.5)+1):\n            if a[i]%j==0:\n                if j*j!=a[i]:\n                    dp[i]=max(dp[i],dp[bl(a,a[i]//j)-1]+1)\n                dp[i]=max(dp[i],dp[bl(a,j)-1]+1)\n    print(max(dp))\nsolve()\n"
    },
    "3922": {
        "negative_solution": "from collections import deque\n\ndef bfs(start, goal):\n    queue = deque([(start, '')])\n    visited = set([start])\n    while queue:\n        state, moves = queue.popleft()\n        if state == goal:\n            return moves\n        for move in generate_moves(state):\n            new_state = apply_move(state, move)\n            if new_state not in visited:\n                queue.append((new_state, moves + move))\n                visited.add(new_state)\n    return None\n\ndef generate_moves(state):\n    # Generate all possible moves for the given state.\n    # This depends on the position of the empty space and the positions of the organs that can be moved into it.\n    # ...\n\ndef apply_move(state, move):\n    # Apply the given move to the state and return the new state.\n    # ...\n\nt = int(input())\nfor _ in range(t):\n    k = int(input())\n    grid = [list(map(str, input().split())) for _ in range(2)]\n    start = ''.join(sum(grid, []))\n    goal = ''.join(map(str, range(1, 4*k+2))) + 'E'\n    moves = bfs(start, goal)\n    if moves is None:\n        print('SURGERY FAILED')\n    else:\n        print('SURGERY COMPLETE')\n        # Print the sequence of moves and the shortcuts.\n        # ...\n"
    },
    "3923": {
        "negative_solution": "import sys\nfrom collections import deque\n\ndef solve():\n    n, a, b = map(int, sys.stdin.readline().split())\n    if a == 1 or b == 1:\n        print(' '.join(map(str, range(1, n + 1))))\n        return\n    if a == b or a > 2 and b > 2 or n < a and n < b:\n        print(-1)\n        return\n    if n == 1:\n        print(1)\n        return\n    if n == 2:\n        if a == 2 or b == 2:\n            print('1 2')\n        else:\n            print(-1)\n        return\n    if n == 3:\n        if a == 2 or b == 2:\n            print('1 2 3')\n        else:\n            print(-1)\n        return\n    if n < max(a, b):\n        print(-1)\n        return\n    ans = deque()\n    for i in range(1, max(a, b) + 1):\n        ans.append(i)\n    n -= max(a, b)\n    while n > 0:\n        if n >= min(a, b):\n            ans.appendleft(ans[0] - 1)\n            n -= min(a, b)\n        else:\n            ans.appendleft(ans[0] - 1)\n            n -= 1\n    print(' '.join(map(str, ans)))\n\nsolve()\n"
    },
    "3924": {
        "negative_solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nbags = 0\nleft = 0\nfor i in range(n):\n    if a[i] + left <= k:\n        bags += 1\n        left = 0\n    else:\n        bags += (a[i] + left) // k\n        left = (a[i] + left) % k\nif left > 0:\n    bags += 1\nprint(bags)\n"
    },
    "3925": {
        "negative_solution": "s = input()\ns += s\nn = len(s)\nf = [0]*n\nf[0] = 1\nfor i in range(1, n):\n    if s[i] != s[i-1]:\n        f[i] = f[i-1] + 1\n    else:\n        f[i] = 1\nprint(min(max(f), len(s)//2))\n"
    },
    "3926": {
        "negative_solution": "from collections import deque\nfrom sys import stdin, stdout\n\nn, m = map(int, stdin.readline().split())\nr, c = map(int, stdin.readline().split())\nx, y = map(int, stdin.readline().split())\nmaze = [list(stdin.readline().strip()) for _ in range(n)]\nvisited = [[False]*m for _ in range(n)]\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\nr -= 1\nc -= 1\nq = deque([(r, c, x, y)])\nvisited[r][c] = True\ncnt = 1\nwhile q:\n    x, y, left, right = q.popleft()\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if nx < 0 or nx >= n or ny < 0 or ny >= m or visited[nx][ny] or maze[nx][ny] == '*':\n            continue\n        if i == 1 and left > 0:\n            visited[nx][ny] = True\n            q.append((nx, ny, left-1, right))\n            cnt += 1\n        elif i == 3 and right > 0:\n            visited[nx][ny] = True\n            q.append((nx, ny, left, right-1))\n            cnt += 1\n        elif i == 0 or i == 2:\n            visited[nx][ny] = True\n            q.appendleft((nx, ny, left, right))\n            cnt += 1\nstdout.write(str(cnt))\n"
    },
    "3927": {
        "negative_solution": "from collections import Counter\nfrom math import factorial as f\ndef C(n, k):\n    return f(n) // f(k) // f(n - k)\nn = int(input())\na = list(map(int, input().split()))\nc = Counter(a)\ndp = [0] * 10005\ndp[0] = 1\nfor x, y in c.items():\n    for i in range(sum(a), -1, -1):\n        for j in range(1, min(i // x, y) + 1):\n            dp[i] = dp[i] + dp[i - j * x] * C(y, j) * C(sum(a) - y + j, j)\n            dp[i] %= 10**9 + 7\nif len(c) == 1:\n    print(n)\nelse:\n    for x, y in c.items():\n        if dp[y * x] > 1:\n            print(1)\n            break\n    else:\n        print(min(c.values()))\n"
    },
    "3928": {
        "negative_solution": "n, a, b = map(int, input().split())\ns = input()\n\ndp = [0] * (n + 1)\ndp[0] = a\nfor i in range(1, n):\n    dp[i] = dp[i - 1] + a\n    p = [0] * 26\n    maxl = 0\n    for j in range(i - 1, -1, -1):\n        if p[ord(s[j]) - ord('a')] != 0:\n            maxl = max(maxl, p[ord(s[j]) - ord('a')])\n        p[ord(s[j]) - ord('a')] = max(p[ord(s[j]) - ord('a')], min(maxl + 1, i - j))\n        if j + p[ord(s[j]) - ord('a')] - 1 == i:\n            dp[i] = min(dp[i], dp[j - 1] + b)\nprint(dp[n - 1])\n"
    },
    "3929": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\nmod = 10**9+7\n\nN, K = map(int, input().split())\nfact = [1]*(N+1)\ninv = [1]*(N+1)\nfor i in range(1, N+1):\n    fact[i] = fact[i-1]*i%mod\n    inv[i] = pow(fact[i], mod-2, mod)\n\ndef comb(n, r):\n    if n < r or r < 0:\n        return 0\n    return fact[n]*inv[r]*inv[n-r]%mod\n\nans = 0\nfor i in range(K, N+1):\n    ans += comb(N, i)*comb(i-1, K-1)\n    ans %= mod\nprint(ans)\n"
    },
    "3930": {
        "negative_solution": "from collections import defaultdict\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    s = [0]*(n+1)\n    for i in range(n):\n        s[i+1] = s[i] + a[i]\n    d = defaultdict(int)\n    d[0] = 1\n    ans = 0\n    for i in range(1, n+1):\n        x = 1\n        while abs(x) <= 10**14:\n            if s[i]-x in d:\n                ans += d[s[i]-x]\n            if k == 1 or k == -1:\n                break\n            x *= k\n        d[s[i]] += 1\n    print(ans)\nsolve()\n"
    },
    "3931": {
        "negative_solution": "from collections import defaultdict\nfrom heapq import *\n\ndef solve():\n    n, a, b, k, f = map(int, input().split())\n    cost = defaultdict(int)\n    prev = None\n    for _ in range(n):\n        u, v = sorted(input().split())\n        if (u, v) == prev:\n            cost[(u, v)] += b\n        else:\n            cost[(u, v)] += a\n        prev = (u, v)\n    costs = list(cost.values())\n    costs.sort(reverse=True)\n    for i in range(min(k, len(costs))):\n        if costs[i] > f:\n            costs[i] = f\n    print(sum(costs))\n\nsolve()\n"
    },
    "3932": {
        "negative_solution": "def solve():\n    n = int(input())\n    c = list(map(int, input().split()))\n    c.sort()\n    if c[0] != 1 or c[-1] != n:\n        print(\"NO\")\n        return\n    c = c[::-1]\n    p = [0] * n\n    p[0] = 1\n    for i in range(1, n):\n        p[i] = p[i-1] + c[i-1]\n    for i in range(n-2, -1, -1):\n        if p[i] < i+1 or p[i] % 2 != (i+1) % 2:\n            print(\"NO\")\n            return\n    print(\"YES\")\n\nsolve()\n"
    },
    "3933": {
        "negative_solution": "n = int(input())\ntemps = list(map(int, input().split()))\ndiffs = [temps[i] - temps[i-1] for i in range(1, n)]\nif len(set(diffs)) == 1:\n    print(temps[-1] + diffs[0])\nelse:\n    print(temps[-1])\n"
    },
    "3934": {
        "negative_solution": "from collections import defaultdict\n\ndef solve():\n    n = int(input())\n    degree = defaultdict(int)\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        degree[u] += 1\n        degree[v] += 1\n    for i in range(1, n+1):\n        if degree[i] == 2:\n            return \"NO\"\n    return \"YES\"\n\nprint(solve())\n"
    },
    "3935": {
        "negative_solution": "import sys\nfrom collections import deque\nn = int(input())\na = list(map(int,input().split()))\na.sort()\nb = deque()\nfor i in range(n):\n    if len(b) == 0 or b[-1] < a[i]:\n        b.append(a[i])\n    else:\n        b.appendleft(a[i])\nprint(n - len(b))\nfor i in range(n - len(b)):\n    print(a[i], end = ' ')\n"
    },
    "3936": {
        "negative_solution": "MOD = 10**9+7\nN = int(input())\nS1 = input()\nS2 = input()\ni = 0\nans = 1\npre = 0\nwhile i < N:\n    if S1[i] == S2[i]:\n        if pre == 0:\n            ans = ans*3%MOD\n        elif pre == 1:\n            ans = ans*2%MOD\n        else:\n            ans = ans*1%MOD\n        pre = 1\n        i += 1\n    else:\n        if pre == 0:\n            ans = ans*6%MOD\n        elif pre == 1:\n            ans = ans*2%MOD\n        else:\n            ans = ans*3%MOD\n        pre = 2\n        i += 2\nprint(ans)\n"
    },
    "3937": {
        "negative_solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = a[0]\n    for i in range(1, k):\n        l = lcm(l, a[i])\n        if l > n:\n            return \"NO\"\n    g = l\n    for i in range(k):\n        if g % a[i] != 0 or (i and gcd(a[i - 1], a[i]) != a[i]):\n            return \"NO\"\n    return \"YES\" if g <= m else \"NO\"\n\nprint(solve())\n"
    },
    "3938": {
        "negative_solution": "import sys\nfrom heapq import *\ninf = 10**18\nn,m = map(int,input().split())\nrect = [list(map(int,input().split())) for _ in range(m)]\nX = sorted(list(set([x for x1,y1,x2,y2 in rect for x in [x1,x2+1]])))\nY = sorted(list(set([y for x1,y1,x2,y2 in rect for y in [y1,y2+1]])))\nrect = [[X.index(x1),Y.index(y1),X.index(x2+1),Y.index(y2+1)] for x1,y1,x2,y2 in rect]\nn = len(X)\nm = len(Y)\nX = [X[0]-1]+X+[X[-1]]\nY = [Y[0]-1]+Y+[Y[-1]]\ndx = [X[i+1]-X[i] for i in range(n)]\ndy = [Y[i+1]-Y[i] for i in range(m)]\nG = [[0]*(m+1) for _ in range(n+1)]\nfor x1,y1,x2,y2 in rect:\n    G[x1][y1] += 1\n    G[x2][y1] -= 1\n    G[x1][y2] -= 1\n    G[x2][y2] += 1\nfor i in range(n+1):\n    for j in range(m):\n        G[i][j+1] += G[i][j]\nfor j in range(m+1):\n    for i in range(n):\n        G[i+1][j] += G[i][j]\ndp = [[inf]*(m+1) for _ in range(n+1)]\ndp[0][0] = 0\nfor i in range(n+1):\n    for j in range(m+1):\n        if G[i][j] > 0:\n            continue\n        if i > 0:\n            dp[i][j] = min(dp[i][j],dp[i-1][j]+dy[j])\n        if j > 0:\n            dp[i][j] = min(dp[i][j],dp[i][j-1]+dx[i])\nprint(dp[-1][-1])\n"
    },
    "3939": {
        "negative_solution": "t = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    if k not in a:\n        print('no')\n    else:\n        if n == 1:\n            print('yes')\n        else:\n            ans = 'no'\n            for i in range(n):\n                if a[i] == k and ((i > 0 and a[i - 1] >= k) or (i < n - 1 and a[i + 1] >= k) or (i > 1 and a[i - 2] >= k) or (i < n - 2 and a[i + 2] >= k)):\n                    ans = 'yes'\n                    break\n            print(ans)\n"
    },
    "3940": {
        "negative_solution": "n, m = map(int, input().split())\na = [0]*n\nb = [0]*n\nc = [0]*n\nfor i in range(m):\n    l, r = map(int, input().split())\n    l -= 1\n    r -= 1\n    b[l] += 1\n    b[r+1] -= 1\nfor i in range(1, n):\n    b[i] += b[i-1]\nfor i in range(n):\n    c[i] = b[i]\nc.sort()\nprint(c[0])\nfor i in range(n):\n    a[i] = c[0] - b[i]\nfor i in range(1, n):\n    a[i] = max(a[i], a[i-1])\nfor i in range(n):\n    print(a[i], end=' ')\n"
    },
    "3941": {
        "negative_solution": "from collections import defaultdict\nn, m = map(int, input().split())\nr = list(map(int, input().split()))\ng = defaultdict(list)\nfor i in range(m):\n    a = list(map(int, input().split()))[1:]\n    for j in a:\n        g[j-1].append(i)\ns = [set() for _ in range(m)]\nfor i in range(n):\n    for j in g[i]:\n        s[j] |= g[i]\nc = [0]*m\nfor i in range(m):\n    for j in s[i]:\n        c[j] += 1\nd = [0]*m\nfor i in range(n):\n    if r[i] == 0:\n        for j in g[i]:\n            d[j] = 1\nif max(c) > 2 or (max(c) == 2 and max(d) == 1):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n"
    },
    "3942": {
        "negative_solution": "s = input()\nopen_brackets = 0\nclose_brackets = 0\nhashes = 0\nfor i in s:\n    if i == '(':\n        open_brackets += 1\n    elif i == ')':\n        close_brackets += 1\n    else:\n        hashes += 1\nif open_brackets < close_brackets + hashes:\n    print(-1)\nelse:\n    for i in range(hashes - 1):\n        print(1)\n    print(open_brackets - close_brackets - hashes + 1)\n"
    },
    "3943": {
        "negative_solution": "def solve(a, b):\n    if a == 0:\n        return -b * b, 'x' * b\n    if b == 0:\n        return a * a, 'o' * a\n    if a == 1:\n        return 1 - b * b, 'x' * (b // 2) + 'o' + 'x' * (b - b // 2)\n    ans = -1\n    for i in range(1, b + 1):\n        t = b // i\n        r = b % i\n        cur = (i - r) * (t * t) + r * ((t + 1) * (t + 1))\n        if i + 1 <= a:\n            cur += (a - i - 1) + (i + 1) * (i + 1)\n        else:\n            cur += (a - 1) * (a - 1) + 1\n        if cur > ans:\n            ans = cur\n            if i + 1 <= a:\n                s = 'o' * (a - i - 1) + 'x' * t + 'o' + 'x' * (t + 1 - 1) + 'o' + 'x' * (b - (i - r) * t - r * (t + 1)) + 'o' * (i - r) + 'x' * (t + 1) + 'o' * r\n            else:\n                s = 'o' * (a - 1) + 'x' * t + 'o' + 'x' * (b - (i - r) * t - r * (t + 1)) + 'o' * (i - r) + 'x' * (t + 1) + 'o' * r\n    return ans, s\n\na, b = map(int, input().split())\nv, s = solve(a, b)\nprint(v)\nprint(s)\n"
    },
    "3944": {
        "negative_solution": "MOD = 10**9+7\nN, M, K = map(int, input().split())\nfact = [1]*(N+M+K+1)\ninv = [1]*(N+M+K+1)\nfor i in range(1, N+M+K+1):\n    fact[i] = fact[i-1]*i%MOD\n    inv[i] = pow(fact[i], MOD-2, MOD)\ndef C(n, r):\n    if r < 0 or r > n: return 0\n    return fact[n]*inv[r]*inv[n-r]%MOD\ndef solve(n, m, k):\n    res = pow(3, n+m+k, MOD)\n    for i in range(m+k+1, n+m+k+1):\n        res -= C(n+m+k, i)*pow(2, i, MOD)*pow(3, n+m+k-i, MOD)%MOD\n        res %= MOD\n    return res\nprint((solve(N, M, K)+solve(M, N, K)+solve(K, N, M))%MOD)\n"
    },
    "3945": {
        "negative_solution": "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [[0]*m for _ in range(n)]\nc = [[0]*m for _ in range(n)]\nfor i in range(n):\n    temp = [(a[i][j], j) for j in range(m)]\n    temp.sort()\n    j = 0\n    for k in range(m):\n        if k and temp[k][0] != temp[k-1][0]:\n            j += 1\n        b[i][temp[k][1]] = j+1\nfor j in range(m):\n    temp = [(a[i][j], i) for i in range(n)]\n    temp.sort()\n    i = 0\n    for k in range(n):\n        if k and temp[k][0] != temp[k-1][0]:\n            i += 1\n        c[temp[k][1]][j] = i+1\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = max(b[i][j], c[i][j]) + max(m-b[i][j], n-c[i][j])\nfor i in range(n):\n    print(*a[i])\n"
    },
    "3946": {
        "negative_solution": "MOD = 998244353\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nw = list(map(int, input().split()))\nsum1 = sum(w[i] for i in range(n) if a[i])\nsum2 = sum(w[i] for i in range(n) if not a[i])\nf = [[0]*(m+1) for _ in range(m+1)]\nf[m][0] = sum1 + sum2\nfor i in range(m, 0, -1):\n    for j in range(min(i, sum1), -1, -1):\n        k = i - j\n        if k > sum2:\n            continue\n        p1 = (j + 1) % MOD if j < sum1 else 0\n        p2 = (k + 1) % MOD if k < sum2 else 0\n        f[i-1][j+1] = (f[i][j] * p1) % MOD\n        f[i-1][j] = (f[i][j] * p2) % MOD\nfor i in range(n):\n    if a[i]:\n        print(w[i] * (f[0][sum1] - sum1 + i) % MOD)\n    else:\n        print(w[i] * (f[0][sum1] - sum1) % MOD)\n"
    },
    "3947": {
        "negative_solution": "import heapq\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int,input().split()))\nif n == 1:\n    print(0)\n    sys.exit()\nif n == 2:\n    print(min(a))\n    sys.exit()\na = [0] + a + [0]\nheap = []\nfor i in range(1,n+1):\n    heapq.heappush(heap,(-a[i],i))\nans = 0\nvis = [0]*(n+2)\nl = [0]*(n+2)\nr = [0]*(n+2)\nfor i in range(1,n+1):\n    l[i] = i-1\n    r[i] = i+1\nwhile heap:\n    val,idx = heapq.heappop(heap)\n    val = -val\n    ans += min(a[l[idx]],a[r[idx]])\n    if a[l[idx]] < a[r[idx]]:\n        r[l[idx]] = r[idx]\n        l[r[idx]] = l[idx]\n    else:\n        l[r[idx]] = l[idx]\n        r[l[idx]] = r[idx]\nprint(ans)\n"
    },
    "3948": {
        "negative_solution": "from collections import deque\n\nn, k = map(int, input().split())\nedges = [0] * (n + 1)\nadj = [[] for _ in range(n + 1)]\ndist = [0] * (n + 1)\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges[u] += 1\n    edges[v] += 1\n    adj[u].append(v)\n    adj[v].append(u)\n\nq = deque()\nfor i in range(1, n + 1):\n    if edges[i] == 1:\n        q.append(i)\n\nwhile q:\n    v = q.popleft()\n    for u in adj[v]:\n        edges[u] -= 1\n        if edges[u] == 1:\n            q.append(u)\n        dist[u] = max(dist[u], dist[v] + 1)\n\ncenter = dist.index(max(dist))\nif dist[center] != k or edges[center] < 3:\n    print(\"No\")\nelse:\n    for v in adj[center]:\n        if dist[v] != k - 1 or edges[v] < 3:\n            print(\"No\")\n            break\n    else:\n        print(\"Yes\")\n"
    },
    "3949": {
        "negative_solution": "n, m = map(int, input().split())\na = [list(input()) for _ in range(n)]\nrow = [0]*n\ncol = [0]*m\nr = [0]*n\nc = [0]*m\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == '#':\n            row[i] += 1\n            col[j] += 1\nfor i in range(n):\n    if row[i] > 0:\n        l = a[i].index('#')\n        r = m - a[i][::-1].index('#') - 1\n        if a[i][l:r+1] != ['#']*row[i]:\n            print(-1)\n            exit(0)\nfor j in range(m):\n    if col[j] > 0:\n        l = [a[i][j] for i in range(n)].index('#')\n        r = n - [a[i][j] for i in range(n)][::-1].index('#') - 1\n        if [a[i][j] for i in range(n)][l:r+1] != ['#']*col[j]:\n            print(-1)\n            exit(0)\nfor i in range(n):\n    if row[i] > 0:\n        r[i] = 1\nfor j in range(m):\n    if col[j] > 0:\n        c[j] = 1\nif sum(r) != r.count(1) or sum(c) != c.count(1):\n    print(-1)\nelse:\n    print(r.count(1))\n"
    },
    "3950": {
        "negative_solution": "import sys\nfrom collections import deque\nn, q = map(int, input().split())\na = list(map(int, input().split()))\na.append(0)\nb = [0]*(n+1)\nc = deque()\nfor i in range(n, -1, -1):\n    if a[i] > a[i+1]:\n        b[i] = a[i]\n        c.appendleft(a[i])\n    else:\n        b[i] = b[i+1]\nif len(c) != q or c[0] != 1:\n    print(\"NO\")\n    sys.exit()\nc.appendleft(0)\nfor i in range(n):\n    if a[i] == 0:\n        a[i] = c[a[i+1]]\nprint(\"YES\")\nprint(*a[:-1])\n"
    },
    "3951": {
        "negative_solution": "import sys\nfrom collections import Counter\nfrom math import gcd\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    c = Counter(a)\n    ans = []\n    for x in a:\n        if c[x] > 0:\n            for y in ans:\n                c[gcd(x, y)] -= 2\n            ans.append(x)\n            c[x] -= 1\n    print(*ans)\n\nsolve()\n"
    },
    "3952": {
        "negative_solution": "import sys\nfrom operator import itemgetter\nfrom collections import defaultdict\nfrom itertools import accumulate\n\ndef add(i, x):\n    while i <= n:\n        bit[i] += x\n        i += i & -i\n\ndef sum(i):\n    s = 0\n    while i > 0:\n        s += bit[i]\n        i -= i & -i\n    return s\n\nn = int(sys.stdin.readline())\nxy = sorted([list(map(int, sys.stdin.readline().split())) for _ in range(n)], key=itemgetter(1, 0))\nxy.append([0, 0])\n\nbit = [0]*(n+1)\ncnt = defaultdict(int)\npre = list(accumulate([1]*n))\nres = 0\n\nj = 0\nfor i in range(n):\n    if xy[i][1] != xy[i+1][1]:\n        for k in range(j, i+1):\n            if cnt[xy[k][0]] == 0:\n                add(xy[k][0], 1)\n            cnt[xy[k][0]] += 1\n        for k in range(j, i+1):\n            if cnt[xy[k][0]] == 1:\n                add(xy[k][0], -1)\n            cnt[xy[k][0]] -= 1\n        res += sum(xy[i][0])*(sum(xy[i][0])-1)//2 - (pre[i]-sum(xy[i][0]))*(pre[i]-sum(xy[i][0])-1)//2\n        j = i+1\nres += pre[n-1]*(pre[n-1]-1)//2\n\nprint(res)\n"
    },
    "3953": {
        "negative_solution": "n = int(input())\na = [list(input()) for _ in range(n)]\nr = [i for i in range(n) if 'E' not in a[i]]\nc = [i for i in range(n) if all(a[j][i] != 'E' for j in range(n))]\nif r:\n    for i in r:\n        print(i + 1, a[i].index('.') + 1)\nelif c:\n    for i in c:\n        print(a[j][i] for j in range(n)).index('.') + 1, i + 1\nelse:\n    print(-1)\n"
    },
    "3954": {
        "negative_solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = [0] * (n + 1)\nfor i in range(1, n + 1):\n    b[i] = b[i - 1] + a[i - 1]\nans = -1e9\nfor l in range(n):\n    for r in range(l, n):\n        out = sorted(a[:l] + a[r + 1:])[-k:]\n        in_ = sorted(a[l:r + 1])\n        while len(out) > 0 and len(in_) > 0 and out[-1] > in_[0]:\n            out.pop()\n            in_.pop(0)\n        ans = max(ans, b[r + 1] - b[l] - sum(in_))\nprint(ans)\n"
    },
    "3955": {
        "negative_solution": "import sys\nfrom collections import defaultdict\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [defaultdict(int) for _ in range(k+1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(k+1):\n        for key in dp[j]:\n            dp[j+1][key^a[i]] += dp[j][key]\n\nmax_val = 0\nfor i in range(k+1):\n    for key in dp[i]:\n        max_val = max(max_val, key)\n\nprint(max_val)\n"
    },
    "3956": {
        "negative_solution": "import sys\ninput = sys.stdin.readline\n\nMOD = 998244353\nK, N = map(int, input().split())\nfact = [1] * (2 * K + 1)\nfact_inv = [1] * (2 * K + 1)\nfor i in range(1, 2 * K + 1):\n    fact[i] = fact[i - 1] * i % MOD\n    fact_inv[i] = pow(fact[i], MOD - 2, MOD)\n\ndef comb(n, r):\n    if n < r or r < 0:\n        return 0\n    return fact[n] * fact_inv[r] * fact_inv[n - r] % MOD\n\ndef solve(i):\n    res = 0\n    for j in range(i // 2 + 1):\n        res += comb(N, j) * comb(N - j + K - 1, N) % MOD\n        res %= MOD\n    return res\n\nfor i in range(2, K + 1):\n    print(solve(i) * 2 % MOD)\nfor i in range(K + 1, 2 * K):\n    print((solve(i) * 2 - comb(N, i - K) * comb(N + K - 1, N) % MOD + MOD) % MOD)\n"
    },
    "3957": {
        "negative_solution": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nn, k = map(int, input().split())\nuniv = [0] * (n + 1)\nfor u in map(int, input().split()):\n    univ[u] = 1\ng = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\nq = deque([1])\np = [0] * (n + 1)\nused = [0] * (n + 1)\nused[1] = 1\nwhile q:\n    v = q.popleft()\n    for to in g[v]:\n        if not used[to]:\n            used[to] = 1\n            p[to] = v\n            q.append(to)\nfor v in range(n, 0, -1):\n    univ[p[v]] += univ[v]\nprint(sum(sorted(univ, reverse=True)[:k]))\n"
    },
    "3958": {
        "negative_solution": "s = input().strip()\nn = len(s)\na, b = [], []\nres = [[] for _ in range(n)]\nfor i in range(n):\n    if s[i] == '0':\n        if len(b) == 0:\n            a.append(i)\n        else:\n            x = b.pop()\n            a.append(x)\n        res[a[-1]].append(i+1)\n    else:\n        if len(a) == 0:\n            print(-1)\n            exit(0)\n        else:\n            x = a.pop()\n            b.append(x)\n        res[b[-1]].append(i+1)\nif len(a) < len(b):\n    print(-1)\nelse:\n    print(len(a))\n    for i in range(len(a)):\n        print(len(res[i]), *res[i])\n"
    },
    "3959": {
        "negative_solution": "from collections import defaultdict\nfrom math import factorial\nmod = 10**9+7\n\nn, m = map(int,input().split())\npokemons = defaultdict(list)\n\nfor _ in range(n):\n    gym = list(map(int,input().split()))[1:]\n    gym.sort()\n    for i in range(len(gym)):\n        pokemons[gym[i]].append(i+1)\n\npokemons = sorted(pokemons.values())\n\nanswer = 1\ncount = 1\n\nfor i in range(1,len(pokemons)):\n    if pokemons[i] == pokemons[i-1]:\n        count += 1\n    else:\n        answer = answer * factorial(count) % mod\n        count = 1\n\nanswer = answer * factorial(count) % mod\n\nprint(answer)\n"
    },
    "3960": {
        "negative_solution": "n = int(input().strip())\na = list(map(int,input().strip().split()))\nb = [0]*(n-1)\nfor i in range(n-1):\n    b[i] = abs(a[i]-a[i+1])*(-1)**i\nc = [0]*(n-1)\nd = [0]*(n-1)\nc[0] = b[0]\nd[0] = -b[0]\nfor i in range(1,n-1):\n    c[i] = max(b[i],c[i-1]+b[i])\n    d[i] = max(-b[i],d[i-1]-b[i])\nprint(max(max(c),max(d)))\n"
    },
    "3961": {
        "negative_solution": "n = int(input())\np = list(map(int, input().split()))\np = [0] + p\ndp = [0]*(n+2)\ns = [0]*(n+2)\nmod = 10**9+7\nfor i in range(1, n+1):\n    dp[i] = (2*dp[i-1] - dp[p[i]-1] + 2) % mod\nprint(dp[n])\n"
    },
    "3962": {
        "negative_solution": "n = int(input())\nl = []\nr = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    l.append(a)\n    r.append(b)\nl.sort()\nr.sort()\nprint(max(sum(l), sum(r)) + n)\n"
    },
    "3963": {
        "negative_solution": "import sys\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom operator import mul\nmod = 10**9+7\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nm = int(input())\na = [1]+a\nb = [0]+b\nc = [0]*(n+1)\nfor i in range(1,n+1):\n    c[i] = c[i-1]+b[i]\n    if a[i]>20 or a[i-1]*a[i]>m:\n        a[i] = min(a[i],m//a[i-1]+1)\ndp = [0]*(m+1)\ndp[0] = 1\nfor i in range(1,n+1):\n    ndp = [0]*(m+1)\n    for j in range(m+1):\n        l = max(0,j-a[i]*b[i])\n        r = min(c[i-1],j)+1\n        if l<r:\n            ndp[j] = (dp[r-1]-(dp[l-1] if l else 0))%mod\n    dp,ndp = ndp,dp\n    dp[0] = 1\n    for j in range(1,m+1):\n        dp[j] = (dp[j-1]+dp[j])%mod\nprint(dp[m])\n"
    },
    "3964": {
        "negative_solution": "def solve():\n    n, m, b, mod = map(int, input().split())\n    a = list(map(int, input().split()))\n    dp = [[0]*(b+1) for _ in range(m+1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(1, m+1):\n            for k in range(a[i], b+1):\n                dp[j][k] = (dp[j][k] + dp[j-1][k-a[i]]) % mod\n    print(sum(dp[m]) % mod)\n\nsolve()\n"
    },
    "3965": {
        "negative_solution": "n = int(input())\np = list(map(int, input().split()))\nvowels = ['a', 'e', 'i', 'o', 'u', 'y']\nfor i in range(n):\n    line = input()\n    syllables = sum([1 for c in line if c in vowels])\n    if syllables != p[i]:\n        print('NO')\n        break\nelse:\n    print('YES')\n"
    },
    "3966": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\ns = sum(a)\nres = s\nfor i in range(n-1):\n    s -= a[i]\n    res += s + a[i]\nprint(res)\n"
    },
    "3967": {
        "negative_solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    s = [0]*(n+1)\n    for i in range(n):\n        s[i+1] = s[i] + a[i]\n    l = 1\n    r = 10**9+1\n    while r - l > 1:\n        m = (l + r) // 2\n        t = 0\n        for i in range(n):\n            t += (a[i] + m - 1) // m\n        if t <= k:\n            r = m\n        else:\n            l = m\n    print(r)\n\nsolve()\n"
    },
    "3968": {
        "negative_solution": "import heapq\n\ndef solve():\n    N, D = map(int, input().split())\n    C, *infected = map(int, input().split())\n    infected = set(infected)\n    people = [list(map(int, input().split())) + [i+1] for i in range(N)]\n    people.sort()\n\n    infected_times = [(t, i) for s, t, i in people if i in infected]\n    heapq.heapify(infected_times)\n\n    for _ in range(D):\n        new_infected = []\n        while people and people[0][0] <= (infected_times[0][0] if infected_times else float('inf')):\n            s, t, i = people.pop(0)\n            if infected_times and infected_times[0][0] <= s:\n                _, j = heapq.heappop(infected_times)\n                infected.add(j)\n            if i not in infected:\n                new_infected.append((t, i))\n        for t, i in new_infected:\n            heapq.heappush(infected_times, (t, i))\n\n    print(*sorted(infected))\n\nsolve()\n"
    },
    "3969": {
        "negative_solution": "n, m = map(int, input().split())\nplants = [0]*n\nfor i in range(n):\n    s, x = map(float, input().split())\n    plants[i] = int(s)\ndp = [1]*n\nfor i in range(n):\n    for j in range(i):\n        if plants[i] >= plants[j]:\n            dp[i] = max(dp[i], dp[j]+1)\nprint(n - max(dp))\n"
    },
    "3970": {
        "negative_solution": "def k_multiple_free_set():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    used = [False]*n\n    ans = 0\n    for i in range(n):\n        if not used[i]:\n            ans += 1\n            if a[i]*k in a:\n                used[a.index(a[i]*k)] = True\n    print(ans)\n\nk_multiple_free_set()\n"
    },
    "3971": {
        "negative_solution": "from collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\nc = Counter(a)\ndp = [0]*(max(a)+1)\nfor i in range(min(a), max(a)+1):\n    dp[i] = max(dp[i-2] + i*c[i], dp[i-1])\nprint(dp[-1])\n"
    },
    "3972": {
        "negative_solution": "MOD = 10**9+7\nn = int(input())\ndp = [0]*(n+1)\ndp[1] = 1\ns = 1\nfor i in range(2,n+1):\n    dp[i] = (dp[i-1] + s - dp[i-2]) % MOD\n    s = (s + dp[i]) % MOD\nprint((pow(n, n, MOD) - s + dp[n-1]) % MOD)\n"
    },
    "3973": {
        "negative_solution": ""
    },
    "3974": {
        "negative_solution": "def min_people(s):\n    people = 0\n    max_people = 0\n    for i in s:\n        if i == '+':\n            people += 1\n        else:\n            if people == 0:\n                max_people += 1\n            else:\n                people -= 1\n    return max_people + people\n\ns = input().strip()\nprint(min_people(s))\n"
    },
    "3975": {
        "negative_solution": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nn = int(input())\ng = [0]*n\nval = [0]*n\ntyp = [0]*n\nfor i in range(n):\n    a = list(input().split())\n    if a[0] == 'IN':\n        typ[i] = 0\n        val[i] = int(a[1])\n    else:\n        if a[0] == 'AND':\n            typ[i] = 1\n        elif a[0] == 'OR':\n            typ[i] = 2\n        elif a[0] == 'XOR':\n            typ[i] = 3\n        else:\n            typ[i] = 4\n        g[i] = list(map(int, a[1:]))\n        g[i] = [x-1 for x in g[i]]\nrev = [[] for _ in range(n)]\nfor i in range(n):\n    for j in g[i]:\n        rev[j].append(i)\nq = deque([0])\nused = [0]*n\nwhile q:\n    v = q.popleft()\n    used[v] = 1\n    for to in rev[v]:\n        if not used[to]:\n            q.append(to)\nfor v in range(n-1, -1, -1):\n    if typ[v] == 0:\n        continue\n    elif typ[v] == 1:\n        val[v] = val[g[v][0]] & val[g[v][1]]\n    elif typ[v] == 2:\n        val[v] = val[g[v][0]] | val[g[v][1]]\n    elif typ[v] == 3:\n        val[v] = val[g[v][0]] ^ val[g[v][1]]\n    else:\n        val[v] = val[g[v][0]] ^ 1\nval1 = val[0]\nval2 = [0]*n\nfor v in range(n):\n    if typ[v] == 0:\n        continue\n    elif typ[v] == 1:\n        val2[v] = val2[g[v][0]] & val[g[v][1]] | val[g[v][0]] & val2[g[v][1]]\n    elif typ[v] == 2:\n        val2[v] = val2[g[v][0]] | val[g[v][1]] | val[g[v][0]] | val2[g[v][1]]\n    elif typ[v] == 3:\n        val2[v] = val2[g[v][0]] ^ val[g[v][1]] ^ val[g[v][0]] ^ val2[g[v][1]]\n    else:\n        val2[v] = val2[g[v][0]] ^ 1\nfor i in range(n):\n    if typ[i] == 0:\n        print((val1 ^ val2[0]) ^ (val[i] ^ 1), end='')\n"
    },
    "3976": {
        "negative_solution": "from collections import Counter\nfrom sys import stdin, stdout\n\nn, m, p = map(int, stdin.readline().split())\na = list(map(int, stdin.readline().split()))\nb = list(map(int, stdin.readline().split()))\n\nb_counter = Counter(b)\nres = []\nfor i in range(p):\n    a_counter = Counter(a[i:i + m * p:p])\n    for j in range(i, n, p):\n        if a_counter == b_counter:\n            res.append(j // p - m + 2)\n        if j + p < n:\n            a_counter[a[j + p]] += 1\n        a_counter[a[j]] -= 1\n        if a_counter[a[j]] == 0:\n            del a_counter[a[j]]\nstdout.write(str(len(res)) + '\\n' + ' '.join(map(str, sorted(res))) + '\\n')\n"
    },
    "3977": {
        "negative_solution": "from collections import defaultdict\nn, m, k = map(int, input().split())\ngov = list(map(int, input().split()))\nedges = defaultdict(list)\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges[u].append(v)\n    edges[v].append(u)\nvisited = [0]*(n+1)\ncomp = []\nfor node in gov:\n    stack = [node]\n    visited[node] = 1\n    size = 0\n    while stack:\n        v = stack.pop()\n        size += 1\n        for u in edges[v]:\n            if not visited[u]:\n                visited[u] = 1\n                stack.append(u)\n    comp.append(size)\ncomp.sort()\ncomp[-1] += n - sum(comp)\nprint(sum(x*(x-1)//2 for x in comp) - m)\n"
    },
    "3978": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\ncnt = [0]*101\nfor i in range(n):\n    if cnt[a[i]] == 0:\n        for j in range(a[i], 101, a[i]):\n            cnt[j] = 1\nprint(sum(cnt))\n"
    },
    "3979": {
        "negative_solution": "import sys\nfrom collections import defaultdict\nfrom heapq import *\n\nn, m = map(int, input().split())\nwords = [list(map(int, input().split()))[1:] for _ in range(n)]\ngraph = defaultdict(list)\nindegree = [0] * (m + 1)\noutdegree = [0] * (m + 1)\ncapital = [0] * (m + 1)\nfor i in range(n - 1):\n    a = words[i]\n    b = words[i + 1]\n    j = 0\n    while j < len(a) and j < len(b) and a[j] == b[j]:\n        j += 1\n    if j == len(a) or j == len(b):\n        if len(a) > len(b):\n            print('No')\n            sys.exit(0)\n        continue\n    if a[j] > b[j]:\n        graph[b[j]].append(a[j])\n        indegree[a[j]] += 1\n    else:\n        graph[a[j]].append(b[j])\n        outdegree[a[j]] += 1\n        capital[a[j]] = 1\nqueue = [i for i in range(1, m + 1) if indegree[i] == 0]\nheapify(queue)\nwhile queue:\n    u = heappop(queue)\n    for v in graph[u]:\n        indegree[v] -= 1\n        if indegree[v] == 0:\n            heappush(queue, v)\n    if capital[u] and outdegree[u]:\n        print('No')\n        sys.exit(0)\nprint('Yes')\nprint(sum(capital))\nfor i in range(1, m + 1):\n    if capital[i]:\n        print(i, end=' ')\n"
    },
    "3980": {
        "negative_solution": "def solve(n):\n    a = [0]*(n+1)\n    b = [0]*(n+1)\n    for i in range(n+1):\n        a[i] = i\n    for i in range(n, -1, -1):\n        if b[i] == 0:\n            j = i\n            while a[j] != i:\n                b[j] = a[j]\n                j = a[j]\n            b[j] = i\n    return sum(b), b\n\nn = int(input())\nm, b = solve(n)\nprint(m)\nprint(*b)\n"
    },
    "3981": {
        "negative_solution": "from sys import stdin, stdout\nfrom math import atan2, pi\nfrom operator import itemgetter\nfrom itertools import groupby\nfrom collections import Counter\n\ndef read():\n    return stdin.readline().strip()\n\ndef read_ints():\n    return list(map(int, read().split()))\n\ndef solve():\n    n, m = read_ints()\n    a = [read_ints() for _ in range(n)]\n    b = [read_ints() for _ in range(m)]\n    a = sorted([(atan2(y, x) + pi) % (2 * pi) for x, y in a])\n    b = sorted([(atan2(y, x) + pi) % (2 * pi) for x, y in b])\n    a = a + [x + 2 * pi for x in a]\n    b = b + [x + 2 * pi for x in b]\n    j = 0\n    for i in range(n):\n        while a[i] > b[j]:\n            j += 1\n        if a[i] + pi <= b[j]:\n            return False\n    return True\n\ndef main():\n    stdout.write('YES\\n' if solve() else 'NO\\n')\n\nmain()\n"
    },
    "3982": {
        "negative_solution": "MOD = 10**9 + 7\nm = int(input())\ndp = [0]*3005\ndp[0] = 1\nfor i in range(1, 3005):\n    dp[i] = dp[i-1]\n    if i >= 2:\n        dp[i] += dp[i-2]\n    if i >= 3:\n        dp[i] += dp[i-3]\n    if i >= 4:\n        dp[i] += dp[i-4]\n    dp[i] %= MOD\ns = [0]*3005\ns[0] = 1\nfor i in range(1, 3005):\n    s[i] = s[i-1] + dp[i]\n    s[i] %= MOD\na = [0]*3005\nb = [0]*3005\nfor _ in range(m):\n    c = int(input())\n    if c == 0:\n        a = [0] + a[:-1]\n    else:\n        b = [0] + b[:-1]\n    a[0] = s[b[0]]\n    b[0] = s[a[0]]\n    print((s[a[0] + b[0]] - a[1] - b[2] - a[3] - b[4] + 5*MOD) % MOD)\n"
    },
    "3983": {
        "negative_solution": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\ndef bfs():\n    dist = [-1]*n\n    dist[0] = 0\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        for nv in g[v]:\n            if dist[nv] == -1:\n                dist[nv] = dist[v] + 1\n                q.append(nv)\n    return dist\nt = int(input())\nfor _ in range(t):\n    n,m = map(int,input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        a,b = map(int,input().split())\n        a -= 1\n        b -= 1\n        g[a].append(b)\n        g[b].append(a)\n    dist = bfs()\n    if dist[n-1]%2 == 0:\n        print(\"First\")\n    else:\n        print(\"Second\")\n"
    },
    "3984": {
        "negative_solution": "s = input()\nmin_char = s[0]\nprint('Mike')\nfor i in range(1, len(s)):\n    if s[i] > min_char:\n        print('Ann')\n    else:\n        print('Mike')\n        min_char = min(min_char, s[i])\n"
    },
    "3985": {
        "negative_solution": "import sys\nfrom collections import defaultdict\nfrom math import sqrt\n\ndef solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    g = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    vis = [0]*n\n    ans = 0\n    for i in range(n):\n        if vis[i] == 0:\n            vis[i] = 1\n            q = [i]\n            p = []\n            while len(q) > 0:\n                u = q.pop()\n                p.append(a[u])\n                for v in g[u]:\n                    if vis[v] == 0:\n                        vis[v] = 1\n                        q.append(v)\n            p.sort()\n            for i in range(2, int(sqrt(p[0]))+1):\n                while all(x%i == 0 for x in p):\n                    p = [x//i for x in p]\n                    ans += 1\n            while all(x%2 == 0 for x in p):\n                p = [x//2 for x in p]\n                ans += 1\n    print(ans)\n\nsolve()\n"
    },
    "3986": {
        "negative_solution": "def find_string(n, k):\n    if k > n or k == 1 and n > 1:\n        return \"-1\"\n    elif k == 1 and n == 1:\n        return \"a\"\n    else:\n        base = \"ab\" * ((n - k + 2) // 2) + \"a\" * ((n - k + 2) % 2)\n        extra = \"\".join(chr(97 + i) for i in range(2, k))\n        return base + extra\n\nn, k = map(int, input().split())\nprint(find_string(n, k))\n"
    },
    "3987": {
        "negative_solution": "n = int(input())\na = list(map(int, input().split()))\na = [0] + a\nf = [[0]*2005 for _ in range(2005)]\ng = [[0]*2005 for _ in range(2005)]\nc = [0]*2005\nd = [0]*2005\nfor i in range(1, n+1):\n    c[i] = c[i-1] + (a[i] == 1)\n    d[i] = d[i-1] + (a[i] == 2)\nfor i in range(1, n+1):\n    for j in range(i, n+1):\n        f[i][j] = max(f[i][j-1], c[i-1] + d[j] - d[i-1] + c[n] - c[j])\n        g[i][j] = max(g[i][j-1], f[i][j] + d[n] - d[j])\nprint(g[1][n])\n"
    },
    "3988": {
        "negative_solution": "import sys\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    used[v] = True\n    for u in g[v]:\n        if not used[u]:\n            dfs(u, v)\n            if p != -1 and (v, u) in undirected:\n                ans[undirected[(v, u)]] = '+'\n    if p != -1 and (p, v) in undirected:\n        ans[undirected[(p, v)]] = '-'\n\ndef dfs2(v):\n    used[v] = True\n    for u in g[v]:\n        if not used[u]:\n            dfs2(u)\n            if (v, u) in undirected:\n                ans[undirected[(v, u)]] = '-'\n\nn, m, s = map(int, sys.stdin.readline().split())\ns -= 1\ng = defaultdict(list)\nundirected = {}\nans = [''] * m\nused = [False] * n\n\nfor i in range(m):\n    t, u, v = map(int, sys.stdin.readline().split())\n    u -= 1\n    v -= 1\n    if t == 1:\n        g[u].append(v)\n    else:\n        g[u].append(v)\n        g[v].append(u)\n        undirected[(u, v)] = i\n        undirected[(v, u)] = i\n        ans[i] = '+'\n\ndfs(s, -1)\nprint(ans.count('+'))\nprint(''.join(ans))\n\nused = [False] * n\nfor i in range(n):\n    if i != s and not used[i]:\n        dfs2(i)\n\nprint(ans.count('+'))\nprint(''.join(ans))\n"
    },
    "3989": {
        "negative_solution": "def solve():\n    a = input().strip()\n    a = sorted(a)\n    a.remove('1')\n    a.remove('6')\n    a.remove('8')\n    a.remove('9')\n    a = ''.join(a)\n    for i in range(7, 1000, 7):\n        if i % 7 == 0 and str(i).find('0') == -1 and str(i).find('1') == -1 and str(i).find('6') == -1 and str(i).find('8') == -1 and str(i).find('9') == -1:\n            b = str(i)\n            break\n    for i in range(len(a) + 1):\n        if int(a[:i] + '1689' + a[i:] + b) % 7 == 0:\n            print(a[:i] + '1689' + a[i:] + b)\n            return\n    print(0)\n\nsolve()\n"
    },
    "3990": {
        "negative_solution": "from collections import deque\ndef solve():\n    n, m = map(int, input().split())\n    g = [[0]*n for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u][v] = g[v][u] = 1\n    if g[0][n-1] == 1:\n        g = [[1-x for x in row] for row in g]\n    dist = [float('inf')]*n\n    dist[0] = 0\n    q = deque([0])\n    while q:\n        v = q.popleft()\n        for u in range(n):\n            if g[v][u] == 1 and dist[u] == float('inf'):\n                dist[u] = dist[v] + 1\n                q.append(u)\n    if dist[n-1] == float('inf'):\n        print(-1)\n    else:\n        print(dist[n-1])\n\nsolve()\n"
    },
    "3991": {
        "negative_solution": "def solve():\n    n = int(input())\n    x = sorted(map(int, input().split()))\n    p = [1]\n    for i in range(1, n):\n        p.append(p[-1] * 2 % (10**9 + 7))\n    ans = 0\n    for i in range(n):\n        ans = (ans + x[i] * (p[i] - p[n - i - 1])) % (10**9 + 7)\n    print(ans)\n\nsolve()\n"
    },
    "3992": {
        "negative_solution": "import sys\nfrom collections import deque\nfrom math import sqrt\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    divisors = []\n    for i in range(2, int(sqrt(s))+1):\n        if s % i == 0:\n            divisors.append(i)\n            while s % i == 0:\n                s //= i\n    if s > 1:\n        divisors.append(s)\n    ans = float('inf')\n    for d in divisors:\n        cur = 0\n        for i in range(n):\n            cur += a[i]\n            a[i] %= d\n            if a[i] > d // 2:\n                a[i] -= d\n            cur -= a[i]\n        a.append(0)\n        q = deque()\n        res = 0\n        for i in range(n+1):\n            while a[i] < 0 and q:\n                x, y = q.popleft()\n                t = min(y, -a[i])\n                res += t * (i - x)\n                y -= t\n                a[i] += t\n                if y:\n                    q.appendleft((x, y))\n            if a[i] > 0:\n                q.append((i, a[i]))\n        ans = min(ans, res)\n    print(ans if ans != float('inf') else -1)\n\nsolve()\n"
    },
    "3993": {
        "negative_solution": "n, m, k = map(int, input().split())\np = list(map(int, input().split()))\np = [i-1 for i in p]\nres = 0\ncnt = 0\nwhile p:\n    page = (p[0]-cnt)//k\n    while p and (p[0]-cnt)//k == page:\n        p.pop(0)\n        cnt += 1\n    res += 1\nprint(res)\n"
    },
    "3994": {
        "negative_solution": "n = int(input())\ns = list(map(int, list(input())))\na = [0]*10000\nfor i in range(n):\n    x, y = map(int, input().split())\n    for j in range(y, 10000, x):\n        a[j] += 1\n    for j in range(y):\n        a[j] += s[i]\nprint(max(a))\n"
    },
    "3995": {
        "negative_solution": "n, k = map(int, input().split())\ns = \"10\" * ((n - k) // 2 + 1) + \"1\" * ((n - k) % 2)\nprint(s[:n])\n"
    },
    "3996": {
        "negative_solution": "MOD = 10**9+7\ndef power(x, y):\n    if y == 0:\n        return 1\n    elif y % 2 == 0:\n        return power(x, y // 2)**2 % MOD\n    else:\n        return x * power(x, y // 2)**2 % MOD\n\nk = int(input())\na = list(map(int, input().split()))\nn = 1\nfor i in range(k):\n    n = n * a[i] % (MOD - 1)\nprint(power(3, n) * power(power(3, MOD - 2), 2) % MOD, '/', power(3, 2) % MOD, sep='')\n"
    },
    "3997": {
        "negative_solution": "import sys\nfrom bisect import bisect_right\ninput = sys.stdin.readline\n\ndef add_edge(u, v, w):\n    G[u].append((v, w))\n    G[v].append((u, w))\n\ndef dfs(v, p, d):\n    dp[v] = bisect_right(D, d - a[v]) - 1\n    D.append(d)\n    for to, cost in G[v]:\n        if to == p:\n            continue\n        dfs(to, v, d + cost)\n    D.pop()\n    if dp[v] != -1:\n        dp[v] = dp[D[dp[v]]]\n    dp[D[dp[v] + 1]] = v\n\nn = int(input())\na = list(map(int, input().split()))\nG = [[] for _ in range(n)]\ndp = [-1] * n\nD = [-10**18]\nfor i in range(n - 1):\n    p, w = map(int, input().split())\n    p -= 1\n    add_edge(p, i + 1, w)\ndfs(0, -1, 0)\nfor i in range(n):\n    print(i - dp[i])\n"
    },
    "3998": {
        "negative_solution": "from heapq import *\nn = int(input())\na = list(map(int,input().split()))\nb = [(-a[i],i+1) for i in range(n)]\nheapify(b)\nc = []\nwhile b[0][0] != b[-1][0]:\n    d = []\n    for i in range(min(5,len(b))):\n        x = heappop(b)\n        d.append(x[1])\n        if x[0] != 0:\n            heappush(b,(x[0]+1,x[1]))\n    c.append(d)\nprint(-b[0][0])\nprint(len(c))\nfor x in c:\n    d = [0]*n\n    for y in x:\n        d[y-1] = 1\n    print(''.join(map(str,d)))\n"
    },
    "3999": {
        "negative_solution": "import sys\nfrom collections import defaultdict\nfrom math import factorial\nfrom operator import mul\nfrom functools import reduce\n\ndef comb(n, r):\n    if n < r: return 0\n    return factorial(n) // (factorial(n - r) * factorial(r))\n\ndef solve():\n    N = int(input())\n    C = [list(map(int, input().split())) for _ in range(N)]\n    for c in C:\n        c.sort()\n    C.sort()\n    color = defaultdict(int)\n    for c in C:\n        for x in c:\n            color[x] += 1\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    used = defaultdict(int)\n    for i in range(N):\n        while i < N and C[i] == C[i - 1]:\n            i += 1\n        x = [color[c] for c in C[i - 1]]\n        for j in range(i - 1, -1, -1):\n            dp[j + 1] += dp[j] * comb(x[0], i - j) * comb(x[1] - x[0], i - j) * comb(x[2] - x[1], i - j) * comb(x[3] - x[2], i - j)\n            dp[j + 1] %= mod\n            for k in range(4):\n                x[k] -= 1\n        for c in C[i - 1]:\n            color[c] -= i\n        used[tuple(C[i - 1])] += 1\n    ans = dp[6]\n    for v in used.values():\n        for i in range(1, v + 1):\n            ans = ans * i % mod\n    print(ans)\n\nmod = 10**9 + 7\nsolve()\n"
    }
}